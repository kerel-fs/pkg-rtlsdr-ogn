From 54a07c768693aabde2e9553dfc4f82de038c80e6 Mon Sep 17 00:00:00 2001
From: "Fabian P. Schmidt" <kerel-fs@gmx.de>
Date: Wed, 11 Jan 2017 22:42:37 +0100
Subject: [PATCH 1/6] Move sources files into ./src/ directory

---
 alloc.h                  |   28 -
 asciitime.h              |   60 --
 boxfilter.h              |  161 -----
 buffer.h                 |  593 ------------------
 fft.h                    |  368 -----------
 gpu_fft.c                |  135 ----
 gpu_fft.h                |  101 ---
 gpu_fft_shaders.c        |  102 ----
 gpu_fft_twiddles.c       |  315 ----------
 gsm_scan.cc              |  296 ---------
 hex/shader_1024k.hex     |  948 -----------------------------
 hex/shader_128k.hex      |  735 ----------------------
 hex/shader_16k.hex       |  688 ---------------------
 hex/shader_1k.hex        |  523 ----------------
 hex/shader_2048k.hex     | 1353 ----------------------------------------
 hex/shader_256.hex       |  359 -----------
 hex/shader_256k.hex      |  861 --------------------------
 hex/shader_2k.hex        |  765 -----------------------
 hex/shader_32k.hex       |  697 ---------------------
 hex/shader_4096k.hex     | 1523 ----------------------------------------------
 hex/shader_4k.hex        |  514 ----------------
 hex/shader_512.hex       |  494 ---------------
 hex/shader_512k.hex      |  983 ------------------------------
 hex/shader_64k.hex       |  940 ----------------------------
 hex/shader_8k.hex        |  603 ------------------
 hex/shader_trans.hex     |  126 ----
 image.h                  |  268 --------
 jpeg.h                   |  128 ----
 mailbox.c                |  258 --------
 mailbox.h                |   47 --
 ogn-rf.cc                | 1068 --------------------------------
 pulsefilter.h            |   69 ---
 r2fft.h                  |  191 ------
 r2fft_test.cc            |   52 --
 rtlsdr-ogn               |  245 --------
 rtlsdr-ogn.conf          |    8 -
 rtlsdr.h                 |  294 ---------
 scripts/rtlsdr-ogn       |  245 ++++++++
 scripts/rtlsdr-ogn.conf  |    8 +
 serialize.h              |   25 -
 socket.h                 |  601 ------------------
 src/alloc.h              |   28 +
 src/asciitime.h          |   60 ++
 src/boxfilter.h          |  161 +++++
 src/buffer.h             |  593 ++++++++++++++++++
 src/fft.h                |  368 +++++++++++
 src/gpu_fft.c            |  135 ++++
 src/gpu_fft.h            |  101 +++
 src/gpu_fft_shaders.c    |  102 ++++
 src/gpu_fft_twiddles.c   |  315 ++++++++++
 src/gsm_scan.cc          |  296 +++++++++
 src/hex/shader_1024k.hex |  948 +++++++++++++++++++++++++++++
 src/hex/shader_128k.hex  |  735 ++++++++++++++++++++++
 src/hex/shader_16k.hex   |  688 +++++++++++++++++++++
 src/hex/shader_1k.hex    |  523 ++++++++++++++++
 src/hex/shader_2048k.hex | 1353 ++++++++++++++++++++++++++++++++++++++++
 src/hex/shader_256.hex   |  359 +++++++++++
 src/hex/shader_256k.hex  |  861 ++++++++++++++++++++++++++
 src/hex/shader_2k.hex    |  765 +++++++++++++++++++++++
 src/hex/shader_32k.hex   |  697 +++++++++++++++++++++
 src/hex/shader_4096k.hex | 1523 ++++++++++++++++++++++++++++++++++++++++++++++
 src/hex/shader_4k.hex    |  514 ++++++++++++++++
 src/hex/shader_512.hex   |  494 +++++++++++++++
 src/hex/shader_512k.hex  |  983 ++++++++++++++++++++++++++++++
 src/hex/shader_64k.hex   |  940 ++++++++++++++++++++++++++++
 src/hex/shader_8k.hex    |  603 ++++++++++++++++++
 src/hex/shader_trans.hex |  126 ++++
 src/image.h              |  268 ++++++++
 src/jpeg.h               |  128 ++++
 src/mailbox.c            |  258 ++++++++
 src/mailbox.h            |   47 ++
 src/ogn-rf.cc            | 1068 ++++++++++++++++++++++++++++++++
 src/pulsefilter.h        |   69 +++
 src/r2fft.h              |  191 ++++++
 src/r2fft_test.cc        |   52 ++
 src/rtlsdr.h             |  294 +++++++++
 src/serialize.h          |   25 +
 src/socket.h             |  601 ++++++++++++++++++
 src/sysmon.h             |  142 +++++
 src/thread.h             |  263 ++++++++
 src/tonefilter.h         |   91 +++
 sysmon.h                 |  142 -----
 thread.h                 |  263 --------
 tonefilter.h             |   91 ---
 84 files changed, 18021 insertions(+), 18021 deletions(-)
 delete mode 100644 alloc.h
 delete mode 100644 asciitime.h
 delete mode 100644 boxfilter.h
 delete mode 100644 buffer.h
 delete mode 100644 fft.h
 delete mode 100644 gpu_fft.c
 delete mode 100644 gpu_fft.h
 delete mode 100644 gpu_fft_shaders.c
 delete mode 100644 gpu_fft_twiddles.c
 delete mode 100644 gsm_scan.cc
 delete mode 100644 hex/shader_1024k.hex
 delete mode 100644 hex/shader_128k.hex
 delete mode 100644 hex/shader_16k.hex
 delete mode 100644 hex/shader_1k.hex
 delete mode 100644 hex/shader_2048k.hex
 delete mode 100644 hex/shader_256.hex
 delete mode 100644 hex/shader_256k.hex
 delete mode 100644 hex/shader_2k.hex
 delete mode 100644 hex/shader_32k.hex
 delete mode 100644 hex/shader_4096k.hex
 delete mode 100644 hex/shader_4k.hex
 delete mode 100644 hex/shader_512.hex
 delete mode 100644 hex/shader_512k.hex
 delete mode 100644 hex/shader_64k.hex
 delete mode 100644 hex/shader_8k.hex
 delete mode 100644 hex/shader_trans.hex
 delete mode 100644 image.h
 delete mode 100644 jpeg.h
 delete mode 100644 mailbox.c
 delete mode 100644 mailbox.h
 delete mode 100644 ogn-rf.cc
 delete mode 100644 pulsefilter.h
 delete mode 100644 r2fft.h
 delete mode 100644 r2fft_test.cc
 delete mode 100755 rtlsdr-ogn
 delete mode 100644 rtlsdr-ogn.conf
 delete mode 100644 rtlsdr.h
 create mode 100755 scripts/rtlsdr-ogn
 create mode 100644 scripts/rtlsdr-ogn.conf
 delete mode 100644 serialize.h
 delete mode 100644 socket.h
 create mode 100644 src/alloc.h
 create mode 100644 src/asciitime.h
 create mode 100644 src/boxfilter.h
 create mode 100644 src/buffer.h
 create mode 100644 src/fft.h
 create mode 100644 src/gpu_fft.c
 create mode 100644 src/gpu_fft.h
 create mode 100644 src/gpu_fft_shaders.c
 create mode 100644 src/gpu_fft_twiddles.c
 create mode 100644 src/gsm_scan.cc
 create mode 100644 src/hex/shader_1024k.hex
 create mode 100644 src/hex/shader_128k.hex
 create mode 100644 src/hex/shader_16k.hex
 create mode 100644 src/hex/shader_1k.hex
 create mode 100644 src/hex/shader_2048k.hex
 create mode 100644 src/hex/shader_256.hex
 create mode 100644 src/hex/shader_256k.hex
 create mode 100644 src/hex/shader_2k.hex
 create mode 100644 src/hex/shader_32k.hex
 create mode 100644 src/hex/shader_4096k.hex
 create mode 100644 src/hex/shader_4k.hex
 create mode 100644 src/hex/shader_512.hex
 create mode 100644 src/hex/shader_512k.hex
 create mode 100644 src/hex/shader_64k.hex
 create mode 100644 src/hex/shader_8k.hex
 create mode 100644 src/hex/shader_trans.hex
 create mode 100644 src/image.h
 create mode 100644 src/jpeg.h
 create mode 100644 src/mailbox.c
 create mode 100644 src/mailbox.h
 create mode 100644 src/ogn-rf.cc
 create mode 100644 src/pulsefilter.h
 create mode 100644 src/r2fft.h
 create mode 100644 src/r2fft_test.cc
 create mode 100644 src/rtlsdr.h
 create mode 100644 src/serialize.h
 create mode 100644 src/socket.h
 create mode 100644 src/sysmon.h
 create mode 100644 src/thread.h
 create mode 100644 src/tonefilter.h
 delete mode 100644 sysmon.h
 delete mode 100644 thread.h
 delete mode 100644 tonefilter.h

diff --git a/alloc.h b/alloc.h
deleted file mode 100644
index 9d2ebe1..0000000
--- a/alloc.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-#ifndef __ALLOC_H__
-#define __ALLOC_H__
-#include <stdlib.h>
-
-template<class Type>
- int Malloc(Type *&Data, size_t Size)
-{ Data = (Type *)malloc(Size*sizeof(Type)); return Data ? Size:0; }
-
-#endif
diff --git a/asciitime.h b/asciitime.h
deleted file mode 100644
index c3284e1..0000000
--- a/asciitime.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-#ifndef __ASCIITIME_H__
-#define __ASCIITIME_H__
-/*
-int SplitTime(int &Hour, int &Min, int &Sec, double &Frac, double Time)
-{ int UnixTime = (int)floor(Time); Frac=Time-UnixTime;
-  const int SecondsPerDay = 24*60*60;
-  int Day = UnixTime/SecondsPerDay;
-  UnixTime -= Day*SecondsPerDay;
-  Hour = UnixTime/3600; UnixTime-=Hour*3600;
-  Min  = UnixTime/60;   UnixTime-=Min*60;
-  Sec  = UnixTime;
-  return Day; }
-
-void AsciiTime_HHMMSSFFF(char *String, double Time)
-{ int Hour, Min, Sec; double Frac;
-  SplitTime(Hour, Min, Sec, Frac, Time);
-  sprintf(String, "%02d:%02d:%02d.%03d", Hour, Min, Sec, (int)floor(Frac*1000)); }
-
-void AsciiTime_DDDDDHHMMSSFFF(char *String, double Time)
-{ int Hour, Min, Sec; double Frac;
-  int Day=SplitTime(Hour, Min, Sec, Frac, Time);
-  sprintf(String, "%05d:%02d:%02d:%02d.%03d", Day, Hour, Min, Sec, (int)floor(Frac*1000)); }
-
-int Time_HHMMSS(time_t Time)
-{ uint32_t DayTime=Time%86400;
-  uint32_t Hour=DayTime/3600; DayTime-=Hour*3600;
-  uint32_t Min=DayTime/60; DayTime-=Min*60;
-  uint32_t Sec=DayTime;
-  return 10000*Hour + 100*Min + Sec; }
-
-int Format_HHMMSS(char *Str, time_t Time)
-{ uint32_t DayTime=Time%86400;
-  uint32_t Hour=DayTime/3600; DayTime-=Hour*3600;
-  uint32_t Min=DayTime/60; DayTime-=Min*60;
-  uint32_t Sec=DayTime;
-  uint32_t HourH=Hour/10; Str[0]='0'+HourH; Str[1]='0'+(Hour-10*HourH);
-  uint32_t  MinH=Min /10; Str[2]='0'+MinH;  Str[3]='0'+(Min -10*MinH);
-  uint32_t  SecH=Sec /10; Str[4]='0'+SecH;  Str[5]='0'+(Sec -10*SecH);
-  return 6; }
-*/
-#endif
diff --git a/boxfilter.h b/boxfilter.h
deleted file mode 100644
index 53c62c5..0000000
--- a/boxfilter.h
+++ /dev/null
@@ -1,161 +0,0 @@
-#ifndef __BOXFILTER_H__
-#define __BOXFILTER_H__
-
-#include <stdlib.h>
-#include <math.h>
-
-#include "alloc.h"
-
-// ===========================================================================================
-
-template <class Type>
- class BoxPeakSum
-{ public:
-   int   Size;       // How many samples to remember
-   Type *Pipe;       // storage for Size most recent signals
-   int   Ptr;        // most recent signal position
-   Type  Peak;       // max. signal value
-   int   PeakPtr;    // position of max. signal
-   Type  Sum;        // sum of all signals in the Pipe
-
-  public:
-   BoxPeakSum()  { Size=0; Pipe=0; Clear(); }
-  ~BoxPeakSum()  { Free(); }
-   void Free(void) { free(Pipe); Size=0; Pipe=0; Clear(); }
-
-   void Print(void)
-   { printf("BoxPeakSum[%d]", Size);
-     for(int Idx=0; Idx<Size; Idx++)
-     { printf(" %3.1f", Pipe[Idx]); }
-     printf(" %3.1f/%3.1f %d/%d\n", Peak, Sum, PeakPtr, Ptr); }
-
-   int Preset(int Size)
-   { Free();
-     this->Size=Size;
-     if(Malloc(Pipe, Size)<=0) return -1;
-     Clear(); return Size; }
-
-   void Clear(void)
-   { Ptr=0; Peak=0; PeakPtr=0; Sum=0; for(int Idx=0; Idx<Size; Idx++) Pipe[Idx]=0; }
-
-   void ReCalc(void)
-   { Sum=0; Peak=Pipe[0]; PeakPtr=0;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Type Sig=Pipe[Idx]; Sum+=Sig;
-       if(Sig>Peak) { Peak=Sig; PeakPtr=Idx; }
-     }
-   }
-
-   // Type operator[](int Idx)
-   // { Idx+=PeakPtr; if(Idx>=Size) Idx-=Size; return Pipe[Idx]; }
-
-   Type GetPipe(int Delay=0)
-   { int Idx = Ptr-Delay; if(Idx<0) Idx+=Size; return Pipe[Idx]; }
-
-   void Process(Type Input)
-   { Ptr+=1; if(Ptr>=Size) Ptr=0;
-     Sum -=  Pipe[Ptr];
-     Sum += (Pipe[Ptr]=Input);
-     if(Input>Peak) { Peak=Input; PeakPtr=Ptr; }
-     if((Ptr==0) || (Ptr==PeakPtr) ) ReCalc(); }
-
-   int isAtPeak(void)
-   { int AntiPtr=Ptr-Size/2; if(AntiPtr<0) AntiPtr+=Size;
-     return AntiPtr==PeakPtr; } // return 1 when peak is in the center of the pipeline
-
-   Type AtPeak(int Ofs=0)
-   { int Idx=PeakPtr+Ofs;
-     if(Idx>=Size) Idx-=Size;
-     else if(Idx<0) Idx+=Size;
-     return Pipe[Idx]; }
-
-   Type PeakSum(int Radius=0)
-   { Type Sum=0; if(Radius>(Size/2)) Radius=Size/2;
-     int Count=2*Radius+1;
-     int Idx=PeakPtr-Radius; if(Idx<0) Idx+=Size;
-     for( ; Count>0; Count--)
-     { Sum+=Pipe[Idx++]; if(Idx>=Size) Idx-=Size; }
-     return Sum; }
-
-   template <class FitType>
-     int FitGauss(FitType &Peak, FitType &Pos, FitType &Sigma, Type Bias=0, int LogFit=0)
-   { int Idx = Ptr-PeakPtr; if(Idx<0) Idx+=Size; // Idx = distance from the current sample to the peak
-     Peak=this->Peak; Pos=(-Idx); Sigma=0; if( (Idx==0) || (Idx==(Size-1)) ) return -1;
-     Idx=PeakPtr;                              Type C=Pipe[Idx]-Bias; if(C<=0) return -2; // center
-     Idx=(PeakPtr-1); if(Idx<0) Idx+=Size;     Type L=Pipe[Idx]-Bias; if(L<=0) return -2; // left (before center)
-     Idx=(PeakPtr+1); if(Idx>=Size) Idx-=Size; Type R=Pipe[Idx]-Bias; if(R<=0) return -2; // right (after center)
-     if(LogFit) { C=log(C); R=log(R); L=log(L); }
-     FitType A = (R+L)/2-C; if(A>=0) return -3;     // parabole coeff: A, B, C
-     FitType B = (R-L)/2;
-     FitType D = B*B-4*A*C;                         // Delta
-     Peak = (-D/(4*A)); if(LogFit) Peak=exp(Peak); // interpolated maximum value
-     Pos += -B/(2*A);                              // interpolated position
-     if(LogFit) Sigma = sqrt(-0.5/A);              // interpolated width
-           else Sigma = sqrt(-0.5*Peak/A);
-     return 3; }
-
-   int FitTriangle(double &Peak, double &Pos)
-   { int Idx = Ptr-PeakPtr; if(Idx<0) Idx+=Size; // Idx = distance from the current sample to the peak
-     Peak=this->Peak; Pos=(-Idx); if( (Idx<2) || (Idx>=(Size-2)) ) return -1;
-     Idx=PeakPtr;                              Type C=Pipe[Idx]; // center
-     Idx=(PeakPtr-1); if(Idx<0) Idx+=Size;     Type L=Pipe[Idx]; // left (before center)
-     Idx=(PeakPtr+1); if(Idx>=Size) Idx-=Size; Type R=Pipe[Idx]; // right (after center)
-     if(R==L) return 2;
-     if(R>L)
-     { Idx=(PeakPtr+2); if(Idx>=Size) Idx-=Size; Type RR=Pipe[Idx]; // next right
-       double X = (-C+2*R-RR)/(-L+C+R-RR); Peak=C+X*(C-L); Pos+=X; }
-     else
-     { Idx=(PeakPtr-2); if(Idx<0) Idx+=Size;     Type LL=Pipe[Idx]; // next left
-       double X = (-LL+2*L-C)/(LL-L-C+R); Peak=C+X*(R-C); Pos+=X; }
-     return 2; }
-
-} ;
-
-// ===========================================================================================
-
-template <class Type, class SumType=Type>
- class BoxSumFilter
-{ public:
-   int   Size;            // box size
-   Type *Pipe;            // box storage
-   int   Ptr;             // pipe pointer
-   SumType Output;        // filter output = sum of all elements in the box
-   int   RoundsPerRecalc; // how often to recalculate
-   int   RoundsToRecalc;  // recalc. counter
-
-  public:
-   BoxSumFilter() { Size=0; Pipe=0; Clear(); }
-  ~BoxSumFilter() { Free(); }
-   void Free(void) { free(Pipe); Size=0; Pipe=0; }
-
-   int Preset(int Size, int RoundsPerRecalc=4)
-   { Free();
-     this->Size=Size; this->RoundsPerRecalc=RoundsPerRecalc;
-     if(Malloc(Pipe, Size)<=0) return -1;
-     Clear(); return Size; }
-
-   void Clear(Type Zero=0)
-   { Ptr=0; Output=Size*(SumType)Zero; for(int Idx=0; Idx<Size; Idx++) Pipe[Idx]=Zero; RoundsToRecalc=RoundsPerRecalc; }
-
-   void ReCalc(void)
-   { Output=0; for(int Idx=0; Idx<Size; Idx++) Output+=Pipe[Idx]; }
-
-   Type Process(Type Input)
-   { Ptr+=1; if(Ptr>=Size) Ptr=0;
-     Output-=Pipe[Ptr];
-     Output+=(Pipe[Ptr]=Input);
-     if( (Ptr==0) && RoundsPerRecalc )
-     { RoundsToRecalc--;
-       if(RoundsToRecalc==0)
-       { ReCalc(); RoundsToRecalc=RoundsPerRecalc; }
-     }
-     return Output; }
-
-   SumType Average(void) { return Output/Size; }
-   Type operator[](int Delay) { int Idx=Ptr-Delay; if(Idx<0) Idx+=Size; return Pipe[Idx]; }
-} ;
-
-
-// ===========================================================================================
-
-#endif // __BOXFILTER_H__
diff --git a/buffer.h b/buffer.h
deleted file mode 100644
index e7908dc..0000000
--- a/buffer.h
+++ /dev/null
@@ -1,593 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __BUFFER_H_
-#define __BUFFER_H_
-
-#include <unistd.h>
-
-#include <string.h>
-
-#include "fft.h"
-#include "r2fft.h"
-
-#include "serialize.h"
-
-// ==================================================================================================
-
-template <class Type>
- class SampleBuffer  // a buffer to hold a batch of samples
-{ public:
-   int32_t Size;  // allocated size ot data
-   int32_t Full;  // number of values in the buffer
-   int32_t Len;   // number of values per sample
-
-   double Rate;   // [Hz]  sampling rate
-   double Time;   // [sec] time when samples were acquired
-   double Freq;   // [Hz]  RF frequency where samples were acquired
-
-   Type  *Data;  // (allocated) storage
-
-  public:
-   SampleBuffer() { Size=0; Data=0; Full=0; Len=1; }
-  ~SampleBuffer() { Free(); }
-
-   void Free(void) { if(Data) delete [] Data; Data=0; Size=0; Full=0; }
-
-   int Allocate(int NewSize)
-   { if(NewSize<=Size) { Full=0; return Size; } // for timing eficiency: do not reallocate if same or bigger size already allocated
-     Free();
-     Data = new (std::nothrow) Type [NewSize]; if(Data==0) { Size=0; Full=0; return Size; }
-     Size=NewSize; return Size; }
-
-   int Allocate(int NewLen, int Samples)
-   { Allocate(NewLen*Samples); Len=NewLen; return Size; }
-
-   int Samples(void) const { return Full/Len; }                // number of samples
-   Type *SamplePtr(int Idx) const { return Data+Idx*Len; }     // pointer to an indexed sample
-   Type &operator [](int Idx) { return Data[Idx]; }            // reference to an indexed value
-
-   Type *Sample(int Idx) { return Data + Idx*Len; }
-
-   template <class OtherType>                                  // allocate after another SampleBuffer
-    int Allocate(SampleBuffer<OtherType> &Buffer)
-   { Allocate(Buffer.Size);
-     Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time; Freq=Buffer.Freq; return Size; }
-
-   void Set(Type Value=0)
-   { Type *DataPtr=Data; for(int Idx=0; Idx<Size; Idx++) (*DataPtr++)=Value; }
-
-   double Average(void) const
-   { double Sum=0;
-     for(int Idx=0; Idx<Full; Idx++) Sum+=Data[Idx];
-     return Sum/Full; }
-
-   void Crop(int Head, int Tail)
-   { int NewFull=Full-(Head+Tail)*Len;
-     if(Head)
-     { memmove(Data, Data+Head*Len, NewFull*sizeof(Type));
-       Time+=Head/Rate; }
-     Full=NewFull; }
-
-   int Copy(SampleBuffer<Type> &Buffer)                        // allocate and copy from another SampleBuffer
-   { Allocate(Buffer.Size); memcpy(Data, Buffer.Data, Size*sizeof(Type));
-     Full=Buffer.Full; Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time; Freq=Buffer.Freq; return Size; }
-
-   int CopySample(SampleBuffer<Type> &Buffer, int Idx)         // copy just one sample (but can be more than one value)
-   { Allocate(Buffer->Len);
-     Full=Buffer.Len; Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time+Idx/Rate; Freq=Buffer.Freq;
-     memcpy(Data, Buffer.Data + Idx*Len, Len*sizeof(Type));
-     return Size; }
-
-   template <class OtherType>
-    int CopySampleSum(SampleBuffer<OtherType> &Buffer)                     // copy the sum of all samples
-   { return CopySampleSum(Buffer, 0, Buffer.Samples()-1); }
-
-   template <class OtherType>
-    int CopySampleSum(SampleBuffer<OtherType> &Buffer, int Idx1, int Idx2) // copy the sum of several samples
-   { Allocate(Buffer.Len);
-     Full=Buffer.Len; Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time+0.5*(Idx1+Idx2)/Rate; Freq=Buffer.Freq;
-     for(int Idx=0; Idx<Len; Idx++) { Data[Idx]=0; }
-     for(int sIdx=Idx1; sIdx<=Idx2; sIdx++)
-     { Type *sPtr = Buffer.Data + sIdx*Len;
-       for(int Idx=0; Idx<Len; Idx++) { Data[Idx]+=sPtr[Idx]; }
-     }
-     return Size; }
-
-   template <class ScaleType>
-    void operator *= (ScaleType Scale)
-   { for(int Idx=0; Idx<Full; Idx++) Data[Idx]*=Scale; }
-
-   int WritePlotFile(const char *FileName, int StartIdx=0, int Values=0) const
-   { if(Values==0) Values=Size-StartIdx;
-     FILE *File=fopen(FileName, "wt"); if(File==0) return 0;
-     fprintf(File, "# %d x %d, Time=%17.6fsec, Freq=%10.6fMHz, Rate=%8.6fMHz\n", Samples(), Len, Time, 1e-6*Freq, 1e-6*Rate);
-     for(int Idx=StartIdx; Idx<Size; Idx++)
-     { if((Idx-StartIdx)>=Values) break;
-       fprintf(File, "%4d: %+12.6f\n", Idx, Data[Idx] ); }
-     fclose(File); return Size; }
-
-   int WriteComplexPlotFile(const char *FileName, int StartIdx=0, int Values=0) const
-   { if(Values==0) Values=Size-StartIdx;
-     FILE *File=fopen(FileName, "wt"); if(File==0) return 0;
-     fprintf(File, "# %d x %d, Time=%17.6fsec, Freq=%10.6fMHz, Rate=%8.6fMHz\n", Samples(), Len, Time, 1e-6*Freq, 1e-6*Rate);
-     fprintf(File, "# Index      Real         Imag         Magn  Phase[deg]\n");
-     for(int Idx=StartIdx; Idx<Size; Idx++)
-     { if((Idx-StartIdx)>=Values) break;
-       fprintf(File, "%4d: %+12.6f %+12.6f %12.6f %+9.3f\n", Idx, real(Data[Idx]), imag(Data[Idx]), sqrt(norm(Data[Idx])), (180/M_PI)*arg(Data[Idx]) ); }
-     fclose(File); return Size; }
-
-  template <class StreamType>
-   int Serialize(StreamType File) // write SampleBuffer to a file/socket
-   { int Total=0, Bytes;
-     Bytes=SerializeWriteData(File, &Size, sizeof(int32_t)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeWriteData(File, &Full, sizeof(int32_t)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeWriteData(File, &Len , sizeof(int32_t)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeWriteData(File, &Rate, sizeof(double)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeWriteData(File, &Time, sizeof(double)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeWriteData(File, &Freq, sizeof(double)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeWriteData(File,  Data, Full*sizeof(Type)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     return Total; }
-
-  template <class StreamType>
-   int Deserialize(StreamType File)  // read SampleBuffer from a file/socket
-   { int Total=0, Bytes;
-     int32_t NewSize=0;
-     Bytes=SerializeReadData(File, &NewSize, sizeof(int32_t)); if(Bytes<0) return -1;
-     if(NewSize<0) return -1;
-     Total+=Bytes;
-     if(Allocate(NewSize)==0) return -2;
-     Bytes=SerializeReadData(File, &Full, sizeof(int32_t)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeReadData(File, &Len , sizeof(int32_t)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeReadData(File, &Rate, sizeof(double)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeReadData(File, &Time, sizeof(double)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeReadData(File, &Freq, sizeof(double)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     Bytes=SerializeReadData(File,  Data, Full*sizeof(Type)); if(Bytes<0) return -1;
-     Total+=Bytes;
-     return Total; }
-
-   int Write(FILE *File) // write all samples onto a binary file (with header)
-   { if(fwrite(&Size, sizeof(Size), 1, File)!=1) return -1;
-     if(fwrite(&Full, sizeof(Full), 1, File)!=1) return -1;
-     if(fwrite(&Len,  sizeof(Len),  1, File)!=1) return -1;
-     if(fwrite(&Rate, sizeof(Rate), 1, File)!=1) return -1;
-     if(fwrite(&Time, sizeof(Time), 1, File)!=1) return -1;
-     if(fwrite(&Freq, sizeof(Freq), 1, File)!=1) return -1;
-     if(fwrite(Data,  sizeof(Type), Size, File)!=(size_t)Size) return -1;
-     return 1; }
-
-   int Read(FILE *File) // read samples from a binary file (with header)
-   { if(fread(&Size, sizeof(Size), 1, File)!=1) return -1;
-     if(fread(&Full, sizeof(Full), 1, File)!=1) return -1;
-     if(fread(&Len,  sizeof(Len),  1, File)!=1) return -1;
-     if(fread(&Rate, sizeof(Rate), 1, File)!=1) return -1;
-     if(fread(&Time, sizeof(Time), 1, File)!=1) return -1;
-     if(fread(&Freq, sizeof(Freq), 1, File)!=1) return -1;
-     Allocate(Size);
-     if(fread(Data,  sizeof(Type), Size, File)!=(size_t)Size) return -1;
-     return 1; }
-
-   int ReadRaw(FILE *File, int Len, int MaxSamples, double Rate=1) // read samples from a raw binary file
-   { Allocate(Len, MaxSamples); this->Rate=Rate;
-     int Read=fread(Data,  Len*sizeof(Type), MaxSamples, File);
-     Full=Len*Read; return Full; }
-
-   int ReadRaw(const char *FileName, int Len, int MaxSamples, double Rate=1)
-   { FILE *File=fopen(FileName, "rb"); if(!File) return -1;
-     int Ret=ReadRaw(File, Len, MaxSamples, Rate);
-     fclose(File); return Ret; }
-} ;
-
-// ==================================================================================================
-
-// Note 1: the sliding FFT routines below take sliding step = half the FFT window size (thus SineWindow should be used)
-// Note 2: the FFT output spectra have the two halfs swapped around thus the FFT amplitude corresponding to the center frequency is in the middle
-
-template <class Float>
- int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer<uint8_t> &Input,
-                InpSlideFFT<Float> &FFT, Float InpBias=127.38)
-{ return SlidingFFT(Output, Input, FFT.FwdFFT, FFT.Window, InpBias); }
-
-template <class Float> // do sliding FFT over a buffer of (complex 8-bit) samples, produce (float/double complex) spectra
- int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer<uint8_t> &Input,
-                DFT1d<Float> &FwdFFT, Float *Window, Float InpBias=127.38)
-{ int WindowSize = FwdFFT.Size;                                                        // FFT object and Window shape are prepared already
-  int WindowSize2=WindowSize/2;                                                        // Slide step
-  int InpSamples=Input.Full/2;                                                         // number of complex,8-bit input samples
-  // printf("SlidingFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSamples);
-  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
-  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
-  uint8_t *InpData = Input.Data;
-  std::complex<Float> *OutData = Output.Data;
-  int Slides=0;
-  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // first slide is special
-    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
-    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
-      InpData+=2; }
-    FwdFFT.Execute();                                             // execute FFT
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // copy spectra into the output buffer
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // swap around the two halfs
-    InpData-=2*WindowSize2; Slides++; }
-  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
-  { std::complex<Float> *Buffer = FwdFFT.Buffer;
-    for( int Bin=0; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
-      InpData+=2; }
-    FwdFFT.Execute();
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    InpData-=2*WindowSize2; Slides++; }
-  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // and the last slide: special
-    for( int Bin=0; Bin<WindowSize2; Bin++)
-    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
-      InpData+=2; }
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = 0; }
-    FwdFFT.Execute();
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    InpData-=2*WindowSize2; Slides++; }
-
-  Output.Full=Slides*WindowSize;
-  return Slides; }
-
-// --------------------------------------------------------------------------------------------------
-
-template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
- int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
-                DFT1d<Float> &FwdFFT, Float *Window)
-{ int WindowSize = FwdFFT.Size;                                                        // FFT object and Window shape are prepared already
-  int WindowSize2=WindowSize/2;                                                        // Slide step
-  int InpSamples=Input.Full;                                                           // number of complex float/double samples
-  // printf("SlidingFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSamples);
-  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
-  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
-  std::complex<Float> *InpData = Input.Data;
-  std::complex<Float> *OutData = Output.Data;
-  int Slides=0;
-  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // first slide is special
-    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
-    { Buffer[Bin] = Window[Bin]*InpData[Bin-WindowSize2]; }
-    FwdFFT.Execute();                                             // execute FFT
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // copy spectra into the output buffer
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // swap around the two halfs
-    Slides++; }
-  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
-  { std::complex<Float> *Buffer = FwdFFT.Buffer;
-    for( int Bin=0; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
-    FwdFFT.Execute();
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    InpData+=WindowSize2; Slides++; }
-  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // and the last slide: special
-    for( int Bin=0; Bin<WindowSize2; Bin++)
-    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = 0; }
-    FwdFFT.Execute();
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    InpData+=WindowSize2; Slides++; }
-
-  Output.Full=Slides*WindowSize;
-  return Slides; }
-
-template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
- int ReconstrFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
-                 DFT1d<Float> &InvFFT, Float *Window)
-{ int WindowSize = InvFFT.Size;                                                        // FFT object and Window shape are prepared already
-  int WindowSize2=WindowSize/2;                                                        // Slide step
-  int InpSlides=Input.Samples();                                                       //
-  // printf("ReconstrFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSlides);
-  Output.Allocate(1, (InpSlides+1)*WindowSize2);                                     // output is complex time-linear samples
-  Output.Rate=Input.Rate*WindowSize2; Output.Time=Input.Time-1.0/Input.Rate; Output.Freq=Input.Freq;
-  std::complex<Float> *InpData = Input.Data;
-  std::complex<Float> *OutData = Output.Data;
-  int Slides=0;
-  { std::complex<Float> *Buffer = InvFFT.Buffer;
-    memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
-    memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
-    InvFFT.Execute();
-    for(int Idx=0; Idx<WindowSize; Idx++)
-    { OutData[Idx]=Window[Idx]*Buffer[Idx]; }
-    OutData+=WindowSize2; Slides++; InpSlides--; }
-  for( ; InpSlides; )
-  { std::complex<Float> *Buffer = InvFFT.Buffer;
-    memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
-    memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
-    InvFFT.Execute();
-    for(int Idx=0; Idx<WindowSize2; Idx++)
-    { OutData[Idx]+=Window[Idx]*Buffer[Idx]; }
-    for(int Idx=WindowSize2; Idx<WindowSize; Idx++)
-    { OutData[Idx]=Window[Idx]*Buffer[Idx]; }
-    OutData+=WindowSize2; Slides++; InpSlides--; }
-
-  Output.Full=(Slides+1)*WindowSize2;
-  return Slides; }
-
-// ==================================================================================================
-// Sliding FFT with r2FFT (no open-source restrictions)
-
-template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
- int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
-                r2FFT<Float> &FFT, Float *Window, std::complex<Float> *Buffer)
-{ int WindowSize = FFT.Size;                                                        // FFT object and Window shape are prepared already
-  int WindowSize2=WindowSize/2;                                                        // Slide step
-  int InpSamples=Input.Full;                                                           // number of complex float/double samples
-  // printf("SlidingFFT() %d point FFT, %d input samples\n", FFT.Size, InpSamples);
-  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
-  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
-  std::complex<Float> *InpData = Input.Data;
-  std::complex<Float> *OutData = Output.Data;
-  int Slides=0;
-  {                                                                 // first slide is special
-    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
-    { Buffer[Bin] = Window[Bin]*InpData[Bin-WindowSize2]; }
-    FFT.Process(Buffer);                                            // execute FFT
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // copy spectra into the output buffer
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // swap around the two halfs
-    Slides++; }
-  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
-  {
-    for( int Bin=0; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
-    FFT.Process(Buffer);
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    InpData+=WindowSize2; Slides++; }
-  {                                                                // and the last slide: special
-    for( int Bin=0; Bin<WindowSize2; Bin++)
-    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = 0; }
-    FFT.Process(Buffer);
-    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
-    InpData+=WindowSize2; Slides++; }
-
-  Output.Full=Slides*WindowSize;
-  return Slides; }
-
-template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
- int ReconstrFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
-                 r2FFT<Float> &FFT, Float *Window, std::complex<Float> *Buffer)
-{ int WindowSize = FFT.Size;                                                           // FFT object and Window shape are prepared already
-  int WindowSize2=WindowSize/2;                                                        // Slide step
-  int InpSlides=Input.Samples();                                                       //
-  // printf("ReconstrFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSlides);
-  Output.Allocate(1, (InpSlides+1)*WindowSize2);                                     // output is complex time-linear samples
-  Output.Rate=Input.Rate*WindowSize2; Output.Time=Input.Time-1.0/Input.Rate; Output.Freq=Input.Freq;
-  std::complex<Float> *InpData = Input.Data;
-  std::complex<Float> *OutData = Output.Data;
-  int Slides=0;
-  {
-    // memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
-    // memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
-    for(int Idx=0; Idx<WindowSize2; Idx++)
-    { Buffer[WindowSize2+Idx] = conj(InpData[Idx]); }
-    InpData+=WindowSize2;
-    for(int Idx=0; Idx<WindowSize2; Idx++)
-    { Buffer[            Idx] = conj(InpData[Idx]); }
-    InpData+=WindowSize2;
-    FFT.Process(Buffer);
-    for(int Idx=0; Idx<WindowSize; Idx++)
-    { OutData[Idx]=Window[Idx]*conj(Buffer[Idx]); }
-    OutData+=WindowSize2; Slides++; InpSlides--; }
-  for( ; InpSlides; )
-  {
-    // memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
-    // memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
-    for(int Idx=0; Idx<WindowSize2; Idx++)
-    { Buffer[WindowSize2+Idx] = conj(InpData[Idx]); }
-    InpData+=WindowSize2;
-    for(int Idx=0; Idx<WindowSize2; Idx++)
-    { Buffer[            Idx] = conj(InpData[Idx]); }
-    InpData+=WindowSize2;
-    FFT.Process(Buffer);
-    for(int Idx=0; Idx<WindowSize2; Idx++)
-    { OutData[Idx]+=Window[Idx]*conj(Buffer[Idx]); }
-    for(int Idx=WindowSize2; Idx<WindowSize; Idx++)
-    { OutData[Idx]=Window[Idx]*conj(Buffer[Idx]); }
-    OutData+=WindowSize2; Slides++; InpSlides--; }
-
-  Output.Full=(Slides+1)*WindowSize2;
-  return Slides; }
-
-// ==================================================================================================
-
-#ifdef USE_RPI_GPU_FFT
-
-// template <class Float> // do sliding FFT over a buffer of (complex 8-bit) samples, produce (float/double complex) spectra
- int SlidingFFT(SampleBuffer< std::complex<float> > &Output, SampleBuffer<uint8_t> &Input,
-                RPI_GPU_FFT &FwdFFT, float *Window, float InpBias=127.38)
-{ int Jobs = FwdFFT.Jobs;
-  int WindowSize = FwdFFT.Size;                                                        // FFT object and Window shape are prepared already
-  int WindowSize2=WindowSize/2;                                                          // Slide step
-  int InpSamples=Input.Full/2;                                                         // number of complex,8-bit input samples
-  // printf("SlidingFFT(RPI_GPU_FFT) %d point FFT, %d jobs/GPU, %d input samples\n", FwdFFT.Size, Jobs, InpSamples);
-  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
-  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
-
-  uint8_t *InpData = Input.Data;
-  std::complex<float> *OutData = Output.Data;
-  int Slides=0; int Job=0;
-  { std::complex<float> *Buffer = FwdFFT.Input(Job);                // first slide is special
-    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
-    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
-      InpData+=2; }
-    Job++; InpData-=2*WindowSize2; }
-  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
-  { std::complex<float> *Buffer = FwdFFT.Input(Job);
-    for( int Bin=0; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
-      InpData+=2; }
-    Job++; InpData-=2*WindowSize2;
-    if(Job>=Jobs)
-    { FwdFFT.Execute();
-      for(int J=0; J<Jobs; J++)
-      { memcpy(OutData, FwdFFT.Output(J)+WindowSize2, WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2;
-        memcpy(OutData, FwdFFT.Output(J),             WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2; }
-      Slides+=Jobs; Job=0;
-    }
-  }
-  { std::complex<float> *Buffer = FwdFFT.Input(Job);                  // and the last slide: special
-    for( int Bin=0; Bin<WindowSize2; Bin++)
-    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias));
-      InpData+=2; }
-    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
-    { Buffer[Bin] = 0; }
-    Job++; InpData-=2*WindowSize2;
-    { FwdFFT.Execute();
-      for(int J=0; J<Job; J++)
-      { memcpy(OutData, FwdFFT.Output(J)+WindowSize2, WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2;
-        memcpy(OutData, FwdFFT.Output(J),             WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2; }
-      Slides+=Job; Job=0;
-    }
-  }
-
-  // printf("SlidingFFT(RPI_GPU_FFT) %d slides\n", Slides);
-  Output.Full=Slides*WindowSize;
-  return Slides; }
-
-#endif
-
-// ==================================================================================================
-
-template <class Float>
- inline Float Power(Float *X)
-{ Float Re=X[0]; Float Im=X[1]; return Re*Re+Im*Im; }
-
-template <class Float>
- inline Float Power(std::complex<Float> &X)
-{ Float Re=real(X); Float Im=imag(X); return Re*Re+Im*Im; }
-
-template <class Float>  // convert (complex) spectra to power (energy)
- void SpectraPower(SampleBuffer<Float> &Output, SampleBuffer< std::complex<Float> > &Input)
-{ Output.Allocate(Input); int WindowSize=Input.Len;
-  std::complex<Float> *InpData=Input.Data;
-  Float *OutData=Output.Data;
-  int Slides=Input.Full/Input.Len;
-  for( int Slide=0; Slide<Slides; Slide++)
-  { for( int Bin=0; Bin<WindowSize; Bin++)
-    { OutData[Bin] = Power(InpData[Bin]); }
-    InpData+=WindowSize; OutData+=WindowSize; }
-  Output.Time=Input.Time; Output.Rate=Input.Rate; Output.Freq=Input.Freq;
-  Output.Full=Input.Full; }
-
-template <class Float>  // convert (complex) spectra to power (energy) - at same time calc. the average spectra power
- Float SpectraPower(SampleBuffer<Float> &Output, SampleBuffer< std::complex<Float> > &Input, int LowBin, int Bins)
-{ int WindowSize=Input.Len;
-  int Slides=Input.Full/WindowSize;
-  Output.Allocate(Bins,Slides);
-  Float *OutData=Output.Data;
-  double Sum=0;
-  for( int Slide=0; Slide<Slides; Slide++)
-  { std::complex<Float> *InpData=Input.Data+(Slide*WindowSize+LowBin);
-    for( int Bin=0; Bin<Bins; Bin++)
-    { Sum += OutData[Bin] = Power(InpData[Bin]); }
-    OutData+=Bins; }
-  Output.Full=Bins*Slides;
-  Output.Time=Input.Time; Output.Rate=Input.Rate; // Output.Freq=Input.Freq;
-  return Sum/Output.Full; }
-
-template <class Float>
- Float SpectraPowerLogHist(int *LogHist, SampleBuffer<Float> &Power, Float Median)
-{ Float Thres[3];
-  Thres[0]=Median; Thres[1]=2*Median; Thres[2]=4*Median;
-  LogHist[0]=0;    LogHist[1]=0;      LogHist[2]=0;      LogHist[3]=0;
-  for(int Idx=0; Idx<Power.Full; Idx++)
-  { Float Pwr=Power.Data[Idx];
-    if(Pwr<Thres[0]) { LogHist[0]++; continue; }
-    if(Pwr<Thres[1]) { LogHist[1]++; continue; }
-    if(Pwr<Thres[2]) { LogHist[2]++; continue; }
-    LogHist[3]++;
-  }
-  if(LogHist[1]==0) return 0;
-  return -Median/log((double)LogHist[1]/LogHist[0]); } // return estimated sigma of the noise
-
-template <class Float>
- Float SpectraPowerLogHist(SampleBuffer<Float> &Power, Float Median)
-{ int LogHist[4]; return SpectraPowerLogHist(LogHist, Power, Median); }
-
-template <class Float>
- Float SpectraPowerLogHist(int *LogHist, SampleBuffer<Float> &Power, Float Median, int HistSize)
-{ Float Thres[HistSize-1];
-  LogHist[0]=0; Thres[0]=Median;
-  for(int Bin=1; Bin<(HistSize-1); Bin++)
-  { LogHist[Bin]=0; Thres[Bin]=2*Thres[Bin-1]; }
-  LogHist[HistSize-1]=0;
-  for(int Idx=0; Idx<Power.Full; Idx++)
-  { Float Pwr=Power.Data[Idx];
-    int Bin;
-    for(Bin=0; Bin<(HistSize-1); Bin++)
-    { if(Pwr<Thres[Bin]) { LogHist[Bin]+=1; break; } }
-    if(Bin==(HistSize-1)) LogHist[HistSize-1]+=1;
-  }
-  if(LogHist[1]==0) return 0;
-  return -Median/log((double)LogHist[1]/LogHist[0]); } // return estimated sigma of the noise
-
-template <class Float>
- Float SpectraPowerLogHist(SampleBuffer<Float> &Power, Float Median, int HistSize)
-{ int LogHist[HistSize]; return SpectraPowerLogHist(LogHist, Power, Median, HistSize); }
-
-// ==================================================================================================
-
-template <class Float>       // write an image (.pgm) spectrogram file out of the spectra power data
- int Spectrogram(const Float *Power, int Slides, int SpectraSize, const char *ImageFileName, Float RefPwr=1.00)
-{
-  FILE *ImageFile=0; if(ImageFileName) ImageFile=fopen(ImageFileName, "wb");
-  if(ImageFile==0) return -1;
-  fprintf(ImageFile, "P5\n%5d %6d\n255\n", SpectraSize, Slides);
-  uint8_t ImageLine[SpectraSize];
-  for(int Slide=0; Slide<Slides; Slide++)
-  { for(int Idx=0; Idx<SpectraSize; Idx++)
-    { Float Pwr = (*Power++);
-      int Pixel=0;
-      if(Pwr>0) Pixel = (int)floor(16+100.0*log10(Pwr/RefPwr)+0.5);
-      if(Pixel<0) { Pixel=0; } else if(Pixel>255) { Pixel=255; }
-      ImageLine[Idx]=Pixel; }
-    fwrite(ImageLine, 1, SpectraSize, ImageFile);
-  }
-  fclose(ImageFile); return Slides*SpectraSize; }
-
-template <class Float>
- int Spectrogram(SampleBuffer<Float> &SpectraPower, const char *ImageFileName, Float RefPwr=1.00)
-{ return Spectrogram(SpectraPower.Data, SpectraPower.Samples(), SpectraPower.Len, ImageFileName, RefPwr); }
-
-// ==================================================================================================
-
-#endif // __BUFFER_H_
diff --git a/fft.h b/fft.h
deleted file mode 100644
index 5850ac6..0000000
--- a/fft.h
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __FFT_H__
-#define __FFT_H__
-
-#include <stdint.h>
-#include <math.h>
-
-// #include <cmath> // for M_PI in C++11 - no, does not work
-#include <complex>
-#include <new>
-
-#include <fftw3.h>
-
-// ===========================================================================================
-
-template <class Float>
- class DFT1d
-{ public:
-   std::complex<Float> *Buffer; // input and output buffer
-   fftw_plan            Plan;   // FFTW specific
-   int                  Size;   // [FFT points]
-   int                  Sign;   // forward or backward (inverse)
-
-  public:
-   DFT1d() { Buffer=0; Plan=0; Size=0; Sign=0; }
-
-  ~DFT1d() { Free(); }
-
-  void Free(void)
-   { if(Buffer) { fftw_destroy_plan(Plan); fftw_free(Buffer); Buffer=0; Size=0; Sign=0; } }
-
-  int Preset(int Size, int Sign)
-  { if( (Size==this->Size) && (Sign==this->Sign) ) return Size;
-    Free();
-    Buffer = (std::complex<Float> *)fftw_malloc(Size*sizeof(std::complex<Float>)); if(Buffer==0) return -1;
-    Plan = fftw_plan_dft_1d(Size, (fftw_complex *)Buffer, (fftw_complex *)Buffer, Sign, FFTW_MEASURE);
-    this->Size=Size; this->Sign=Sign; return Size; }
-
-  int PresetForward(int Size) { return Preset(Size, FFTW_FORWARD); }
-  int PresetBackward(int Size) { return Preset(Size, FFTW_BACKWARD); }
-
-  template <class Type>
-   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
-  { for(int Idx=0; Idx<WindowSize; Idx++)
-    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
-  }
-
-  std::complex<Float>& operator [] (int Idx) { return Buffer[Idx]; }  // access to input/output buffer
-
-  void Execute(void) { return fftw_execute(Plan); }
-
-  void PrintPlan(void) { fftw_print_plan(Plan); printf("\n"); }
-
-} ;
-
-// ----------------------------------------------------------------------------------------------
-
-template <>
- class DFT1d <float>
-{ public:
-   std::complex<float> *Buffer;
-   fftwf_plan           Plan;
-   int                  Size;
-   int                  Sign;
-
-  public:
-   DFT1d() { Buffer=0; Plan=0; Size=0; Sign=0; }
-
-  ~DFT1d() { Free(); }
-
-  void Free(void)
-   { if(Buffer) { fftwf_destroy_plan(Plan); fftwf_free(Buffer); Buffer=0; Size=0; Sign=0; } }
-
-  int Preset(int Size, int Sign)
-  { if( (Size==this->Size) && (Sign==this->Sign) ) return Size;
-    Free();
-    Buffer = (std::complex<float> *)fftwf_malloc(Size*sizeof(std::complex<float>)); if(Buffer==0) return -1;
-    Plan = fftwf_plan_dft_1d(Size, (fftwf_complex *)Buffer, (fftwf_complex *)Buffer, Sign, FFTW_MEASURE);
-    this->Size=Size; this->Sign=Sign; return Size; }
-
-  int PresetForward(int Size) { return Preset(Size, FFTW_FORWARD); }
-  int PresetBackward(int Size) { return Preset(Size, FFTW_BACKWARD); }
-
-  template <class Type>
-   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
-  { for(int Idx=0; Idx<WindowSize; Idx++)
-    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
-  }
-
-  std::complex<float>& operator [] (int Idx) { return Buffer[Idx]; }  // access to input/output buffer
-
-  void Execute(void) { return fftwf_execute(Plan); }
-
-  void PrintPlan(void) { fftwf_print_plan(Plan); printf("\n"); }
-
-} ;
-
-// ===========================================================================================
-
-template <class Float=double>
- class InpSlideFFT
-{ public:
-   DFT1d<Float>         FwdFFT;       // forward FFT
-   int                  WindowSize;   // Window size = FFT size
-   int                  SlideSize;    // slide step for sliding-window FFT
-   Float               *Window;       // Window shape (Hanning)
-   std::complex<Float> *Pipe;         // input circular buffer
-   int                  Ptr;          // wrap-around input buffer pointer
-   std::complex<Float> *Output;       // pointer to FFT spectra
-
-  public:
-   InpSlideFFT() { WindowSize=0; Window=0; Pipe=0; }
-  ~InpSlideFFT() { Free(); }
-   void Free(void)  { delete [] Window; delete [] Pipe; Window=0; Pipe=0; WindowSize=0; }
-
-   int Size(void) const { return FwdFFT.Size; }
-   int Preset(int Size)
-   { // if(Size==WindowSize) return Size;
-     Free();                                             // deallocate everything
-     if(FwdFFT.PresetForward(Size)<0) return -1;         // setup forward FFT
-     WindowSize=Size;
-     Window = new (std::nothrow) Float               [WindowSize]; if(Window==0) return -1;
-     Pipe   = new (std::nothrow) std::complex<Float> [WindowSize]; if(Pipe==0) return -1;
-     SetSineWindow(); return Size; }                     // return FFT size (or negative when allocations failed)
-
-   void Clear(void) { for(int Idx=0; Idx<WindowSize; Idx++) { Pipe[Idx]=0; } Ptr=WindowSize-SlideSize; }
-
-   void SetHannWindow(int Slide=0)
-   { Float Scale=1.0/sqrt(WindowSize);                  // scale factor (forward+backward FFT scale data up by size)
-     for(int Idx=0; Idx<WindowSize; Idx++)
-     { Window[Idx]=Scale*(1.0-cos((2*M_PI*Idx)/WindowSize)); }
-     if(Slide==0) Slide=WindowSize/4;
-     SlideSize=Slide; Clear(); }
-
-   void SetSineWindow(int Slide=0)
-   { Float Scale=1.0/sqrt(WindowSize);
-     for(int Idx=0; Idx<WindowSize; Idx++)
-     { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
-   if(Slide==0) Slide=WindowSize/2;
-   SlideSize=Slide; Clear(); }
-
-   void SetGaussWindow(double Sigma, int Slide)
-   { int WindowSize2 = WindowSize/2;
-     for(int Idx=0; Idx<WindowSize; Idx++)
-     { double D=Idx-WindowSize2;
-       Window[Idx]=exp(-(D*D)/(2*Sigma*Sigma)); }
-   SlideSize=Slide; Clear(); }
-
-   void PrintWindow(void)
-   { printf("InpSlideFFT::Window[%d] =", WindowSize);
-     for(int Idx=0; Idx<WindowSize; Idx++)
-       printf(" %+5.3f", Window[Idx]);
-     printf("\n"); }
-
-   int Process(const uint8_t *Input, Float Bias=127.38)       // process exactly one slide [SlideSize] of samples
-   { int Idx;
-     if(Input)                                                    //
-     { for(Idx=0; Idx<SlideSize; Idx++)                           // enter new samples into the Pipe
-       { std::complex<Float> CmpxInput(Input[0]-Bias, Input[1]-Bias);
-         Pipe[Ptr++] = CmpxInput; Input+=2;
-         if(Ptr>=WindowSize) Ptr=0; }
-     } else                                                       // if no Input given
-     { for(Idx=0; Idx<SlideSize; Idx++)                           // enter zeros into the pipe
-       { Pipe[Ptr++] = 0; if(Ptr>=WindowSize) Ptr=0; }
-     }
-     return ProcessWindow(); }
-
-  template <class InpFloat>
-   int Process(std::complex<InpFloat> *Input)                      // process exactly one slide [SlideSize] of samples
-   { int Idx;
-     if(Input)
-     { for(Idx=0; Idx<SlideSize; Idx++)                            // enter new samples into the Pipe
-       { Pipe[Ptr++] = Input[Idx]; if(Ptr>=WindowSize) Ptr=0; }
-     } else
-     { for(Idx=0; Idx<SlideSize; Idx++)                           // enter zeros into the pipe
-       { Pipe[Ptr++] = 0; if(Ptr>=WindowSize) Ptr=0; }
-     }
-     return ProcessWindow(); }
-
-   int ProcessWindow(void)
-   { int Idx;
-     for(Idx=0; Ptr<WindowSize; Idx++)                            // multiply by the Window and copy to FwdFFT buffer
-     { FwdFFT[Idx] = Window[Idx]*Pipe[Ptr++]; }
-     Ptr=0;
-     for(     ; Idx<WindowSize; Idx++)
-     { FwdFFT[Idx] = Window[Idx]*Pipe[Ptr++]; }
-     FwdFFT.Execute();                                             // execute forward FFT
-     Output = FwdFFT.Buffer;                                       // spectra in now in FwdFFT.Buffer
-     return SlideSize; }
-
-} ;
-
-// ===========================================================================================
-
-template <class Float=double>
- class OutSlideFFT
-{ public:
-   DFT1d<Float>         BwdFFT;       // backward FFT
-   int                  WindowSize;   // Window size = FFT size
-   int                  SlideSize;    // slide step for sliding-window FFT
-   Float               *Window;       // Window shape (Hanning)
-   std::complex<Float> *Pipe;         // output circular buffer
-   int                  Ptr;          // wrap-around input buffer pointer
-   std::complex<Float> *Input;        // here the input spectra are to be placed
-   std::complex<Float> *Output;       // the output samples (beware of circular buffering)
-
-  public:
-   OutSlideFFT() { WindowSize=0; Window=0; Pipe=0; Input=0; Output=0; }
-  ~OutSlideFFT() { Free(); }
-   void Free(void)  { delete [] Window; delete [] Pipe; Window=0; Pipe=0; WindowSize=0; }
-
-   int Size(void) const { return BwdFFT.Size; }
-   int Preset(int Size)
-   { // if(Size==WindowSize) return Size;                   // to avoid reallocations
-     Free();                                             // deallocate everything
-     if(BwdFFT.PresetBackward(Size)<0) return -1;        // setup forward FFT
-     WindowSize=Size;
-     Input = BwdFFT.Buffer;                              // here the input spectra is to be place
-     Window = new (std::nothrow) Float               [WindowSize]; if(Window==0) return -1;
-     Pipe   = new (std::nothrow) std::complex<Float> [WindowSize]; if(Pipe==0) return -1;
-     SetSineWindow(); return Size; }                     // return FFT size (or negative when allocations failed)
-
-   void Clear(void) { for(int Idx=0; Idx<WindowSize; Idx++) { Pipe[Idx]=0; } Ptr=WindowSize-SlideSize; Output=Pipe+Ptr; }
-
-   void SetHannWindow(int Slide=0)
-   { double Scale=0.5/sqrt(WindowSize);                  // scale factor (forward+backward FFT scale data up by size)
-     for(int Idx=0; Idx<WindowSize; Idx++)
-     { Window[Idx]=Scale*(1.0-cos((2*M_PI*Idx)/WindowSize)); }
-     if(Slide==0) Slide=WindowSize/4;
-     SlideSize=Slide; Clear(); }
-
-   void SetSineWindow(int Slide=0)
-   { double Scale=0.5/sqrt(WindowSize);
-     for(int Idx=0; Idx<WindowSize; Idx++)
-     { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
-   if(Slide==0) Slide=WindowSize/2;
-   SlideSize=Slide; Clear(); }
-
-   void SetGaussWindow(double Sigma, int Slide)
-   { int WindowSize2 = WindowSize/2;
-     for(int Idx=0; Idx<WindowSize; Idx++)
-     { double D=Idx-WindowSize2;
-       Window[Idx]=exp(-(D*D)/(2*Sigma*Sigma)); }
-   SlideSize=Slide; Clear(); }
-
-   void PrintWindow(void)
-   { printf("OutSlideFFT::Window[%d] =", WindowSize);
-     for(int Idx=0; Idx<WindowSize; Idx++)
-       printf(" %+5.3f", Window[Idx]);
-     printf("\n"); }
-
-   int Process(void)                                     // spectra to be processed must be in Input
-   { int Idx;
-     BwdFFT.Execute();
-
-     for(Idx=0; Idx<SlideSize; Idx++)
-     { Pipe[Ptr++] = 0;
-       if(Ptr>=WindowSize) Ptr=0; }
-
-     Output = Pipe+Ptr;
-
-     for(Idx=0; Ptr<WindowSize; Idx++)
-     { Pipe[Ptr++] += Input[Idx]*Window[Idx]; }
-     Ptr=0;
-     for(     ; Idx<WindowSize; Idx++)
-     { Pipe[Ptr++] += Input[Idx]*Window[Idx]; }
-
-     return SlideSize; }
-
-   template <class SpectraType>
-    int Process(std::complex<SpectraType> *Spectra)
-   { for(int Idx=0; Idx<WindowSize; Idx++)
-     { Input[Idx] = Spectra[Idx]; }
-     return Process(); }
-
-   template <class SpectraType, class MaskType>
-    int Process(std::complex<SpectraType> *Spectra, MaskType *Mask)
-   { for(int Idx=0; Idx<WindowSize; Idx++)
-     { Input[Idx] = Spectra[Idx]*Mask[Idx]; }
-     return Process(); }
-
-   template <class OutType>
-    int GetOutput(std::complex<OutType> *Output, int Decimate=1) // Decimate must be a 1,2,4,8,16,...
-   { int Idx, OutPtr = Ptr;
-     for(Idx=0; Idx<SlideSize; Idx+=Decimate)
-     { (*Output++)=Pipe[OutPtr]; OutPtr+=Decimate; if(OutPtr>=WindowSize) OutPtr-=WindowSize; }
-     return SlideSize/Decimate; }
-
-} ; 
-
-// ===========================================================================================
-
-#ifdef USE_RPI_GPU_FFT     // the following code is Raspberry PI specific
-
-#include "mailbox.h"
-#include "gpu_fft.h"
-
-class RPI_GPU_FFT
-{ public:
-
-   struct GPU_FFT *FFT;
-   int MailBox;
-   int Size;
-   int Sign;
-   int Jobs;
-
-  public:
-   RPI_GPU_FFT()
-   { MailBox=mbox_open(); FFT=0; Size=0; Sign=0; Jobs=0; }
-
-  ~RPI_GPU_FFT()
-   { Free(); mbox_close(MailBox); }
-
-   void Free(void)
-   { if(FFT==0) return;
-     gpu_fft_release(FFT);
-     FFT=0; Size=0; Sign=0; Jobs=0; }
-
-   int Preset(int Size, int Sign, int Jobs=32)
-   { if( FFT && (Size==this->Size) && (Sign==this->Sign) && (Jobs==this->Jobs) ) return Size;
-     Free(); if(Size<256) return -1;
-     int LogN;
-     for(LogN=8; LogN<=22; LogN++)
-     { if(Size==(1<<LogN)) break; }
-     if(LogN>22) return -1;
-     int Err=gpu_fft_prepare(MailBox, LogN, Sign, Jobs, &FFT);
-     if(Err<0) { FFT=0; Size=0; return Err; } // -1 => firmware up todate ?, -2 => Size not supported ?, -3 => not enough GPU memory
-     this->Size=Size; this->Sign=Sign; this->Jobs=Jobs; return Size; }
-
-   int PresetForward (int Size, int Jobs=32) { return Preset(Size, GPU_FFT_FWD, Jobs); }
-   int PresetBackward(int Size, int Jobs=32) { return Preset(Size, GPU_FFT_REV, Jobs); }
-
-   std::complex<float> *Input (int Job=0) { return (std::complex<float> *)(FFT->in  + Job*FFT->step); }
-   void Execute(void) { gpu_fft_execute(FFT); }
-   std::complex<float> *Output(int Job=0) { return (std::complex<float> *)(FFT->out + Job*FFT->step); }
-
-  template <class Type>
-   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
-  { for(int Idx=0; Idx<WindowSize; Idx++)
-    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
-  }
-
-} ;
-
-#endif
-
-// ===========================================================================================
-
-#endif // of  __FFT_H__
diff --git a/gpu_fft.c b/gpu_fft.c
deleted file mode 100644
index 5bda67b..0000000
--- a/gpu_fft.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
-BCM2835 "GPU_FFT" release 3.0
-Copyright (c) 2015, Andrew Holme.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <string.h>
-
-#include "gpu_fft.h"
-
-#define GPU_FFT_BUSY_WAIT_LIMIT (5<<12) // ~1ms
-
-typedef struct GPU_FFT_COMPLEX COMPLEX;
-
-int gpu_fft_prepare(
-    int mb,         // mailbox file_desc
-    int log2_N,     // log2(FFT_length) = 8...22
-    int direction,  // GPU_FFT_FWD: fft(); GPU_FFT_REV: ifft()
-    int jobs,       // number of transforms in batch
-    struct GPU_FFT **fft) {
-
-    unsigned info_bytes, twid_bytes, data_bytes, code_bytes, unif_bytes, mail_bytes;
-    unsigned size, *uptr, vc_tw, vc_data;
-    int i, q, shared, unique, passes, ret;
-
-    struct GPU_FFT_BASE *base;
-    struct GPU_FFT_PTR ptr;
-    struct GPU_FFT *info;
-
-    if (gpu_fft_twiddle_size(log2_N, &shared, &unique, &passes)) return -2;
-
-    info_bytes = 4096;
-    data_bytes = (1+((sizeof(COMPLEX)<<log2_N)|4095));
-    code_bytes = gpu_fft_shader_size(log2_N);
-    twid_bytes = sizeof(COMPLEX)*16*(shared+GPU_FFT_QPUS*unique);
-    unif_bytes = sizeof(int)*GPU_FFT_QPUS*(5+jobs*2);
-    mail_bytes = sizeof(int)*GPU_FFT_QPUS*2;
-
-    size  = info_bytes +        // header
-            data_bytes*jobs*2 + // ping-pong data, aligned
-            code_bytes +        // shader, aligned
-            twid_bytes +        // twiddles
-            unif_bytes +        // uniforms
-            mail_bytes;         // mailbox message
-
-    ret = gpu_fft_alloc(mb, size, &ptr);
-    if (ret) return ret;
-
-    // Header
-    info = (struct GPU_FFT *) ptr.arm.vptr;
-    base = (struct GPU_FFT_BASE *) info;
-    gpu_fft_ptr_inc(&ptr, info_bytes);
-
-    // For transpose
-    info->x = 1<<log2_N;
-    info->y = jobs;
-
-    // Ping-pong buffers leave results in or out of place
-    info->in = info->out = ptr.arm.cptr;
-    info->step = data_bytes / sizeof(COMPLEX);
-    if (passes&1) info->out += info->step * jobs; // odd => out of place
-    vc_data = gpu_fft_ptr_inc(&ptr, data_bytes*jobs*2);
-
-    // Shader code
-    memcpy(ptr.arm.vptr, gpu_fft_shader_code(log2_N), code_bytes);
-    base->vc_code = gpu_fft_ptr_inc(&ptr, code_bytes);
-
-    // Twiddles
-    gpu_fft_twiddle_data(log2_N, direction, ptr.arm.fptr);
-    vc_tw = gpu_fft_ptr_inc(&ptr, twid_bytes);
-
-    uptr = ptr.arm.uptr;
-
-    // Uniforms
-    for (q=0; q<GPU_FFT_QPUS; q++) {
-        *uptr++ = vc_tw;
-        *uptr++ = vc_tw + sizeof(COMPLEX)*16*(shared + q*unique);
-        *uptr++ = q;
-        for (i=0; i<jobs; i++) {
-            *uptr++ = vc_data + data_bytes*i;
-            *uptr++ = vc_data + data_bytes*i + data_bytes*jobs;
-        }
-        *uptr++ = 0;
-        *uptr++ = (q==0); // For mailbox: IRQ enable, master only
-
-        base->vc_unifs[q] = gpu_fft_ptr_inc(&ptr, sizeof(int)*(5+jobs*2));
-    }
-
-    if ((jobs<<log2_N) <= GPU_FFT_BUSY_WAIT_LIMIT) {
-        // Direct register poking with busy wait
-        base->vc_msg = 0;
-    }
-    else {
-        // Mailbox message
-        for (q=0; q<GPU_FFT_QPUS; q++) {
-            *uptr++ = base->vc_unifs[q];
-            *uptr++ = base->vc_code;
-        }
-
-        base->vc_msg = ptr.vc;
-    }
-
-    *fft = info;
-    return 0;
-}
-
-unsigned gpu_fft_execute(struct GPU_FFT *info) {
-    return gpu_fft_base_exec(&info->base, GPU_FFT_QPUS);
-}
-
-void gpu_fft_release(struct GPU_FFT *info) {
-    gpu_fft_base_release(&info->base);
-}
diff --git a/gpu_fft.h b/gpu_fft.h
deleted file mode 100644
index 8b1cb08..0000000
--- a/gpu_fft.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-BCM2835 "GPU_FFT" release 3.0
-Copyright (c) 2015, Andrew Holme.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef __GPU_FFT__
-#define __GPU_FFT__
-
-#define GPU_FFT_QPUS 8
-
-#define GPU_FFT_PI 3.14159265358979323846
-
-#define GPU_FFT_FWD 0 // forward FFT
-#define GPU_FFT_REV 1 // inverse FFT
-
-struct GPU_FFT_COMPLEX {
-    float re, im;
-};
-
-struct GPU_FFT_PTR {
-    unsigned vc;
-    union { struct GPU_FFT_COMPLEX *cptr;
-            void                   *vptr;
-            char                   *bptr;
-            float                  *fptr;
-            unsigned               *uptr; } arm;
-};
-
-struct GPU_FFT_BASE {
-    int mb;
-    unsigned handle, size, vc_msg, vc_code, vc_unifs[GPU_FFT_QPUS], peri_size;
-    volatile unsigned *peri;
-};
-
-struct GPU_FFT {
-    struct GPU_FFT_BASE base;
-    struct GPU_FFT_COMPLEX *in, *out;
-    int x, y, step;
-};
-
-int gpu_fft_prepare(
-    int mb,         // mailbox file_desc
-    int log2_N,     // log2(FFT_length) = 8...22
-    int direction,  // GPU_FFT_FWD: fft(); GPU_FFT_REV: ifft()
-    int jobs,       // number of transforms in batch
-    struct GPU_FFT **fft);
-
-unsigned gpu_fft_execute(
-    struct GPU_FFT *info);
-
-void gpu_fft_release(
-    struct GPU_FFT *info);
-
-// private
-int           gpu_fft_twiddle_size(int, int *, int *, int *);
-void          gpu_fft_twiddle_data(int, int, float *);
-unsigned int  gpu_fft_shader_size(int);
-unsigned int *gpu_fft_shader_code(int);
-
-// gpu_fft_base:
-
-unsigned gpu_fft_base_exec (
-    struct GPU_FFT_BASE *base,
-    int num_qpus);
-
-int gpu_fft_alloc (
-    int mb,
-    unsigned size,
-    struct GPU_FFT_PTR *ptr);
-
-void gpu_fft_base_release(
-    struct GPU_FFT_BASE *base);
-
-unsigned gpu_fft_ptr_inc (
-    struct GPU_FFT_PTR *ptr,
-    int bytes);
-
-#endif // __GPU_FFT__
diff --git a/gpu_fft_shaders.c b/gpu_fft_shaders.c
deleted file mode 100644
index f8e3bfe..0000000
--- a/gpu_fft_shaders.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
-BCM2835 "GPU_FFT" release 3.0
-Copyright (c) 2015, Andrew Holme.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-static unsigned int shader_256[] = {
-    #include "hex/shader_256.hex"
-};
-static unsigned int shader_512[] = {
-    #include "hex/shader_512.hex"
-};
-static unsigned int shader_1k[] = {
-    #include "hex/shader_1k.hex"
-};
-static unsigned int shader_2k[] = {
-    #include "hex/shader_2k.hex"
-};
-static unsigned int shader_4k[] = {
-    #include "hex/shader_4k.hex"
-};
-static unsigned int shader_8k[] = {
-    #include "hex/shader_8k.hex"
-};
-static unsigned int shader_16k[] = {
-    #include "hex/shader_16k.hex"
-};
-static unsigned int shader_32k[] = {
-    #include "hex/shader_32k.hex"
-};
-static unsigned int shader_64k[] = {
-    #include "hex/shader_64k.hex"
-};
-static unsigned int shader_128k[] = {
-    #include "hex/shader_128k.hex"
-};
-static unsigned int shader_256k[] = {
-    #include "hex/shader_256k.hex"
-};
-static unsigned int shader_512k[] = {
-    #include "hex/shader_512k.hex"
-};
-static unsigned int shader_1024k[] = {
-    #include "hex/shader_1024k.hex"
-};
-static unsigned int shader_2048k[] = {
-    #include "hex/shader_2048k.hex"
-};
-static unsigned int shader_4096k[] = {
-    #include "hex/shader_4096k.hex"
-};
-
-static struct {
-    unsigned int size, *code;
-}
-shaders[] = {
-    {sizeof(shader_256), shader_256},
-    {sizeof(shader_512), shader_512},
-    {sizeof(shader_1k), shader_1k},
-    {sizeof(shader_2k), shader_2k},
-    {sizeof(shader_4k), shader_4k},
-    {sizeof(shader_8k), shader_8k},
-    {sizeof(shader_16k), shader_16k},
-    {sizeof(shader_32k), shader_32k},
-    {sizeof(shader_64k), shader_64k},
-    {sizeof(shader_128k), shader_128k},
-    {sizeof(shader_256k), shader_256k},
-    {sizeof(shader_512k), shader_512k},
-    {sizeof(shader_1024k), shader_1024k},
-    {sizeof(shader_2048k), shader_2048k},
-    {sizeof(shader_4096k), shader_4096k}
-};
-
-unsigned int  gpu_fft_shader_size(int log2_N) {
-    return shaders[log2_N-8].size;
-}
-
-unsigned int *gpu_fft_shader_code(int log2_N) {
-    return shaders[log2_N-8].code;
-}
diff --git a/gpu_fft_twiddles.c b/gpu_fft_twiddles.c
deleted file mode 100644
index 5323650..0000000
--- a/gpu_fft_twiddles.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
-BCM2835 "GPU_FFT" release 3.0
-Copyright (c) 2015, Andrew Holme.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <math.h>
-
-#include "gpu_fft.h"
-
-#define ALPHA(dx) (2*pow(sin((dx)/2),2))
-#define  BETA(dx) (sin(dx))
-
-static double k[16] = {0,8,4,4,2,2,2,2,1,1,1,1,1,1,1,1};
-static double m[16] = {0,0,0,1,0,1,2,3,0,1,2,3,4,5,6,7};
-
-/****************************************************************************/
-
-static float *twiddles_base_16(double two_pi, float *out, double theta) {
-    int i;
-    for (i=0; i<16; i++) {
-        *out++ = cos(two_pi/16*k[i]*m[i] + theta*k[i]);
-        *out++ = sin(two_pi/16*k[i]*m[i] + theta*k[i]);
-    }
-    return out;
-}
-
-static float *twiddles_base_32(double two_pi, float *out, double theta) {
-    int i;
-    for (i=0; i<16; i++) {
-        *out++ = cos(two_pi/32*i + theta);
-        *out++ = sin(two_pi/32*i + theta);
-    }
-    return twiddles_base_16(two_pi, out, 2*theta);
-}
-
-static float *twiddles_base_64(double two_pi, float *out) {
-    int i;
-    for (i=0; i<32; i++) {
-        *out++ = cos(two_pi/64*i);
-        *out++ = sin(two_pi/64*i);
-    }
-    return twiddles_base_32(two_pi, out, 0);
-}
-
-/****************************************************************************/
-
-static float *twiddles_step_16(double two_pi, float *out, double theta) {
-    int i;
-    for (i=0; i<16; i++) {
-        *out++ = ALPHA(theta*k[i]);
-        *out++ =  BETA(theta*k[i]);
-    }
-    return out;
-}
-
-static float *twiddles_step_32(double two_pi, float *out, double theta) {
-    int i;
-    for (i=0; i<16; i++) {
-        *out++ = ALPHA(theta);
-        *out++ =  BETA(theta);
-    }
-    return twiddles_step_16(two_pi, out, 2*theta);
-}
-
-static float *twiddles_step_64(double two_pi, float *out, double theta) {
-    int i;
-    for (i=0; i<32; i++) {
-        *out++ = ALPHA(theta);
-        *out++ =  BETA(theta);
-    }
-    return twiddles_step_32(two_pi, out, 2*theta);
-}
-
-/****************************************************************************/
-
-static void twiddles_256(double two_pi, float *out) {
-    double N=256;
-    int q;
-
-    out = twiddles_base_16(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_16(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_512(double two_pi, float *out) {
-    double N=512;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_16(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_1k(double two_pi, float *out) {
-    double N=1024;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_2k(double two_pi, float *out) {
-    double N=2048;
-    int q;
-
-    out = twiddles_base_64(two_pi, out);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_4k(double two_pi, float *out) {
-    double N=4096;
-    int q;
-
-    out = twiddles_base_16(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 16);
-    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_16(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_8k(double two_pi, float *out) {
-    double N=8192;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 16);
-    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_16(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_16k(double two_pi, float *out) {
-    double N=16384;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 16);
-    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_16(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_32k(double two_pi, float *out) {
-    double N=32768;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_64k(double two_pi, float *out) {
-    double N=65536;
-    int q;
-
-    out = twiddles_base_64(two_pi, out);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_128k(double two_pi, float *out) {
-    double N=128*1024;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 16*16);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 16);
-    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_16(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_256k(double two_pi, float *out) {
-    double N=256*1024;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 32*16);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_512k(double two_pi, float *out) {
-    double N=512*1024;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_16(two_pi, out, two_pi/N * 32*32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_1024k(double two_pi, float *out) {
-    double N=1024*1024;
-    int q;
-
-    out = twiddles_base_32(two_pi, out, 0);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32*32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_2048k(double two_pi, float *out) {
-    double N=2048*1024;
-    int q;
-
-    out = twiddles_base_64(two_pi, out);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32*32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-static void twiddles_4096k(double two_pi, float *out) {
-    double N=4096*1024;
-    int q;
-
-    out = twiddles_base_64(two_pi, out);
-    out = twiddles_step_64(two_pi, out, two_pi/N * 32*32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
-    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
-
-    for (q=0; q<GPU_FFT_QPUS; q++)
-        out = twiddles_base_32(two_pi, out, two_pi/N*q);
-}
-
-/****************************************************************************/
-
-static struct {
-    int passes, shared, unique;
-    void (*twiddles)(double, float *);
-}
-shaders[] = {
-    {2, 2, 1, twiddles_256},
-    {2, 3, 1, twiddles_512},
-    {2, 4, 2, twiddles_1k},
-    {2, 6, 2, twiddles_2k},
-    {3, 3, 1, twiddles_4k},
-    {3, 4, 1, twiddles_8k},
-    {3, 5, 1, twiddles_16k},
-    {3, 6, 2, twiddles_32k},
-    {3, 8, 2, twiddles_64k},
-    {4, 5, 1, twiddles_128k},
-    {4, 6, 2, twiddles_256k},
-    {4, 7, 2, twiddles_512k},
-    {4, 8, 2, twiddles_1024k},
-    {4,10, 2, twiddles_2048k},
-    {4,12, 2, twiddles_4096k}
-};
-
-int gpu_fft_twiddle_size(int log2_N, int *shared, int *unique, int *passes) {
-    if (log2_N<8 || log2_N>22) return -1;
-    *shared = shaders[log2_N-8].shared;
-    *unique = shaders[log2_N-8].unique;
-    *passes = shaders[log2_N-8].passes;
-    return 0;
-}
-
-void gpu_fft_twiddle_data(int log2_N, int direction, float *out) {
-    shaders[log2_N-8].twiddles((direction==GPU_FFT_FWD?-2:2)*GPU_FFT_PI, out);
-}
diff --git a/gsm_scan.cc b/gsm_scan.cc
deleted file mode 100644
index 70712fc..0000000
--- a/gsm_scan.cc
+++ /dev/null
@@ -1,296 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-#include <string.h>
-#include <time.h>
-
-#include <math.h>
-
-#include <vector>
-#include <algorithm>
-
-#include "rtlsdr.h"
-#include "buffer.h"
-#include "fft.h"
-#include "image.h"
-
-#define FloatType float
-
-// ==================================================================================================================
-
-const int GSM_ChannelWidth = 200000; // [Hz]
-const int GSM_DataRate     = 270833; // [bps]
-
-// ==================================================================================================================
-
-   template <class Float>
-    void AverPeakBkg(Float &Aver, Float &Peak, Float &PeakPos, Float &Bkg, Float *Data, int Size)
-   { Aver=0; Peak=0; PeakPos=0; int PeakIdx=0;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Float Dat=Data[Idx];
-       if(Dat>Peak) { Peak=Dat; PeakIdx=Idx; }
-       Aver+=Dat; }
-     if(PeakIdx==0)             { Peak+=Data[     1];                    PeakPos=PeakIdx+Data[     1]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
-     else if(PeakPos==(Size-1)) { Peak+=Data[Size-2];                    PeakPos=PeakIdx-Data[Size-2]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
-     else                       { Peak+=Data[PeakIdx+1]+Data[PeakIdx-1]; PeakPos=PeakIdx+(Data[PeakIdx+1]-Data[PeakIdx-1])/Peak; Bkg=(Aver-Peak)/(Size-3); }
-     Aver/=Size; }
-
-   template <class Float>
-    void AverRMS(Float &Aver, Float &RMS, Float *Data, int Size) // classical average and RMS of a data series
-   { Aver=0; RMS=0;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Aver+=Data[Idx]; }
-     Aver/=Size;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Float Diff=Data[Idx]-Aver; RMS+=Diff*Diff; }
-     RMS=sqrt(RMS/Size); }
-
-   template <class Float>
-    int ProcessChan(std::vector<Float> &PPM_Values, Float &AverPower,
-                    int LowBin, int UppBin, Float CenterBin, Float BinWidth, Float CenterFreq,
-                    SampleBuffer<Float> &Power)
-   { int Slides = Power.Samples();
-     int Bins = Power.Len;
-     SampleBuffer<Float> Aver, Peak, PeakPos, Bkg;
-     Aver.Allocate(1, Slides); Peak.Allocate(1, Slides); PeakPos.Allocate(1, Slides); Bkg.Allocate(1, Slides);
-     Float *Data = Power.Data;
-     for(int Idx=0; Idx<Slides; Idx++, Data+=Bins)
-     { AverPeakBkg(Aver[Idx], Peak[Idx], PeakPos[Idx], Bkg[Idx], Data+LowBin, UppBin-LowBin+1);
-       PeakPos[Idx]+=LowBin-CenterBin; }
-     Aver.Full=Slides; Peak.Full=Slides; PeakPos.Full=Slides; Bkg.Full=Slides;
-     Float PowerRMS; AverRMS(AverPower, PowerRMS, Aver.Data, Slides);
-     // printf("AverPower=%3.1f, PowerRMS=%3.1f\n", AverPower, PowerRMS);
-     if(PowerRMS>(0.5*AverPower)) return 0;                                   // skip pulsing channels
-
-     Float AverPeak, PeakRMS; AverRMS(AverPeak, PeakRMS, Peak.Data, Slides);
-     Float AverBkg, BkgRMS; AverRMS(AverBkg, BkgRMS, Bkg.Data, Slides);
-     // printf("AverPeak=%3.1f, PeakRMS=%3.1f, AverBkg=%5.3f, BkgRMS=%5.3f\n", AverPeak, PeakRMS, AverBkg, BkgRMS);
-
-     int Marks=0;
-     Float PeakThres = 4*PeakRMS;
-     Float BkgThres  = 4*BkgRMS;
-     for(int Idx=1; Idx<(Slides-1); Idx++)
-     { Float PeakL=Peak.Data[Idx-1]-AverPeak;
-       Float PeakM=Peak.Data[Idx  ]-AverPeak;
-       Float PeakR=Peak.Data[Idx+1]-AverPeak;
-       Float PeakSum = PeakL+PeakM+PeakR;
-       if(PeakSum<=PeakThres) continue;
-       if(PeakM<PeakL)  continue;
-       if(PeakM<=PeakR) continue;
-       if(PeakM<=((PeakL+PeakR)/2)) continue;
-       Float BkgSum = Bkg.Data[Idx-1]+Bkg.Data[Idx]+Bkg.Data[Idx+1];
-       if((3*AverBkg-BkgSum)<BkgThres) continue;
-       if(Peak.Data[Idx]<(32*Bkg.Data[Idx])) continue;
-       Float PPM = -1e6*(PeakPos.Data[Idx]*BinWidth-(Float)GSM_DataRate/4)/CenterFreq;
-       // printf("Mark: PeakSum[%5d]=%8.1f/%6.1f Bkg=%8.3f/%6.3f Peak/Bkg=%8.1f PeakPos=%+7.3f %+7.3fppm\n",
-       //         Idx, PeakSum, PeakThres, 3*AverBkg-BkgSum, BkgThres, Peak.Data[Idx]/Bkg.Data[Idx], PeakPos.Data[Idx], PPM);
-       PPM_Values.push_back(PPM);
-       Marks++; }
-
-     return Marks; }
-/*
-   template <class Float>
-    int EstimatePPM(double &EstPPM, SampleBuffer<Float> &Power)
-   { int Slides = Power.Samples();
-     int Bins = Power.Len;
-     double Sum[Bins];
-     for(int Bin=0; Bin<Bins; Bin++)
-     { Sum[Bin]=0; }
-     Float *Data = Power.Data;
-     for(int Slide=0; Slide<Slides; Slide++)
-     { for(int Bin=0; Bin<Bins; Bin++)
-       { Sum[Bin]+=Data[Bin]; }
-       Data+=Bins; }
-     double I=0, Q=0;
-     for(int Bin=0; Bin<Bins; Bin++)
-     { double Phase=(10.0*Bin)/Bins; Phase-=floor(Phase); Phase*=2*M_PI;
-       double LogPwr = Sum[Bin];
-       I += LogPwr*cos(Phase);
-       Q += LogPwr*sin(Phase); }
-     printf("EstimatePPM(%7.3fMHz, %dx%d) I/Q=%+8.1f/%+8.1f\n", 1e-6*Power.Freq, Slides, Bins, I, Q);
-     return 0; }
-*/
-// ==================================================================================================================
-
-  const char *OptionHelp = "\
-  --device <device index>         [int] RTLSDR device index\n\
-  --serial <serial number>        [string] RTLSDR device serial number\n\
-  --ppm <crystal correction>      [ppm] receiver crystal correction\n\
-  --gain <receiver gain>          [dB] receiver gain [default is auto-gain]\n\
-  --offset-tuning                      enable offset tuning - for E4000 tuner\n\
-  --gsm-850                            scan the GSM-850 band for USA and Canada (default is E-GSM for Europe)\n\
-" ;
-
-int main(int argc, char **argv)
-{ 
-  RTLSDR SDR;     // DVB-T device with the RTL2832U control chip
-
-  int RxDevice       =         0;    // [Index] device index for RTLSDR device
-  int RxCrystalCorr  =         0;    // [PPM] crystal frequency correction for the DVB-T receiver
-  int RxGain         =       200;    // [0.1dB] receiver gain - low default gain for the GSM band as signals are strong
-  int RxOffsetTuning =         0;    // [bool]
-  int SampleRate     =   2000000;    // [Hz] => single scan takes 10 GSM channels (0.2MHz/channel)
-  int LowerFreq      = 920000000;    // [Hz] => scan whole E-GSM band
-  int UpperFreq      = 960000000;    // [Hz]
-  // int LowerFreq      = 868000000;    // [Hz] => scan whole GSM-850 band
-  // int UpperFreq      = 900000000;    // [Hz]
-  int GuardBand      =    100000;    // [Hz] first channel starts at 921.0 + 0.1 = 921.1 MHz
-  int FFTsize        =      1024;    // [FFT bins] => FFT resolution = 3200000/1024 = ~6.4kHz/bin
-  int SamplesPerScan =    500000;    // 0.250sec of RF data per scan
-
-  int arg=1;
-  for( ; arg<argc; )
-  {
-    if(memcmp(argv[arg],"--",2)==0)
-    { char *OptName=argv[arg]+2;
-      if(strcmp(OptName,"help")==0)
-      { printf("Usage: %s [options]\n%s", argv[0], OptionHelp); exit(0); }
-      else if(strcmp(OptName,"device")==0)
-      { if(sscanf(argv[++arg], "%d", &RxDevice)!=1)
-        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
-        arg++; }
-      else if(strcmp(OptName,"serial")==0)
-      { int Index=SDR.getDeviceIndexBySerial(argv[++arg]);
-        if(Index<0)
-        { printf("Device with serial %s not found (%d)\n", argv[arg], Index); exit(0); }
-        RxDevice=Index;
-        arg++; }
-      else if(strcmp(OptName,"ppm")==0)
-      { if(sscanf(argv[++arg], "%d", &RxCrystalCorr)!=1)
-        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
-        arg++; }
-      else if(strcmp(OptName,"gain")==0)
-      { float Gain;
-        if(sscanf(argv[++arg], "%f", &Gain)!=1)
-        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
-        RxGain = (int)floor(10*Gain+0.5);
-        arg++; }
-      else if(strcmp(OptName,"offset-tuning")==0)
-      { RxOffsetTuning=1;
-        arg++; }
-      else if(strcmp(OptName,"gsm-850")==0)
-      { LowerFreq = 868000000; UpperFreq = 900000000;
-        arg++; }
-      else if( (strcmp(OptName,"sample-rate")==0) || (strcmp(OptName,"bandwidth")==0) )
-      { if(sscanf(argv[++arg], "%d", &SampleRate)!=1)
-        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
-        arg++; }
-    }
-    else if(argv[arg][0]=='-')
-    { printf("Unknown option: %s\n", argv[arg]); exit(0);
-    }
-    else
-    { printf("File names not allowed, only options\n"); exit(0);
-      arg++; }
-  }
-
-  int CenterFreq     = (LowerFreq+UpperFreq)/2;                      // [Hz] center frequency of the scan
-  int FreqStep       = SampleRate;                                   // [Hz] scanning step
-  int FFTsize2       = FFTsize/2;
-  int Scans          = (UpperFreq-LowerFreq-2*GuardBand+FreqStep-1)/FreqStep;    // number of scan to cover the desired band
-      UpperFreq      =  LowerFreq+Scans*FreqStep+2*GuardBand;                    // [Hz]
-      CenterFreq     = (LowerFreq+UpperFreq)/2;                                  // [Hz]
-
-#ifdef USE_RPI_GPU_FFT
-  RPI_GPU_FFT       FFT;
-#else
-  DFT1d<FloatType>  FFT;
-#endif
-  FloatType         Window[FFTsize];
-  FFT.PresetForward(FFTsize); FFT.SetSineWindow(Window, FFTsize, (FloatType)(1.0/sqrt(FFTsize)) );
-
-  printf("Frequency = %5.3fMHz..%5.3fMHz %5.3fMHz step, %d scans\n",
-                       1e-6*LowerFreq, 1e-6*UpperFreq, 1e-6*FreqStep, Scans);
-  printf("Sampling rate    = %10dHz = %8.3fMHz\n", SampleRate, 1e-6*SampleRate);
-  printf("%5.3fsec per scan\n", (double)SamplesPerScan/SampleRate);
-  printf("FFT: %d bins, %3.1fHz/bin, %5.3fms/slide\n",
-          FFTsize, (double)SampleRate/FFTsize, 0.5e3*FFTsize/SampleRate);
-
-  if(SDR.Open(RxDevice, CenterFreq, SampleRate)<0)        // open the RTLSDR device
-  { printf("Can't open RTLSDR device #%d\n", RxDevice);  return 0; }
-  printf("Open(%d, %d, %d) OK\n", RxDevice, CenterFreq, SampleRate);
-
-  SDR.setFreqCorrection(RxCrystalCorr);          // [PPM] correct the crystal frequencies
-  printf("Tuner crystal correction set to %d ppm\n", RxCrystalCorr);
-  if(RxGain>=0)
-  { SDR.setTunerGainManual(); SDR.setTunerGain(RxGain); printf("Tuner gain set to %3.1f dB (device reports %3.1f dB)\n", 0.1*RxGain, 0.1*SDR.getTunerGain() ); }
-  else
-  { SDR.setTunerGainAuto(); printf("Tuner gain set to automatic\n"); }  // automatic gain control
-
-  SDR.setOffsetTuning(RxOffsetTuning); if(RxOffsetTuning) printf("Offset tuning activated\n");
-
-  printf("\n");
-
-  SampleBuffer<uint8_t>                   Input;
-  SampleBuffer< std::complex<FloatType> > Spectra;
-  SampleBuffer<FloatType>                 Power;
-  std::vector<FloatType> PPM_Values;
-
-  FloatType BinWidth     = SampleRate/FFTsize;
-
-  int Freq=LowerFreq+GuardBand+FreqStep/2;
-  for(int Scan=0; Scan<Scans; Scan++, Freq+=FreqStep)
-  { SDR.setCenterFreq(Freq);
-    SDR.ResetBuffer();
-    int Samples=SDR.Read(Input, SamplesPerScan);                                    // acquire RF I/Q data
-    // printf("SDR.Read(, %5.3fMHz) => %d samples\n", 1e-6*Freq, Samples);
-    if(Samples<=0) { printf("SDR.Read(%5.1fMHz) failed\n", 1e-6*Freq); continue; }
-    SlidingFFT(Spectra, Input, FFT, Window);                                        // process with sliding FFT
-    SpectraPower(Power, Spectra);                                                   // we only want the amplitudes (power)
-#ifdef WRITE_SPECTROGRAM
-    char FileName[64]; sprintf(FileName, "gsm_scan_%7.3fMHz-%7.3fMHz.jpg", 1e-6*(Power.Freq-FreqStep/2), 1e-6*(Power.Freq+FreqStep/2));
-    MonoImage<FloatType> Spectrogram; Spectrogram.setExternal(Power.Data, FFTsize, Power.Samples() );
-    Spectrogram.WriteJPG_8bpp(FileName, 80, 0.33, 32.0, 32.0);                      // write spectrogram file
-#endif
-    // double EstPPM=0;
-    // EstimatePPM(EstPPM, Power);
-
-    FloatType FirstBinFreq = Freq-BinWidth*FFTsize2;          // [Hz] center frequency of the first FFT bin
-    FloatType LastBinFreq  = Freq+BinWidth*FFTsize2;          // [Hz] center frequency of the one-after-the-last FFT bin
-    int Chan = (int)ceil(FirstBinFreq/GSM_ChannelWidth);      // integer channel number corr. to the first FFT bin (GSM channels are on multiples of 200kHz)
-    for( ; ; Chan++)                                          // loop over (possible) channels in this scan
-    { FloatType CenterFreq=Chan*GSM_ChannelWidth; if(CenterFreq>=LastBinFreq) break; // center frequency of the channel
-      FloatType LowFreq = CenterFreq-0.45*GSM_ChannelWidth;    // [Hz] lower frequency to measure the channel
-      FloatType UppFreq = CenterFreq+0.45*GSM_ChannelWidth;    // [Hz] upper frequency to measure the channel
-      int LowBin=(int)floor((LowFreq-FirstBinFreq)/BinWidth+0.5); // FFT bins corresponding to the channel frequency range
-      int UppBin=(int)floor((UppFreq-FirstBinFreq)/BinWidth+0.5);
-      if( (LowBin<0) || (LowBin>=FFTsize) ) continue;          // skip this channel if range to measure
-      if( (UppBin<0) || (UppBin>=FFTsize) ) continue;          // not contained completely in this scan
-      FloatType AverPower; int Marks;
-      Marks=ProcessChan(PPM_Values, AverPower,                 // measure the channel, add measured points to PPM_Values
-                        LowBin, UppBin, (CenterFreq-FirstBinFreq)/BinWidth, BinWidth, CenterFreq,
-                        Power);
-      if(Marks==1) PPM_Values.pop_back();
-      if(Marks>1)
-      {  printf("%7.3fMHz: %+6.1fdB:",
-                1e-6*CenterFreq, 10*log10(AverPower/0.33));
-         for(size_t Mark=PPM_Values.size()-Marks; Mark<PPM_Values.size(); Mark++)
-           printf(" %+6.2f", PPM_Values[Mark]);
-         printf(" [ppm]\n");
-        // printf("%7.3fMHz %2d:[%4d-%4d] %+6.1fdB %d marks\n",
-        //         1e-6*CenterFreq, Scan, LowBin, UppBin, 10*log10(AverPower), Marks);
-      }
-    }
-  }
-
-  SDR.Close();
-
-  std::sort(PPM_Values.begin(), PPM_Values.end());
-  if(PPM_Values.size()>=16)
-  { FloatType Aver, RMS; int Margin=PPM_Values.size()/8;
-    AverRMS(Aver, RMS, PPM_Values.data()+Margin, PPM_Values.size()-2*Margin);
-    if(RMS>0.3)
-    { Margin=PPM_Values.size()/4; AverRMS(Aver, RMS, PPM_Values.data()+Margin, PPM_Values.size()-2*Margin); }
-    printf("Receiver Xtal correction = %d%+6.3f = %+7.3f (%5.3f) ppm [%d]\n", RxCrystalCorr, Aver, RxCrystalCorr+Aver, RMS, (int)PPM_Values.size()-2*Margin);
-    if(RMS>0.3)
-      printf("Warning: measurements appear inconsistent:\nplease retry with better initial estimate or with lower gain to reduce distortions\n");
-    printf("Note: when the receiver warms up the Xtal may drift 5-10ppm\n");
-  } else
-  { printf("Not enough data was collected: please retry with higher gain to catch more GSM signals\n"); }
-
-  return 0; }
-
-// ==================================================================================================================
diff --git a/hex/shader_1024k.hex b/hex/shader_1024k.hex
deleted file mode 100644
index bad96b5..0000000
--- a/hex/shader_1024k.hex
+++ /dev/null
@@ -1,948 +0,0 @@
-0x00000014, 0xe0021227, // mov rb_STAGES,  STAGES
-0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
-0x00000040, 0xe0021727, // mov rb_0x40,    0x40
-0x00000080, 0xe0021767, // mov rb_0x80,    0x80
-0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
-0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
-0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
-0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
-0x00ff00ff, 0xe0021027, // mov rx_0x00FF00FF, 0x00FF00FF
-0x0000ffff, 0xe00216a7, // mov rx_0x0000FFFF, 0x0000FFFF
-0x80904000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
-0x80905000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246e0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000002e8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x15727d80, 0x10020827, // mov r0, ra_vdw_32
-0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00040000, 0xe00208e7, // mov r3, PASS32_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x000005d8, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149c01c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149c01c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9db1c0, 0x10020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119db3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c91c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffd78, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149c01c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149c01c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9db1c0, 0x10020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119db3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c91c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc30, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb50, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00001258, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149c01c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149c01c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9db1c0, 0x10020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119db3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c91c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff998, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff970, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff9d0, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00007fff, 0xe0020827, // mov r0, 0x7FFF
-0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
-0xfffff9a0, 0xf01809e7, // brr.allnz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff710, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff4a0, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff480, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff460, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff440, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff1b0, 0xf00809e7, // brr.allz -, r:pass_3
-0x00000060, 0xe0020827, // mov r0, 3*4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000007, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000006, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xffffef40, 0xf0f80227, // brr ra_link_1, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xffffecb0, 0xf00809e7, // brr.allz -, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xffffed78, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_128k.hex b/hex/shader_128k.hex
deleted file mode 100644
index 6b82f92..0000000
--- a/hex/shader_128k.hex
+++ /dev/null
@@ -1,735 +0,0 @@
-0x00000011, 0xe0021227, // mov rb_STAGES,  STAGES
-0x00000010, 0xe00216a7, // mov rb_0x10,    0x10
-0x00000040, 0xe00216e7, // mov rb_0x40,    0x40
-0x00000080, 0xe0021727, // mov rb_0x80,    0x80
-0x000000f0, 0xe0021767, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217a7, // mov rb_0x100,   0x100
-0x00000fff, 0xe00217e7, // mov rb_0xFFF,   0xFFF
-0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
-0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
-0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
-0x00ff00ff, 0xe0021627, // mov rx_0x00FF00FF, 0x00FF00FF
-0x0000ffff, 0xe0021667, // mov rx_0x0000FFFF, 0x0000FFFF
-0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
-0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
-0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000b0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
-0xc000ffc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
-0x8c05bdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000000c8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc0007fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05bdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000560, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d81c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d81c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9da1c0, 0x10020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119da3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9cc1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffd78, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d81c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d81c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9da1c0, 0x10020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119da3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9cc1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc30, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x00000000, 0xf0f489e7, // bra -, ra_save_16
-0x009e7000, 0x100009e7, // nop
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000d00, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d81c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d81c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9da1c0, 0x10020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119da3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9cc1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa08, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff9e0, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffaf0, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x141dfdc0, 0x100229e7, // and.setf -, ra_points, rb_0xFFF
-0xfffffac8, 0xf01809e7, // brr.allnz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff938, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff778, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0xfffff758, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff5c8, 0xf00809e7, // brr.allz -, r:pass_3
-0x00000020, 0xe0020827, // mov r0, 4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff408, 0xf0f80227, // brr ra_link_1, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff278, 0xf00809e7, // brr.allz -, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff2d0, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_16k.hex b/hex/shader_16k.hex
deleted file mode 100644
index 160d783..0000000
--- a/hex/shader_16k.hex
+++ /dev/null
@@ -1,688 +0,0 @@
-0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
-0x00000040, 0xe0021727, // mov rb_0x40,    0x40
-0x00000080, 0xe0021767, // mov rb_0x80,    0x80
-0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
-0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
-0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
-0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
-0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
-0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000b0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
-0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
-0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000000c8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc0000fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x000005f0, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c11c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c11c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc80, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb10, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x00000000, 0xf0f489e7, // bra -, ra_save_16
-0x009e7000, 0x100009e7, // nop
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000b10, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c11c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff9a0, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1cedc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff978, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff988, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff968, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cedc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff6d8, 0xf00809e7, // brr.allz -, r:pass_2
-0x00000020, 0xe0020827, // mov r0, 4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff5f8, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cedc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff468, 0xf00809e7, // brr.allz -, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff4c0, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_1k.hex b/hex/shader_1k.hex
deleted file mode 100644
index 7de3279..0000000
--- a/hex/shader_1k.hex
+++ /dev/null
@@ -1,523 +0,0 @@
-0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
-0x00000040, 0xe0021727, // mov rb_0x40,    0x40
-0x000000f0, 0xe0021767, // mov rb_0xF0,    0xF0
-0x00005555, 0xe00207a7, // mov rx_0x5555,  0x5555
-0x00003333, 0xe00217a7, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00217e7, // mov rx_0x00FF,  0x00FF
-0x90104000, 0xe0020767, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202a7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212a7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x100246e0, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x10024720, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000c8, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15767d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x156e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000588, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c31c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c31c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc80, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x956c2ff6, 0x100246c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95707ff6, 0x10024707, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95741ff6, 0x10024741, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x956c2ff6, 0x100246c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95707ff6, 0x10024707, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95741ff6, 0x10024741, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x000007a0, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c31c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x0e1cadc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff9e8, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100202e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100212e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff9f8, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x95492dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024a7c80, 0x10020827, // fsub r0,  a, b
-0x024a7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024a7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014e7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025892, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024a7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204e7, // fadd a+1, r0, r1
-0x029d2ec0, 0x10020827, // fsub r0,  a, b
-0x029d21c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d2e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d33c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024892, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d2e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214e7, // fadd a+1, r0, r1
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x202e7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cb017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cb01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x212e709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02427c80, 0x10020827, // fsub r0,  a, b
-0x02427180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02427c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01467380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025890, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02427c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020467, // fadd a+1, r0, r1
-0x029d0ec0, 0x10020827, // fsub r0,  a, b
-0x029d01c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d0e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d13c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024890, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d0e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021467, // fadd a+1, r0, r1
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cadc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff768, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff830, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_2048k.hex b/hex/shader_2048k.hex
deleted file mode 100644
index c49cd94..0000000
--- a/hex/shader_2048k.hex
+++ /dev/null
@@ -1,1353 +0,0 @@
-0x00000010, 0xe0021227, // mov rb_0x10,    0x10
-0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
-0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000002e8, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x153a7d80, 0x10020827, // mov r0, ra_vdw_32
-0x8c04ddf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00080000, 0xe00208e7, // mov r3, PASS32_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000050, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000520, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x80904000, 0xe0020827, // mov r0, vdw_setup_0(1, 16, dma_h32(0,0))
-0x00000040, 0xe0020867, // mov r1, 0x40
-0x8c067c76, 0x10024061, // add ra_save_ptr, ra_save_ptr, r1; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00040000, 0xe00208e7, // mov r3, PASS64_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000002b8, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000e0, 0xf0f809e7, // brr -, r:2f
-0x00000010, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000c0, 0xf0f809e7, // brr -, r:2f
-0x00000011, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000a0, 0xf0f809e7, // brr -, r:2f
-0x00000012, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000080, 0xf0f809e7, // brr -, r:2f
-0x00000013, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000060, 0xf0f809e7, // brr -, r:2f
-0x00000014, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000040, 0xf0f809e7, // brr -, r:2f
-0x00000015, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000020, 0xf0f809e7, // brr -, r:2f
-0x00000016, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f809e7, // brr -, r:2f
-0x00000017, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000008, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000009, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000a, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000b, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000c, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000d, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000e, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000f, 0xe80009e7, // mov -, srel(i+8)
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000998, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffd50, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffbe0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
-0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
-0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
-0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
-0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffa30, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffff8c0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
-0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
-0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
-0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
-0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
-0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
-0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
-0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
-0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
-0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
-0x00000000, 0xf0f549e7, // bra -, ra_save_64
-0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
-0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
-0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
-0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff7e0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff790, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00001378, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c61c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff4f8, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000015, 0xe0020867, // mov r1, STAGES
-0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
-0xfffff4c8, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
-0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
-0x80904000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
-0x80905000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
-0x00000015, 0xe00212e7, // mov rb_STAGES, STAGES
-0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
-0x00000040, 0xe0021367, // mov rb_0x40, 0x40
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff8b0, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00007fff, 0xe0020827, // mov r0, 0x7FFF
-0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
-0xfffff880, 0xf01809e7, // brr.allnz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff5f0, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000007, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000006, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff380, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0xfffff360, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0xfffff340, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0xfffff320, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0x00000100, 0xe0020827, // mov r0, 0x100
-0xfffff088, 0xf00809e7, // brr.allz -, r:pass_3
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000060, 0xe0020827, // mov r0, (4-1)*4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000009, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000008, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xffffee18, 0xf0f80227, // brr ra_link_1, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xffffeb88, 0xf00809e7, // brr.allz -, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xffffec58, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_256.hex b/hex/shader_256.hex
deleted file mode 100644
index bfd5b45..0000000
--- a/hex/shader_256.hex
+++ /dev/null
@@ -1,359 +0,0 @@
-0x00000040, 0xe00217a7, // mov rb_0x40,    0x40
-0x00000080, 0xe00217e7, // mov rb_0x80,    0x80
-0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
-0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
-0x88104000, 0xe0020727, // mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
-0x88104800, 0xe0021727, // mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))
-0x15827d80, 0x10020227, // mov rx_tw_shared, unif
-0x15827d80, 0x10021227, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x100246e0, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100256e0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100049e0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100009e7, // add out_3, r0, r2
-0x000000b0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156e7d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x15727d80, 0x10021c67, // mov vw_setup, arg_vdw
-0xc0000040, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
-0x8c05edf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156e7d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x156e7d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000248, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x202a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ca039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208acb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x202a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x202e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cb039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208bcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x202e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20327030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cc039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ccb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20327031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f489e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0xfffffe98, 0xf0f809e7, // brr -, r:fft_16
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000600, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c227c00, 0x10020e27, // add t0s, ptr, r0
-0x0c227c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffd50, 0xf0f80027, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0xfffffd30, 0xf0f80027, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9c8e00, 0x10020e27, // add t0s, ptr, r0
-0x0c9c8e40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c227c00, 0x10020e27, // add t0s, ptr, r0
-0x0c227c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
-0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb50, 0xf0f80027, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02367c80, 0x10020827, // fsub r0,  a, b
-0x02367180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02367c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x013a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02367c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100203a7, // fadd a+1, r0, r1
-0x029cdec0, 0x10020827, // fsub r0,  a, b
-0x029cd1c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029cde40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029cde80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100213a7, // fadd a+1, r0, r1
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0xfffff9c8, 0xf0f80027, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0xfffff9d0, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_256k.hex b/hex/shader_256k.hex
deleted file mode 100644
index d51e651..0000000
--- a/hex/shader_256k.hex
+++ /dev/null
@@ -1,861 +0,0 @@
-0x00000012, 0xe0021227, // mov rb_STAGES,  STAGES
-0x00000010, 0xe00216a7, // mov rb_0x10,    0x10
-0x00000040, 0xe00216e7, // mov rb_0x40,    0x40
-0x00000080, 0xe0021727, // mov rb_0x80,    0x80
-0x000000f0, 0xe0021767, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217a7, // mov rb_0x100,   0x100
-0x00001fff, 0xe00217e7, // mov rb_0x1FFF,  0x1FFF
-0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
-0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
-0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
-0x00ff00ff, 0xe0021627, // mov rx_0x00FF00FF, 0x00FF00FF
-0x0000ffff, 0xe0021667, // mov rx_0x0000FFFF, 0x0000FFFF
-0x80904000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0( 1, 16, dma_h32( 0,0))
-0x80905000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0( 1, 16, dma_h32(32,0))
-0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000001d0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x156e7d80, 0x10020827, // mov r0, arg_vdw
-0x8c05bdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00020000, 0xe00208e7, // mov r3, PASS16_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000000c8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc000ffc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05bdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000640, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d81c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d81c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9da1c0, 0x10020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119da3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9cb1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffd78, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d81c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d81c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9da1c0, 0x10020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119da3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9cb1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc30, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x00000000, 0xf0f489e7, // bra -, ra_save_16
-0x009e7000, 0x100009e7, // nop
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb38, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffae8, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000ef0, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d81c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d81c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9da1c0, 0x10020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119da3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9cb1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff928, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff900, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x141dfdc0, 0x100229e7, // and.setf -, ra_points, rb_0x1FFF
-0xfffff9e8, 0xf01809e7, // brr.allnz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff858, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff698, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0xfffff678, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0xfffff658, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0xfffff638, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff4a8, 0xf00809e7, // brr.allz -, r:pass_3
-0x00000060, 0xe0020827, // mov r0, 3*4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff2a0, 0xf0f80227, // brr ra_link_1, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff010, 0xf00809e7, // brr.allz -, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff0e0, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_2k.hex b/hex/shader_2k.hex
deleted file mode 100644
index bd30abb..0000000
--- a/hex/shader_2k.hex
+++ /dev/null
@@ -1,765 +0,0 @@
-0x00000010, 0xe0021727, // mov rb_0x10,    0x10
-0x00000040, 0xe0021767, // mov rb_0x40,    0x40
-0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
-0x000001d0, 0xe00217e7, // mov rb_0x1D0,   0x1D0
-0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
-0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
-0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000c8, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15367d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc00001c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000000f8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0xa0104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(64, 16, dma_h32(0,0))
-0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(PASS64_STRIDE-16*4)
-0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, step; mov vw_addr, ra_save_ptr
-0x000002b8, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000e0, 0xf0f809e7, // brr -, r:2f
-0x00000010, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000c0, 0xf0f809e7, // brr -, r:2f
-0x00000011, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000a0, 0xf0f809e7, // brr -, r:2f
-0x00000012, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000080, 0xf0f809e7, // brr -, r:2f
-0x00000013, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000060, 0xf0f809e7, // brr -, r:2f
-0x00000014, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000040, 0xf0f809e7, // brr -, r:2f
-0x00000015, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000020, 0xf0f809e7, // brr -, r:2f
-0x00000016, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f809e7, // brr -, r:2f
-0x00000017, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000008, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000009, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000a, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000b, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000c, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000d, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000e, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000f, 0xe80009e7, // mov -, srel(i+8)
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000858, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc80, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
-0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
-0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
-0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffb20, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffa00, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
-0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
-0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
-0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
-0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
-0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
-0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
-0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
-0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
-0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
-0x00000000, 0xf0f549e7, // bra -, ra_save_64
-0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
-0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
-0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff920, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff8d0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x9534dff6, 0x1002434d, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000870, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c61c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff688, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x0e1cbdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff660, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
-0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
-0x90104000, 0xe0020367, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021367, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff920, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cbdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff690, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff760, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_32k.hex b/hex/shader_32k.hex
deleted file mode 100644
index 3b6fd77..0000000
--- a/hex/shader_32k.hex
+++ /dev/null
@@ -1,697 +0,0 @@
-0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
-0x00000040, 0xe0021727, // mov rb_0x40,    0x40
-0x00000080, 0xe0021767, // mov rb_0x80,    0x80
-0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
-0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
-0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
-0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202a7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212a7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246e0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000c8, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000588, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c21c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c21c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc80, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000d00, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c21c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1cfdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff9e8, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100202e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100212e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff9f8, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff9d8, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff9b8, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff998, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x95492dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024a7c80, 0x10020827, // fsub r0,  a, b
-0x024a7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024a7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014e7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025892, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024a7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204e7, // fadd a+1, r0, r1
-0x029d2ec0, 0x10020827, // fsub r0,  a, b
-0x029d21c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d2e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d33c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024892, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d2e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214e7, // fadd a+1, r0, r1
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x202e7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cb017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cb01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x212e709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02427c80, 0x10020827, // fsub r0,  a, b
-0x02427180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02427c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01467380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025890, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02427c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020467, // fadd a+1, r0, r1
-0x029d0ec0, 0x10020827, // fsub r0,  a, b
-0x029d01c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d0e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d13c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024890, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d0e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021467, // fadd a+1, r0, r1
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cfdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff708, 0xf00809e7, // brr.allz -, r:pass_2
-0x00000060, 0xe0020827, // mov r0, 3*4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100202e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100212e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff498, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x95492dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024a7c80, 0x10020827, // fsub r0,  a, b
-0x024a7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024a7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014e7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025892, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024a7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204e7, // fadd a+1, r0, r1
-0x029d2ec0, 0x10020827, // fsub r0,  a, b
-0x029d21c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d2e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d33c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024892, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d2e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214e7, // fadd a+1, r0, r1
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x202e7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cb017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cb01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x212e709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02427c80, 0x10020827, // fsub r0,  a, b
-0x02427180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02427c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01467380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025890, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02427c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020467, // fadd a+1, r0, r1
-0x029d0ec0, 0x10020827, // fsub r0,  a, b
-0x029d01c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d0e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d13c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024890, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d0e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021467, // fadd a+1, r0, r1
-0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cfdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff208, 0xf00809e7, // brr.allz -, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff2d0, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_4096k.hex b/hex/shader_4096k.hex
deleted file mode 100644
index f49df21..0000000
--- a/hex/shader_4096k.hex
+++ /dev/null
@@ -1,1523 +0,0 @@
-0x00000010, 0xe0021227, // mov rb_0x10,    0x10
-0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
-0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000002e8, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x153a7d80, 0x10020827, // mov r0, ra_vdw_32
-0x8c04ddf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00100000, 0xe00208e7, // mov r3, PASS32_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000050, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000520, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x80904000, 0xe0020827, // mov r0, vdw_setup_0(1, 16, dma_h32(0,0))
-0x00000040, 0xe0020867, // mov r1, 0x40
-0x8c067c76, 0x10024061, // add ra_save_ptr, ra_save_ptr, r1; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00080000, 0xe00208e7, // mov r3, PASS64_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000002b8, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000e0, 0xf0f809e7, // brr -, r:2f
-0x00000010, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000c0, 0xf0f809e7, // brr -, r:2f
-0x00000011, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000a0, 0xf0f809e7, // brr -, r:2f
-0x00000012, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000080, 0xf0f809e7, // brr -, r:2f
-0x00000013, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000060, 0xf0f809e7, // brr -, r:2f
-0x00000014, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000040, 0xf0f809e7, // brr -, r:2f
-0x00000015, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000020, 0xf0f809e7, // brr -, r:2f
-0x00000016, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f809e7, // brr -, r:2f
-0x00000017, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000008, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000009, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000a, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000b, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000c, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000d, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000e, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000f, 0xe80009e7, // mov -, srel(i+8)
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000ba8, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffd50, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffbe0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
-0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
-0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
-0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
-0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffa30, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffff8c0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
-0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
-0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
-0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
-0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
-0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
-0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
-0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
-0x2225b19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
-0x206e701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
-0x00000000, 0xf0f549e7, // bra -, ra_save_64
-0x209db017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
-0x216c97d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
-0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff7e0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff790, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
-0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
-0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
-0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
-0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff700, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff6b0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
-0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
-0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
-0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
-0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
-0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
-0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
-0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
-0x2225b19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
-0x206e701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
-0x00000000, 0xf0f549e7, // bra -, ra_save_64
-0x209db017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
-0x216c97d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
-0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
-0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff5d0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff580, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x000016b8, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100206e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100216e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c61c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x55555555, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x33333333, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0f0f0f0f, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x00ff00ff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0000ffff, 0xe00208a7, // mov r2, mask
-0x149e7080, 0x10020867, // and r1, r0, r2
-0x0e9c81c0, 0x10020827, // shr r0, r0, shift
-0x149e7080, 0x10020827, // and r0, r0, r2
-0x119c83c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff2e8, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000016, 0xe0020867, // mov r1, STAGES
-0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
-0xfffff2b8, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100206e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100216e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe002469a, // mov ra_tw_re+TW48+1, 0; mov rb_tw_im+TW48+1, 0
-0x00000000, 0xe002471c, // mov ra_tw_re+TW64+1, 0; mov rb_tw_im+TW64+1, 0
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000007, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000006, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020767, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021767, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100207a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100217a7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c61c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff568, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x0000ffff, 0xe0020827, // mov r0, 0xFFFF
-0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
-0xfffff538, 0xf01809e7, // brr.allnz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
-0x956dbdbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x207a7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209de017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209de01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x217a709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x026e7c80, 0x10020827, // fsub r0,  a, b
-0x026e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x026e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01727380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002589b, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x026e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020727, // fadd a+1, r0, r1
-0x029dbec0, 0x10020827, // fsub r0,  a, b
-0x029db1c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029dbe40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019dc3c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002489b, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029dbe80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021727, // fadd a+1, r0, r1
-0x95659dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20767016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209dd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209dd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2176709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02667c80, 0x10020827, // fsub r0,  a, b
-0x02667180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02667c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x016a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025899, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02667c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100206a7, // fadd a+1, r0, r1
-0x029d9ec0, 0x10020827, // fsub r0,  a, b
-0x029d91c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d9e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019da3c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024899, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d9e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100216a7, // fadd a+1, r0, r1
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x00000016, 0xe0020867, // mov r1, STAGES
-0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
-0xfffff0a0, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
-0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
-0x80904000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
-0x80905000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
-0x00000016, 0xe00212e7, // mov rb_STAGES, STAGES
-0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
-0x00000040, 0xe0021367, // mov rb_0x40, 0x40
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000009, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000008, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff008, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x000003ff, 0xe0020827, // mov r0, 0x3FF
-0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
-0xffffefd8, 0xf01809e7, // brr.allnz -, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xffffed48, 0xf00809e7, // brr.allz -, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x0000000b, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x0000000a, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xffffead8, 0xf0f80227, // brr ra_link_1, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xffffe848, 0xf00809e7, // brr.allz -, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xffffe918, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_4k.hex b/hex/shader_4k.hex
deleted file mode 100644
index c37e50d..0000000
--- a/hex/shader_4k.hex
+++ /dev/null
@@ -1,514 +0,0 @@
-0x00000020, 0xe0021767, // mov rb_0x20,    0x20
-0x00000040, 0xe00217a7, // mov rb_0x40,    0x40
-0x00000080, 0xe00217e7, // mov rb_0x80,    0x80
-0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
-0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
-0x88104000, 0xe00206e7, // mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
-0x88104800, 0xe00216e7, // mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))
-0x15827d80, 0x10020227, // mov rx_tw_shared, unif
-0x15827d80, 0x10021227, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100256a0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100049e0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100009e7, // add out_3, r0, r2
-0x000000b0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
-0xc00007c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
-0x8c05edf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x156a7d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x000003e8, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f409e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x202a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ca039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208acb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x202a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x202e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cb039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208bcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x202e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20327030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cc039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ccb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20327031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f489e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c11c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
-0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
-0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
-0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
-0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
-0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
-0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
-0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
-0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
-0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
-0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
-0xfffffd40, 0xf0f809e7, // brr -, r:fft_16
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffcf8, 0xf0f809e7, // brr -, r:fft_16
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000928, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c227c00, 0x10020e27, // add t0s, ptr, r0
-0x0c227c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c11c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
-0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
-0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
-0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
-0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
-0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffbe0, 0xf0f80027, // brr ra_link_1, r:pass_1
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffffbb8, 0xf00809e7, // brr.allz -, r:pass_1
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c227c00, 0x10020e27, // add t0s, ptr, r0
-0x0c227c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c227c00, 0x10020e27, // add t0s, ptr, r0
-0x0c227c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
-0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb78, 0xf0f80027, // brr ra_link_1, r:pass_2
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0xfffffb58, 0xf0f80027, // brr ra_link_1, r:pass_2
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x0d01ddc0, 0x10020027, // sub ra_link_1, ra_link_1, rb_0x20
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02367c80, 0x10020827, // fsub r0,  a, b
-0x02367180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02367c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x013a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02367c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100203a7, // fadd a+1, r0, r1
-0x029cdec0, 0x10020827, // fsub r0,  a, b
-0x029cd1c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029cde40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029cde80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100213a7, // fadd a+1, r0, r1
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff9c0, 0xf00809e7, // brr.allz -, r:pass_2
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9c8e00, 0x10020e27, // add t0s, ptr, r0
-0x0c9c8e40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c227c00, 0x10020e27, // add t0s, ptr, r0
-0x0c227c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
-0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff808, 0xf0f80027, // brr ra_link_1, r:pass_3
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02367c80, 0x10020827, // fsub r0,  a, b
-0x02367180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02367c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x013a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02367c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100203a7, // fadd a+1, r0, r1
-0x029cdec0, 0x10020827, // fsub r0,  a, b
-0x029cd1c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029cde40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029cde80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100213a7, // fadd a+1, r0, r1
-0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff678, 0xf00809e7, // brr.allz -, r:pass_3
-0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
-0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff6a8, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_512.hex b/hex/shader_512.hex
deleted file mode 100644
index 505ab41..0000000
--- a/hex/shader_512.hex
+++ /dev/null
@@ -1,494 +0,0 @@
-0x00000010, 0xe0021727, // mov rb_0x10,    0x10
-0x00000040, 0xe0021767, // mov rb_0x40,    0x40
-0x00000080, 0xe00217a7, // mov rb_0x80,    0x80
-0x000000f0, 0xe00217e7, // mov rb_0xF0,    0xF0
-0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
-0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
-0x88104000, 0xe00206a7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
-0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
-0x90104000, 0xe00206e7, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10024620, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x10024660, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000b0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15627d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x156a7d80, 0x10021c67, // mov vw_setup, arg_vdw
-0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
-0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15627d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15627d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000000c8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15627d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x156e7d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc0000040, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15627d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15627d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000510, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc80, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95602ff6, 0x10024602, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95647ff6, 0x10024647, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x956c1ff6, 0x100246c1, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x00000000, 0xf0f489e7, // bra -, ra_save_16
-0x009e7000, 0x100009e7, // nop
-0x95602ff6, 0x10024602, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95680ff6, 0x10024680, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x000005e8, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14727180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14727180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa80, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0xfffffa60, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb20, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c9dc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff990, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff9e8, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_512k.hex b/hex/shader_512k.hex
deleted file mode 100644
index ebc84d8..0000000
--- a/hex/shader_512k.hex
+++ /dev/null
@@ -1,983 +0,0 @@
-0x00000013, 0xe0021227, // mov rb_STAGES,  STAGES
-0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
-0x00000040, 0xe0021727, // mov rb_0x40,    0x40
-0x00000080, 0xe0021767, // mov rb_0x80,    0x80
-0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
-0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
-0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
-0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
-0x00ff00ff, 0xe0021667, // mov rx_0x00FF00FF, 0x00FF00FF
-0x0000ffff, 0xe00216a7, // mov rx_0x0000FFFF, 0x0000FFFF
-0x80904000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(1, 16, dma_h32( 0,0))
-0x80905000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(1, 16, dma_h32(32,0))
-0x80904000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
-0x80905000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000001d0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x156e7d80, 0x10020827, // mov r0, arg_vdw
-0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00040000, 0xe00208e7, // mov r3, PASS16_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000002e8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x15727d80, 0x10020827, // mov r0, ra_vdw_32
-0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
-0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
-0x00020000, 0xe00208e7, // mov r3, PASS32_STRIDE
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
-0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000640, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9db1c0, 0x10020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119db3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffd78, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9db1c0, 0x10020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119db3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc30, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffba0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x00000000, 0xf0f489e7, // bra -, ra_save_16
-0x009e7000, 0x100009e7, // nop
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb38, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffae8, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x000010a8, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149d91c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149d91c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9db1c0, 0x10020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119db3c0, 0x10020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff928, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff900, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00003fff, 0xe0020827, // mov r0, 0x3FFF
-0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
-0xfffff9e0, 0xf01809e7, // brr.allnz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff850, 0xf00809e7, // brr.allz -, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff648, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff628, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff608, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0xfffff5e8, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff358, 0xf00809e7, // brr.allz -, r:pass_3
-0x00000060, 0xe0020827, // mov r0, 3*4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000006, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff0e8, 0xf0f80227, // brr ra_link_1, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x024e7c80, 0x10020827, // fsub r0,  a, b
-0x024e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x024e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01527380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x024e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020527, // fadd a+1, r0, r1
-0x029d3ec0, 0x10020827, // fsub r0,  a, b
-0x029d31c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d3e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d43c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d3e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021527, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xffffee58, 0xf00809e7, // brr.allz -, r:pass_4
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xffffef28, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_64k.hex b/hex/shader_64k.hex
deleted file mode 100644
index 5daa0a5..0000000
--- a/hex/shader_64k.hex
+++ /dev/null
@@ -1,940 +0,0 @@
-0x00000010, 0xe0021227, // mov rb_0x10,    0x10
-0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
-0x00005555, 0xe00207a7, // mov rx_0x5555,  0x5555
-0x00003333, 0xe00217a7, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00217e7, // mov rx_0x00FF,  0x00FF
-0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000c8, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x153a7d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc0003fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c04ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000100, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000040, 0xe0020827, // mov r0, 0x40
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0xa0104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(64, 16, dma_h32(0,0))
-0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(PASS64_STRIDE-16*4)
-0x8c067c36, 0x10024072, // add ra_save_ptr, ra_save_ptr, step; mov vw_addr, ra_save_ptr
-0x000002b8, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000e0, 0xf0f809e7, // brr -, r:2f
-0x00000010, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000c0, 0xf0f809e7, // brr -, r:2f
-0x00000011, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x000000a0, 0xf0f809e7, // brr -, r:2f
-0x00000012, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000080, 0xf0f809e7, // brr -, r:2f
-0x00000013, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000060, 0xf0f809e7, // brr -, r:2f
-0x00000014, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000040, 0xf0f809e7, // brr -, r:2f
-0x00000015, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000020, 0xf0f809e7, // brr -, r:2f
-0x00000016, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f809e7, // brr -, r:2f
-0x00000017, 0xe80009e7, // mov -, sacq(i)
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
-0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
-0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
-0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
-0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
-0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
-0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
-0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
-0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
-0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
-0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
-0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
-0x00000000, 0xf0fc49e7, // brr -, ra_temp
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000008, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000009, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000a, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000b, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000c, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000d, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000e, 0xe80009e7, // mov -, srel(i+8)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x0000000f, 0xe80009e7, // mov -, srel(i+8)
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000858, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda0, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc80, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
-0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
-0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
-0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
-0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffb20, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffa00, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
-0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
-0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
-0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
-0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
-0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
-0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
-0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
-0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
-0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
-0x00000000, 0xf0f549e7, // bra -, ra_save_64
-0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
-0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
-0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
-0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff920, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff8d0, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f489e7, // bra -, ra_save_32
-0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000df0, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c61c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149de1c0, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x149de1c0, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149df1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149df1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff688, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000010, 0xe0020867, // mov r1, STAGES
-0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
-0xfffff658, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x00000200, 0xe0020827, // mov r0, 0x200
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
-0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
-0x90104000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x00000060, 0xe00212e7, // mov rb_3x4x8, 3*4*8
-0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
-0x00000040, 0xe0021367, // mov rb_0x40, 0x40
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000005, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000004, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff900, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0xfffff8e0, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0xfffff8c0, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0xfffff8a0, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff610, 0xf00809e7, // brr.allz -, r:pass_2
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x0d20bdc0, 0x10020227, // sub ra_link_1, ra_link_1, rb_3x4x8
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000007, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000006, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff3a0, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x025e7c80, 0x10020827, // fsub r0,  a, b
-0x025e7180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x025e7c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x01627380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x025e7c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10020627, // fadd a+1, r0, r1
-0x029d7ec0, 0x10020827, // fsub r0,  a, b
-0x029d71c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d7e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d83c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d7e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x10021627, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02567c80, 0x10020827, // fsub r0,  a, b
-0x02567180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02567c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x015a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02567c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100205a7, // fadd a+1, r0, r1
-0x029d5ec0, 0x10020827, // fsub r0,  a, b
-0x029d51c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d5e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d63c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d5e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100215a7, // fadd a+1, r0, r1
-0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
-0xfffff110, 0xf00809e7, // brr.allz -, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x00000100, 0xe0020827, // mov r0, 0x100
-0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff1e0, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_8k.hex b/hex/shader_8k.hex
deleted file mode 100644
index 7e1f112..0000000
--- a/hex/shader_8k.hex
+++ /dev/null
@@ -1,603 +0,0 @@
-0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
-0x00000040, 0xe0021727, // mov rb_0x40,    0x40
-0x00000080, 0xe0021767, // mov rb_0x80,    0x80
-0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
-0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
-0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
-0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
-0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
-0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
-0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
-0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
-0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
-0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
-0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
-0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
-0x15827d80, 0x10021167, // mov rb_inst, unif
-0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
-0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
-0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
-0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
-0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
-0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
-0x0c9e7080, 0x100211e7, // add out_3, r0, r2
-0x000000b0, 0xf0f80127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
-0xc0000fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
-0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000038, 0xf0f81127, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, arg
-0x159e7000, 0x10020c27, // mov vpm, r0
-0x159e7240, 0x10020c27, // mov vpm, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x000000c8, 0xf0f802a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
-0xc00007c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
-0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
-0x00000050, 0xf0f812a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
-0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
-0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
-0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
-0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
-0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
-0x00000000, 0xf0f4c9e7, // bra -, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
-0x15c27d80, 0x100009e7, // mov -, vpm
-0x00000080, 0xf0f801a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x00000019, 0xe80009e7, // mov -, sacq(i+9)
-0x00000001, 0xe80009e7, // mov -, srel(i+1)
-0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
-0x00000002, 0xe80009e7, // mov -, srel(i+1)
-0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
-0x00000003, 0xe80009e7, // mov -, srel(i+1)
-0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
-0x00000004, 0xe80009e7, // mov -, srel(i+1)
-0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
-0x00000005, 0xe80009e7, // mov -, srel(i+1)
-0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000006, 0xe80009e7, // mov -, srel(i+1)
-0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
-0x00000007, 0xe80009e7, // mov -, srel(i+1)
-0x00000500, 0xf0f811a7, // brr rx_ptr, label
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x00000009, 0xe80009e7, // mov -, srel(i+9)
-0x00000011, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000a, 0xe80009e7, // mov -, srel(i+9)
-0x00000012, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000b, 0xe80009e7, // mov -, srel(i+9)
-0x00000013, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000c, 0xe80009e7, // mov -, srel(i+9)
-0x00000014, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000d, 0xe80009e7, // mov -, srel(i+9)
-0x00000015, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000e, 0xe80009e7, // mov -, srel(i+9)
-0x00000016, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x00000000, 0xf0f509e7, // bra -, ra_link_1
-0x0000000f, 0xe80009e7, // mov -, srel(i+9)
-0x00000017, 0xe80009e7, // mov -, sacq(i+1)
-0x009e7000, 0x100009e7, // nop
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
-0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
-0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
-0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
-0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
-0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
-0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
-0x00000000, 0xf0f409e7, // bra -, ra_link_0
-0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
-0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
-0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
-0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffda8, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0xfffffc90, 0xf0f80027, // brr ra_link_0, call
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
-0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
-0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
-0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
-0x019e72c0, 0x10020867, // fadd r1, r1,      r3
-0x00000000, 0xf0f549e7, // bra -, ra_save_32
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
-0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffc00, 0xf0f80027, // brr ra_link_0, call
-0x009e7000, 0xa00009e7, // nop;        ldtmu0
-0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
-0x159e7900, 0x10020867, // mov r1, r4
-0x00000000, 0xf0f489e7, // bra -, ra_save_16
-0x009e7000, 0x100009e7, // nop
-0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
-0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
-0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
-0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
-0x119c51c0, 0xd0020827, // shl r0, r0, 5
-0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
-0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
-0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
-0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
-0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
-0x00000958, 0xf00809e7, // brr.allz -, r:end
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c51c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x14767180, 0x10020867, // and r1, r0, mask
-0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
-0x14767180, 0x10020827, // and r0, r0, mask
-0x119c13c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147a7180, 0x10020867, // and r1, r0, mask
-0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
-0x147a7180, 0x10020827, // and r0, r0, mask
-0x119c23c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x147e7180, 0x10020867, // and r1, r0, mask
-0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
-0x147e7180, 0x10020827, // and r0, r0, mask
-0x119c43c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x149da1c0, 0x10020867, // and r1, r0, mask
-0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
-0x149da1c0, 0x10020827, // and r0, r0, mask
-0x119c83c0, 0xd0020867, // shl r1, r1, shift
-0x159e7040, 0x10020827, // or  r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
-0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
-0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffa98, 0xf0f80227, // brr ra_link_1, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffffa70, 0xf00809e7, // brr.allz -, r:pass_1
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000001, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000002, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffffb20, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0xfffffb00, 0xf0f80227, // brr ra_link_1, r:pass_2
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff970, 0xf00809e7, // brr.allz -, r:pass_2
-0x00000020, 0xe0020827, // mov r0, 4*8
-0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000000, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
-0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
-0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
-0x00000003, 0xe0020867, // mov r1, src
-0x119c73c0, 0xd0020867, // shl r1, r1, 7
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
-0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
-0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
-0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x159c5fc0, 0x10020827, // mov r0, rb_inst
-0x119c41c0, 0xd0020827, // shl r0, r0, m
-0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
-0x00000000, 0xe00201e7, // mov ra_points, 0
-0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
-0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
-0x119c31c0, 0xd0020827, // shl r0, r0, 3
-0x0c9c41c0, 0xd0020867, // add r1, r0, 4
-0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
-0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
-0xfffff7b0, 0xf0f80227, // brr ra_link_1, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
-0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
-0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
-0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
-0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
-0x029e7640, 0x100208e7, // fsub r3, r3, r1
-0x02467c80, 0x10020827, // fsub r0,  a, b
-0x02467180, 0x10020867, // fsub r1, r0, a
-0x019e7280, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x02467c40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x014a7380, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x02467c80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100204a7, // fadd a+1, r0, r1
-0x029d1ec0, 0x10020827, // fsub r0,  a, b
-0x029d11c0, 0x10020867, // fsub r1, r0, a
-0x019e72c0, 0x100208a7, // fadd r2, r1, b
-0x029e7040, 0x10020867, // fsub r1, r0, r1
-0x029d1e40, 0x10020867, // fsub r1,  a, r1
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x019d23c0, 0x10020867, // fadd r1, r1, a+1
-0x019e7040, 0x100208a7, // fadd r2, r0, r1
-0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
-0x029e7280, 0x10020867, // fsub r1, r1, r2
-0x029d1e80, 0x100208a7, // fsub r2,  a, r2
-0x029e7080, 0x10020827, // fsub r0, r0, r2
-0x019e7040, 0x100214a7, // fadd a+1, r0, r1
-0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
-0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
-0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
-0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
-0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
-0xfffff620, 0xf00809e7, // brr.allz -, r:pass_3
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
-0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0xa00009e7, // ldtmu0
-0x009e7000, 0xa00009e7, // ldtmu0
-0xfffff678, 0xf0f809e7, // brr -, r:loop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x159c3fc0, 0x100209a7, // mov interrupt, flag
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/hex/shader_trans.hex b/hex/shader_trans.hex
deleted file mode 100644
index 93af75e..0000000
--- a/hex/shader_trans.hex
+++ /dev/null
@@ -1,126 +0,0 @@
-0x15827d80, 0x10020e27, // mov t0s, unif
-0x009e7000, 0xa00009e7, // ldtmu0
-0x0c9cc9c0, 0xd0020e27, // add t0s, r4, 3*4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x0c827980, 0x100200a7, // add ra_src_base, r4, unif
-0x15827d80, 0x10020e27, // mov t0s, unif
-0x009e7000, 0xa00009e7, // ldtmu0
-0x0c9cc9c0, 0xd0020e27, // add t0s, r4, 3*4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x0c827980, 0x100200e7, // add ra_dst_base, r4, unif
-0x15827d80, 0x100214a7, // mov rb_Y_STRIDE_SRC, unif
-0x15827d80, 0x100214e7, // mov rb_Y_STRIDE_DST, unif
-0x15827d80, 0x10021527, // mov rb_NX,           unif
-0x15827d80, 0x10021567, // mov rb_NY,           unif
-0x00000008, 0xe0021467, // mov rb_X_STRIDE, 2*4
-0x00000010, 0xe0021427, // mov rb_0x10, 0x10
-0xc0000000, 0xe0020827, // mov r0, vdw_setup_1(0)
-0x0c9d31c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_DST
-0x00000040, 0xe0020867, // mov r1, 16*4
-0x0d9e7040, 0x100201a7, // sub ra_vdw_stride, r0, r1
-0x40991037, 0x100049e0, // nop; mul24 r0, elem_num, rb_X_STRIDE
-0x159e7000, 0x10021027, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd0021227, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x10021067, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd0021267, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x100210a7, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd00212a7, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x100210e7, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd00212e7, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x10021127, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd0021327, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x10021167, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd0021367, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x100211a7, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd00213a7, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x159e7000, 0x100211e7, // mov rb_offsets_re+i, r0
-0x0c9c41c0, 0xd00213e7, // add rb_offsets_im+i, r0, 4
-0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
-0x00000000, 0xe0020067, // mov ra_y, 0
-0x00000000, 0xe0020027, // mov ra_x, 0
-0x40052037, 0x100049e1, // nop; mul24 r1, ra_y, rb_Y_STRIDE_SRC
-0x40011037, 0x100049e0, // nop; mul24 r0, ra_x, rb_X_STRIDE
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c0a7c00, 0x10020127, // add ra_src_cell, ra_src_base, r0
-0x40013037, 0x100049e1, // nop; mul24 r1, ra_x, rb_Y_STRIDE_DST
-0x40051037, 0x100049e0, // nop; mul24 r0, ra_y, rb_X_STRIDE
-0x0c9e7040, 0x10020827, // add r0, r0, r1
-0x0c0e7c00, 0x10020167, // add ra_dst_cell, ra_dst_base, r0
-0x00001200, 0xe0021c67, // mov vw_setup, vpm_setup(16, 1, v32(0,0))
-0x0c100dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re
-0x0c108dc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im
-0x0c101dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c109dc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x0c102dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c10adc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x0c103dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c10bdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x0c104dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c10cdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x0c105dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c10ddc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x0c106dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c10edc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x0c107dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
-0x0c10fdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xa00009e7, // ldtmu0
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x009e7000, 0xb00009e7, // ldtmu1
-0x159e7900, 0x10020c27, // mov vpm, r4
-0x88104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(16, 16, dma_h32(0,0))
-0x151a7d80, 0x10021c67, // mov vw_setup, ra_vdw_stride
-0x15167d80, 0x10021ca7, // mov vw_addr, ra_dst_cell
-0x159f2fc0, 0x100009e7, // mov -, vw_wait
-0x0c010dc0, 0x10020027, // add ra_x, ra_x, rb_0x10
-0x009e7000, 0x100009e7, // nop
-0x0d014dc0, 0x100229e7, // sub.setf -, ra_x, rb_NX
-0xfffffde0, 0xf01809e7, // brr.allnz -, r:inner
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x0c048dc0, 0xd0020067, // add ra_y, ra_y, 8
-0x009e7000, 0x100009e7, // nop
-0x0d055dc0, 0x100229e7, // sub.setf -, ra_y, rb_NY
-0xfffffda0, 0xf01809e7, // brr.allnz -, r:outer
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
-0x00000001, 0xe00209a7, // mov interrupt, 1
-0x009e7000, 0x300009e7, // nop; nop; thrend
-0x009e7000, 0x100009e7, // nop
-0x009e7000, 0x100009e7, // nop
diff --git a/image.h b/image.h
deleted file mode 100644
index b44b71f..0000000
--- a/image.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __IMAGE_H__
-#define __IMAGE_H__
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-// #include <png.h>
-#include <jpeglib.h>
-#include <setjmp.h>
-
-// =============================================================================
-
-template <class Type=float>
- class MonoImage
-{ public:
-   Type   *Data;        // pointer to image storage
-   int     Size;        // actuall (needed) storage size
-   int     Allocated;   // allocated storage (when 0 => storage is empty or outside of this object)
-
-   int     Width;       // number of columns
-   int     Height;      // number of rows
-
-   MonoImage()
-     { Data=0; Width=0; Height=0; Size=0; Allocated=0; }
-
-   MonoImage(int NewWidth, int NewHeight) { New(NewWidth, NewHeight); }
-
-  ~MonoImage()
-     { if(Allocated) free(Data); }
-
-   void Free(void)
-     { if(Allocated) free(Data);
-       Data=0; Size=0; Allocated=0; }
-
-   int Reallocate(int NewSize)
-     { // printf("PixelImage::Reallocate(%d) ...\n", NewSize);
-       if(Allocated&&(NewSize==Size)) return Size;
-       Data=(Type *)realloc(Data, NewSize*sizeof(Type)); if(Data==0) { Allocated=0; Size=0; return 0; }
-       Allocated=NewSize; return NewSize; }
-
-   int New(int NewWidth, int NewHeight)
-     { // printf("MonoImage::New(%dx%d) ...\n", NewWidth, NewHeight);
-       int NewSize=NewWidth*NewHeight;
-       if(Allocated<NewSize) Reallocate(NewSize);
-       if(Allocated<NewSize) { Width=0; Height=0; Size=0; return 0; }
-       Width=NewWidth; Height=NewHeight; Size=NewSize;
-       // printf(" Size=%d, Allocated=%d\n", Size, Allocated);
-       return Size; }
-
-   template <class NewType>
-    int New(MonoImage<NewType> &Ref)
-     { return New(Ref.Width, Ref.Height); }
-
-   int NewBlank(int NewWidth, int NewHeight)
-      { if(New(NewWidth, NewHeight)<=0) return 0;
-        Blank(0); return Size; }
-
-   int setExternal(Type *ExtImage, int ExtWidth, int ExtHeight)
-     { if(Allocated) { free(Data); Allocated=0; }
-       Data=ExtImage; Width=ExtWidth; Height=ExtHeight;
-       return Size=Width*Height; }
-
-// -----------------------------------------------------------------------------
-
-   bool  isPixel(int X, int Y) const         { return (X>=0) && (X<Width) && (Y>=0) && (Y<=Height); }
-   void setPixel(int X, int Y, Type Value)   { Data[Y*Width+X]=Value; }
-   Type getPixel(int X, int Y) const         { return Data[Y*Width+X]; }
-   Type incPixel(int X, int Y, Type Value=1) { return Data[Y*Width+X]+=Value; }
-
-// -----------------------------------------------------------------------------
-
-   template <class ExtType>
-    int Copy(ExtType *ExtData, int ExtWidth, int ExtHeight, ExtType Scale=1)
-   { if(New(ExtWidth, ExtHeight)<=0) return 0;
-     Type *ImgData = Data;
-     for(int Row=0; Row<Height; Row++)
-     { for(int Col=0; Col<Width; Col++)
-       { (*ImgData++) = Scale*(*ExtData++); }
-     }
-     return Size; }
-
-   template <class ExtType>
-    int Copy(MonoImage<ExtType> &ExtImage, ExtType Scale=1)
-   { return Copy(ExtImage.Data, ExtImage.Width, ExtImage.Height, Scale); }
-
-   template <class ExtType>
-    int Add(ExtType *ExtData, int ExtWidth, int ExtHeight, ExtType Weight=1)
-   { if(Size==0) { if(NewBlank(ExtWidth, ExtHeight)<=0) return 0; }
-     if( (Width!=ExtWidth) || (Height!=ExtHeight) ) return 0;
-     Type *ImgData = Data;
-     for(int Row=0; Row<Height; Row++)
-     { for(int Col=0; Col<Width; Col++)
-       { (*ImgData++) += Weight*(*ExtData++); }
-     }
-     return Size; }
-
-   template <class ExtType>
-    int Add(MonoImage<ExtType> &ExtImage, ExtType Weight=1)
-   { return Add(ExtImage.Data, ExtImage.Width, ExtImage.Height, Weight); }
-
-   template <class ExtType>
-    int CopyBox(ExtType *ExtData, int ExtWidth, int ExtHeight, int FirstCol, int FirstRow, int Cols, int Rows, ExtType Scale=1)
-   { if(New(Cols, Rows)<=0) return 0;
-     Type *ImgData = Data;
-     for(int Row=0; Row<Height; Row++)
-     { int ExtRow = FirstRow+Row;
-       if( (ExtRow<0) || (ExtRow>=ExtHeight) )
-       { for(int Col=0; Col<Width; Col++) (*ImgData++)=0; continue; }
-       ExtType *ExtRowData = ExtData + (ExtRow*ExtWidth);
-       int ExtCol = FirstCol;
-       for( int Col=0; Col<Width; Col++, ExtCol++)
-         { ExtType Data=0;
-           if((ExtCol>=0) && (ExtCol<ExtWidth))
-             Data=ExtRowData[ExtCol];
-           (*ImgData++)=Scale*Data; }
-     }
-     return Size; }
-
-   template <class ExtType>
-    int CopyBox(MonoImage<ExtType> &ExtImage, int FirstCol, int FirstRow, int Cols, int Rows, ExtType Scale=1)
-   { return CopyBox(ExtImage.Data, ExtImage.Width, ExtImage.Height, FirstCol, FirstRow, Cols, Rows, Scale); }
-
-   void Blank(Type Level=0)
-      { if(Data==0) return;
-        Type *Image=Data; int Count=Size; for( ; Count; Count--) (*Image++)=Level; }
-
-// -----------------------------------------------------------------------------
-
-   int WritePGM_8bpp(const char *FileName, Type LogRef=0, Type Scale=1, Type Bias=0) const
-     { FILE *File=fopen(FileName,"wb"); if(File==0) return -1;
-       fprintf(File,"P5\n%d %d 255\n", Width, Height);
-       uint8_t Line[Width];
-       Type *Img = Data;
-       for(int Row=0; Row<Height; Row++)
-       { for(int Col=0; Col<Width; Col++)
-         { Type Pixel=(*Img++);
-           if(LogRef)
-           { if(Pixel) { Pixel=logf((float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
-             else Pixel=0; }
-           else
-           { Pixel = Pixel*Scale + Bias; }
-           if(Pixel<0x00) Pixel=0x00;
-           else if(Pixel>0xFF) Pixel=0xFF;
-           Line[Col]=(uint8_t)Pixel; }
-         if(fwrite(Line, Width, 1, File)!=1) { fclose(File); return -1; }
-       }
-       fclose(File);
-       return Width*Height; }
-/*
-   int WritePNG_8bpp(const char *FileName, Type LogRef=0, Type Scale=1, Type Bias=0) const
-     { FILE *File=fopen(FileName, "wb"); if(File==0) return -1;
-
-       png_structp Struct;
-       png_infop   Info;
-       Struct = png_create_write_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);
-       if(Struct==0) { fclose(File); return -1; }
-       Info = png_create_info_struct(Struct);
-       if(Info==0) { png_destroy_write_struct(&Struct, (png_infopp)0); fclose(File); return -1; }
-       if(setjmp(png_jmpbuf(Struct))) { png_destroy_write_struct(&Struct, (png_infopp)0); fclose(File); return -1; }
-       png_set_IHDR(Struct, Info, Width, Height,
-                    8, PNG_COLOR_TYPE_GRAY, PNG_INTERLACE_NONE,
-                    PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
-       png_init_io(Struct, File);
-       png_write_info(Struct, Info);
-
-       uint8_t Line[Width];
-       for(int Row=0; Row<Height; Row++)
-       { Type *Img = Data+(Row*Width);
-         for(int Col=0; Col<Width; Col++)
-         { Type Pixel=(*Img++);
-           if(LogRef)
-           { if(Pixel) { Pixel=logf((float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
-             else Pixel=0; }
-           else
-           { Pixel = Pixel*Scale + Bias; }
-           if(Pixel<0x00) Pixel=0x00;
-           else if(Pixel>0xFF) Pixel=0xFF;
-           Line[Col]=(uint8_t)Pixel; }
-         png_write_row(Struct, Line);
-       }
-
-       png_write_end(Struct, Info);
-       png_destroy_write_struct(&Struct, (png_infopp)0);
-       fclose(File);
-       return Width*Height; }
-*/
-
-   int WriteJPG_8bpp(int Fd, int Quality=80, Type LogRef=0, Type Scale=1, Type Bias=0) const
-     { FILE *File=fdopen(Fd, "wb"); if(File==0) return -1;
-       int Size=WriteJPG_8bpp(File, Quality, LogRef, Scale, Bias);
-       fclose(File); return Size; }
-
-   int WriteJPG_8bpp(const char *FileName, int Quality=80, Type LogRef=0, Type Scale=1, Type Bias=0) const
-     { FILE *File=fopen(FileName, "wb"); if(File==0) return -1;
-       int Size=WriteJPG_8bpp(File, Quality, LogRef, Scale, Bias);
-       fclose(File); return Size; }
-
-   int WriteJPG_8bpp(FILE *File, int Quality=80, Type LogRef=0, Type Scale=1, Type Bias=0) const
-     {
-       struct jpeg_compress_struct JpegCompress;
-       struct jpeg_error_mgr       JpegErrorManager;
-              jmp_buf              JpegErrorJmp;
-
-       JpegCompress.err = jpeg_std_error(&JpegErrorManager);
-       jpeg_create_compress(&JpegCompress);
-       JpegCompress.image_width  = Width;
-       JpegCompress.image_height = Height;
-       JpegCompress.input_components = 1;
-       JpegCompress.in_color_space = JCS_GRAYSCALE;
-       jpeg_set_defaults(&JpegCompress);
-       jpeg_set_quality(&JpegCompress, Quality, TRUE);
-       jpeg_stdio_dest(&JpegCompress, File);
-       jpeg_start_compress(&JpegCompress, TRUE);
-
-       if(setjmp(JpegErrorJmp))
-       { jpeg_abort_compress(&JpegCompress);
-         jpeg_destroy_compress(&JpegCompress);
-         return -1; }
-
-       uint8_t Line[Width];
-       for(int Row=0; Row<Height; Row++)     // loop over image lines
-       { Type *Img = Data+(Row*Width);
-         for(int Col=0; Col<Width; Col++)    // loop over pixels in a line
-         { Type Pixel=(*Img++);
-           if(LogRef)                        // logarythimc pixel rescale
-           { if(Pixel) { Pixel=logf((float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
-             else Pixel=0; }                 //
-           else                              // linear pixel rescale
-           { Pixel = Pixel*Scale + Bias; }
-           if(Pixel<0x00) Pixel=0x00;        // limit to 8 bits
-           else if(Pixel>0xFF) Pixel=0xFF;
-           Line[Col]=(uint8_t)Pixel; }
-         uint8_t *RowPtr=Line;
-         jpeg_write_scanlines(&JpegCompress, &RowPtr, 1);
-       }
-
-       jpeg_finish_compress(&JpegCompress);
-       jpeg_destroy_compress(&JpegCompress);
-       return Width*Height; }
-
-} ;
-
-// =============================================================================
-
-#endif // of __IMAGE_H__
-
diff --git a/jpeg.h b/jpeg.h
deleted file mode 100644
index 8891fc6..0000000
--- a/jpeg.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdlib.h>
-#include <stdint.h>
-
-#include <setjmp.h>
-#include <jpeglib.h>
-
-class JPEG
-{ private:
-   struct jpeg_compress_struct Compress;           // structures for jpeglib
-   struct jpeg_error_mgr       ErrorManager;
-   struct jpeg_destination_mgr DestinationManager;
-          jmp_buf              ErrorJmp;
-
-  public:
-   uint8_t *Data;                                 // compressed JPEG storage
-   size_t   Size;                                 // actuall JPEG size
-   uint32_t Valid;
-
-  private:
-   size_t Allocated;                             // allocated staorage
-   static const size_t AllocUnit = 8192;         // storage will be allocated in blocks
-
-  public:
-   int Quality;                                  // JPEG quality: 0..100
-
-  private:
-   size_t Reallocate(size_t NewSize)            // reallocate JPEG storage to a new (bigger) size
-     { // printf("Reallocate(%d)\n", NewSize);
-       Data=(uint8_t *)realloc(Data, NewSize);
-       if(Data==0) { Allocated=0; Size=0; return 0; } // return zero if not possible to reallocate
-       return Allocated=NewSize; }
-
-   static void BufferInit_(jpeg_compress_struct *Compress)
-     { JPEG *Client = (JPEG *)Compress->client_data; Client->BufferInit(); }
-
-          void BufferInit(void)
-     { if(Allocated<=0) Reallocate(AllocUnit);
-       DestinationManager.next_output_byte    = Data;
-       DestinationManager.free_in_buffer      = Allocated;
-       Size=0; }
-
-   static boolean BufferFull_(jpeg_compress_struct *Compress)
-     { JPEG *Client = (JPEG *)Compress->client_data; return Client->BufferFull(); }
-
-          boolean BufferFull(void)
-     { Size=Allocated;
-       if(Reallocate(Allocated+AllocUnit)<=0)
-       { longjmp(ErrorJmp, -1); return FALSE; }
-       DestinationManager.next_output_byte    = Data+Size;
-       DestinationManager.free_in_buffer      = Allocated-Size;
-       return TRUE; }
-
-   static void BufferTerminate_(jpeg_compress_struct *Compress)
-     { JPEG *Client = (JPEG *)Compress->client_data; Client->BufferTerminate(); }
-
-          void BufferTerminate(void)
-     { Size=Allocated-DestinationManager.free_in_buffer; }
-
-   int Compress_(uint8_t *Image, int Width, int Height,                      // compress Image
-                 J_COLOR_SPACE ColorSpace, int BytesPerPixel)
-     { Compress.image_width      = Width;
-       Compress.image_height     = Height;
-       Compress.input_components = BytesPerPixel;
-       Compress.in_color_space   = ColorSpace;
-       jpeg_set_defaults(&Compress);
-       jpeg_set_quality(&Compress, Quality, TRUE);
-
-       jpeg_start_compress(&Compress, TRUE);
-
-       int Row=0;
-       if(setjmp(ErrorJmp)) { jpeg_abort_compress(&Compress); Size=0; return -1; }
-
-       for(Row=0; Row<Height; Row++, Image+=(Width*BytesPerPixel))
-       { jpeg_write_scanlines(&Compress, &Image, 1); }
-
-       jpeg_finish_compress(&Compress);
-       return Size; }
-
-  public:
-   JPEG()
-     { Data=0; Allocated=0; Size=0;
-       Quality=80;
-       Compress.err = jpeg_std_error(&ErrorManager);
-       jpeg_create_compress(&Compress);
-       Compress.client_data = this;
-       Compress.dest = &DestinationManager;
-       DestinationManager.init_destination    = BufferInit_;        // call-backs
-       DestinationManager.empty_output_buffer = BufferFull_;
-       DestinationManager.term_destination    = BufferTerminate_;
-     }
-
-  ~JPEG()
-     { jpeg_destroy_compress(&Compress);
-       if(Data) free(Data); }
-
-   int Compress_MONO8(uint8_t *Image, int Width, int Height)        // compress a grey-scale image
-     { return Compress_(Image, Width, Height, JCS_GRAYSCALE, 1); }
-
-   int Compress_RGB24(uint8_t *Image, int Width, int Height)        // compress an RGB image
-     { return Compress_(Image, Width, Height, JCS_RGB, 3); }
-
-   int Write(char *FileName)                                        // write compressed JPEG image to a file
-     { if(Data==0) return 0;
-       FILE *File = fopen(FileName, "wb"); if(File==0) return 0;
-       size_t Written=fwrite(Data, 1, Size, File);
-       fclose(File); return Written; }
-
-} ;
diff --git a/mailbox.c b/mailbox.c
deleted file mode 100644
index 2958d33..0000000
--- a/mailbox.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <assert.h>
-#include <stdint.h>
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-
-#include "mailbox.h"
-
-#define PAGE_SIZE (4*1024)
-
-void *mapmem(unsigned base, unsigned size)
-{
-   int mem_fd;
-   unsigned offset = base % PAGE_SIZE;
-   base = base - offset;
-   /* open /dev/mem */
-   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
-      printf("can't open /dev/mem\nThis program should be run as root. Try prefixing command with: sudo\n");
-      exit (-1);
-   }
-   void *mem = mmap(
-      0,
-      size,
-      PROT_READ|PROT_WRITE,
-      MAP_SHARED/*|MAP_FIXED*/,
-      mem_fd,
-      base);
-#ifdef DEBUG
-   printf("base=0x%x, mem=%p\n", base, mem);
-#endif
-   if (mem == MAP_FAILED) {
-      printf("mmap error %d\n", (int)mem);
-      exit (-1);
-   }
-   close(mem_fd);
-   return (char *)mem + offset;
-}
-
-void unmapmem(void *addr, unsigned size)
-{
-   int s = munmap(addr, size);
-   if (s != 0) {
-      printf("munmap error %d\n", s);
-      exit (-1);
-   }
-}
-
-/*
- * use ioctl to send mbox property message
- */
-
-static int mbox_property(int file_desc, void *buf)
-{
-   int ret_val = ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
-
-   if (ret_val < 0) {
-      printf("ioctl_set_msg failed:%d\n", ret_val);
-   }
-
-#ifdef DEBUG
-   unsigned *p = buf; int i; unsigned size = *(unsigned *)buf;
-   for (i=0; i<size/4; i++)
-      printf("%04x: 0x%08x\n", i*sizeof *p, p[i]);
-#endif
-   return ret_val;
-}
-
-unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags)
-{
-   int i=0;
-   unsigned p[32];
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-
-   p[i++] = 0x3000c; // (the tag id)
-   p[i++] = 12; // (size of the buffer)
-   p[i++] = 12; // (size of the data)
-   p[i++] = size; // (num bytes? or pages?)
-   p[i++] = align; // (alignment)
-   p[i++] = flags; // (MEM_FLAG_L1_NONALLOCATING)
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-unsigned mem_free(int file_desc, unsigned handle)
-{
-   int i=0;
-   unsigned p[32];
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-
-   p[i++] = 0x3000f; // (the tag id)
-   p[i++] = 4; // (size of the buffer)
-   p[i++] = 4; // (size of the data)
-   p[i++] = handle;
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-unsigned mem_lock(int file_desc, unsigned handle)
-{
-   int i=0;
-   unsigned p[32];
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-
-   p[i++] = 0x3000d; // (the tag id)
-   p[i++] = 4; // (size of the buffer)
-   p[i++] = 4; // (size of the data)
-   p[i++] = handle;
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-unsigned mem_unlock(int file_desc, unsigned handle)
-{
-   int i=0;
-   unsigned p[32];
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-
-   p[i++] = 0x3000e; // (the tag id)
-   p[i++] = 4; // (size of the buffer)
-   p[i++] = 4; // (size of the data)
-   p[i++] = handle;
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
-{
-   int i=0;
-   unsigned p[32];
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-
-   p[i++] = 0x30010; // (the tag id)
-   p[i++] = 28; // (size of the buffer)
-   p[i++] = 28; // (size of the data)
-   p[i++] = code;
-   p[i++] = r0;
-   p[i++] = r1;
-   p[i++] = r2;
-   p[i++] = r3;
-   p[i++] = r4;
-   p[i++] = r5;
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-unsigned qpu_enable(int file_desc, unsigned enable)
-{
-   int i=0;
-   unsigned p[32];
-
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-
-   p[i++] = 0x30012; // (the tag id)
-   p[i++] = 4; // (size of the buffer)
-   p[i++] = 4; // (size of the data)
-   p[i++] = enable;
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout) {
-   int i=0;
-   unsigned p[32];
-
-   p[i++] = 0; // size
-   p[i++] = 0x00000000; // process request
-   p[i++] = 0x30011; // (the tag id)
-   p[i++] = 16; // (size of the buffer)
-   p[i++] = 16; // (size of the data)
-   p[i++] = num_qpus;
-   p[i++] = control;
-   p[i++] = noflush;
-   p[i++] = timeout; // ms
-
-   p[i++] = 0x00000000; // end tag
-   p[0] = i*sizeof *p; // actual size
-
-   mbox_property(file_desc, p);
-   return p[5];
-}
-
-int mbox_open() {
-   int file_desc;
-
-   // open a char device file used for communicating with kernel mbox driver
-   file_desc = open(DEVICE_FILE_NAME, 0);
-   if (file_desc < 0) {
-      printf("Can't open device file: %s\n", DEVICE_FILE_NAME);
-      printf("Try creating a device file with: sudo mknod %s c %d 0\n", DEVICE_FILE_NAME, MAJOR_NUM);
-      exit(-1);
-   }
-   return file_desc;
-}
-
-void mbox_close(int file_desc) {
-  close(file_desc);
-}
diff --git a/mailbox.h b/mailbox.h
deleted file mode 100644
index 370d115..0000000
--- a/mailbox.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
-Copyright (c) 2012, Broadcom Europe Ltd.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-    * Neither the name of the copyright holder nor the
-      names of its contributors may be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <linux/ioctl.h>
-
-#define MAJOR_NUM 100
-#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
-#define DEVICE_FILE_NAME "/dev/vcio"
-
-int mbox_open();
-void mbox_close(int file_desc);
-
-unsigned get_version(int file_desc);
-unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags);
-unsigned mem_free(int file_desc, unsigned handle);
-unsigned mem_lock(int file_desc, unsigned handle);
-unsigned mem_unlock(int file_desc, unsigned handle);
-void *mapmem(unsigned base, unsigned size);
-void unmapmem(void *addr, unsigned size);
-
-unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
-unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);
-unsigned qpu_enable(int file_desc, unsigned enable);
diff --git a/ogn-rf.cc b/ogn-rf.cc
deleted file mode 100644
index c9baead..0000000
--- a/ogn-rf.cc
+++ /dev/null
@@ -1,1068 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-#include <unistd.h>
-#include <math.h>
-
-#include <libconfig.h>
-
-#include <algorithm>
-
-#include "thread.h"     // multi-thread stuff
-#include "fft.h"        // Fast Fourier Transform
-#include "rtlsdr.h"     // SDR radio
-
-#define QUOTE(name) #name
-#define STR(macro) QUOTE(macro)
-#ifndef VERSION
-#define VERSION 0.0.0
-#endif
-
-#include "jpeg.h"
-#include "socket.h"
-#include "sysmon.h"
-
-#include "pulsefilter.h"
-#include "tonefilter.h"
-
-// ==================================================================================================
-
-template <class Float> // scale floating-point data to 8-bit gray scale image
- void LogImage(SampleBuffer<uint8_t> &Image, SampleBuffer<Float> &Data, Float LogRef=0, Float Scale=1, Float Bias=0)
-{ Image.Allocate(Data);
-  int Pixels=Data.Full;
-  for(int Idx=0; Idx<Pixels; Idx++)
-  { Float Pixel=Data.Data[Idx];
-    if(LogRef)
-    { if(Pixel) { Pixel=logf((Float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
-           else { Pixel=0; } }
-    else
-    { Pixel = Pixel*Scale + Bias; }
-    if(Pixel<0x00) Pixel=0x00;
-    else if(Pixel>0xFF) Pixel=0xFF;
-    Image.Data[Idx]=(uint8_t)Pixel;
-  }
-  Image.Full=Pixels;
-}
-
-// ==================================================================================================
-
-class RF_Acq                                    // acquire wideband (1MHz) RF data thus both OGN frequencies at same time
-{ public:
-   int    SampleRate;                           // [Hz] sampling rate
-
-   int    OGN_GainMode;                         // 0=Auto, 1=Manual, 2=Linearity, 3=Sensitivity
-   int    OGN_Gain;                             // [0.1dB] Rx gain for OGN reception
-   int    OGN_CenterFreq;                       // [Hz] center acquisition frequency: can be 868.3+/-0.2 MHz
-   double OGN_StartTime;                        // [sec] when to start acquisition on the center frequency
-   int    OGN_SamplesPerRead;                   // [samples] should correspond to about 800 ms of data and be a multiple of 256
-                                                // the goal is to listen on center frequency from 0.4 to 1.2 sec
-   int    OGN_SaveRawData;
-   const static uint32_t OGN_RawDataSync = 0x254F7D01;
-
-                                                // for frequency hopping
-   // int              FreqBase;                   // [Hz] for Australia: 917.0MHz, for USA: 902.2MHz
-   static const int FreqHopChannelWidth = 400000;  // [Hz] 0.4MHz per channel
-   int              OGN_FreqHopChannels;           // [number] Australia: 24, USA: 65
-
-   int  DeviceIndex;                            // rtl-sdr device index
-   char DeviceSerial[64];                       // serial number of the rtl-sdr device to be selected
-   int  OffsetTuning;                           // [bool] this option might be good for E4000 tuner
-   int  BiasTee;                                // [bool] T-bias for external LNA power
-   int  FreqCorr;                               // [ppm] frequency correction applied to the Rx chip
-   RTLSDR SDR;                                  // SDR receiver (DVB-T stick)
-   ReuseObjectQueue< SampleBuffer<uint8_t> > OutQueue; // OGN sample batches are sent there
-
-   Thread Thr;                                  // acquisition thread
-   volatile int StopReq;                        // request to stop the acquisition thread
-
-   PulseFilter PulseFilt;
-
-   static const int GSM_GainMode = 1;           // Manual gain mode for GSM
-   int GSM_Gain;                                // [0.1dB] Rx gain for GSM frequency calibration
-   int GSM_CenterFreq;                          // [Hz] should be selected to cover at lease one broadcast channel in the area
-   int GSM_Scan;                                // [bool] scan around the whole GSM band
-   int GSM_SamplesPerRead;                      // [samples] should cover one or more frequency correction bursts (100 ms should be enough ?)
-   volatile float GSM_FreqCorr;                 // [ppm] frequency correction measured by the GSM frequency calibration
-   static const int GSM_LowEdge = 925100000;    // [Hz] E-GSM-900 band, excluding the guards of 100kHz
-   static const int GSM_UppEdge = 959900000;    // [Hz]
-   static const int GSM_ScanStep =   800000;    // [Hz]
-   ReuseObjectQueue< SampleBuffer<uint8_t> > GSM_OutQueue; // GSM sample batches are sent there
-
-   MessageQueue<Socket *>  RawDataQueue;        // sockets send to this queue should be written with a most recent raw data
-
-  public:
-   RF_Acq() { Config_Defaults();
-              GSM_FreqCorr=0;
-              // PulseBox.Preset(PulseBoxSize);
-              StopReq=0; Thr.setExec(ThreadExec); }
-
-  ~RF_Acq() { }
-
-  void Config_Defaults(void)
-  { SampleRate=1000000;
-    OGN_CenterFreq=868300000;
-    OGN_StartTime=0.375; OGN_SamplesPerRead=(850*SampleRate)/1000;
-    OGN_GainMode=1; OGN_Gain=600;
-    OGN_FreqHopChannels=0;
-    OGN_SaveRawData=0;
-    PulseFilt.Threshold=0;
-    DeviceIndex=0; DeviceSerial[0]=0;
-    OffsetTuning=0; FreqCorr=0; BiasTee=0;
-    GSM_CenterFreq=GSM_LowEdge+GSM_ScanStep/2; GSM_Scan=1; GSM_SamplesPerRead=(250*SampleRate)/1000; GSM_Gain=200; }
-
-  int config_lookup_float_or_int(config_t *Config, const char *Path, double *Value)
-  { int Ret = config_lookup_float(Config, Path, Value); if(Ret==CONFIG_TRUE) return Ret;
-    int IntValue; Ret = config_lookup_int(Config, Path, &IntValue); if(Ret==CONFIG_TRUE) { (*Value) = IntValue; return Ret; }
-    return Ret; }
-
-  int Config(config_t *Config)
-  { double Corr=0.0;
-    config_lookup_float_or_int(Config,   "RF.FreqCorr", &Corr); FreqCorr = (int)floor(Corr+0.5);
-    config_lookup_int(Config,   "RF.Device",         &DeviceIndex);
-    const char *Serial = 0;
-    config_lookup_string(Config,"RF.DeviceSerial",   &Serial);
-    if(Serial) { strncpy(DeviceSerial, Serial, 64); DeviceSerial[63]=0; }
-    config_lookup_int(Config,   "RF.OfsTune",        &OffsetTuning);
-    config_lookup_int(Config,   "RF.BiasTee",        &BiasTee);
-    config_lookup_int(Config,   "RF.OGN.GainMode",   &OGN_GainMode);
-
-    config_lookup_int(Config,   "RF.OGN.SaveRawData",   &OGN_SaveRawData);
-
-    SampleRate=1000000;
-    if(config_lookup_int(Config, "RF.OGN.SampleRate", &SampleRate)!=CONFIG_TRUE)
-    { double Rate;
-      if(config_lookup_float(Config, "RF.OGN.SampleRate", &Rate)==CONFIG_TRUE) SampleRate=(int)floor(1e6*Rate+0.5);
-      else if(config_lookup_int(Config, "RF.SampleRate", &SampleRate)!=CONFIG_TRUE)
-      { if(config_lookup_float(Config, "RF.SampleRate", &Rate)==CONFIG_TRUE) SampleRate=(int)floor(1e6*Rate+0.5); }
-    }
-
-    double InpGain= 60.0; config_lookup_float_or_int(Config, "RF.OGN.Gain",         &InpGain); OGN_Gain=(int)floor(InpGain*10+0.5);
-    double Freq=868.3;    config_lookup_float_or_int(Config, "RF.OGN.CenterFreq",   &Freq);    OGN_CenterFreq=(int)floor(Freq*1e6+0.5);
-           InpGain= 20.0; config_lookup_float_or_int(Config, "RF.GSM.Gain",         &InpGain); GSM_Gain=(int)floor(InpGain*10+0.5);
-           Freq=958.4;    config_lookup_float_or_int(Config, "RF.GSM.CenterFreq",   &Freq);    GSM_CenterFreq=(int)floor(Freq*1e6+0.5); GSM_Scan=0;
-
-    OGN_FreqHopChannels=0;
-    config_lookup_int(Config, "RF.OGN.FreqHopChannels",  &OGN_FreqHopChannels);
-
-    PulseFilt.Threshold=0;
-    config_lookup_int(Config, "RF.PulseFilter.Threshold",  &PulseFilt.Threshold);
-
-    config_lookup_float(Config, "RF.OGN.StartTime", &OGN_StartTime);
-    double SensTime=0.850;
-    config_lookup_float(Config, "RF.OGN.SensTime",  &SensTime);
-    OGN_SamplesPerRead=(int)floor(SensTime*SampleRate+0.5);
-           SensTime=0.250;
-    config_lookup_float(Config, "RF.GSM.SensTime",  &SensTime);
-    GSM_SamplesPerRead=(int)floor(SensTime*SampleRate+0.5);
-
-    return 0; }
-
-   int QueueSize(void) { return OutQueue.Size(); }
-
-   int Start(void) { StopReq=0; return Thr.Create(this); }
-   int Stop(void)  { StopReq=1; return Thr.Join(); }
-
-   static void *ThreadExec(void *Context)
-   { RF_Acq *This = (RF_Acq *)Context; return This->Exec(); }
-
-   void *Exec(void)
-   { // printf("RF_Acq.Exec() ... Start\n");
-     char Header[256];
-     int Priority = Thr.getMaxPriority(); Thr.setPriority(Priority);
-     int CurrCenterFreq = OGN_CenterFreq;
-     while(!StopReq)
-     { if(SDR.isOpen())                                                    // if device is already open
-       { double Now  = SDR.getTime();
-         int    IntTimeNow = (int)floor(Now); int ReadGSM = (IntTimeNow%20) == 0; // do the GSM calibration every 20 seconds
-
-         int NextCenterFreq = OGN_CenterFreq;
-         if(OGN_FreqHopChannels)
-         { int Channel = FreqHopChannel1(IntTimeNow+1);
-           NextCenterFreq += FreqHopChannelWidth*Channel; }
-
-         double FracTimeNow = Now-IntTimeNow;
-         double WaitTime = OGN_StartTime-FracTimeNow; if(WaitTime<0) WaitTime+=1.0;
-         int SamplesToRead=OGN_SamplesPerRead;
-         if( ReadGSM || (QueueSize()>1) ) SamplesToRead/=2; // when GSM calibration or data is not being processed fast enough we only read half-time
-         if(WaitTime<0.200)
-         { usleep((int)floor(1e6*WaitTime+0.5));                              // wait right before the time slot starts
-           SampleBuffer<uint8_t> *Buffer = OutQueue.New();                    // get the next buffer to fill with raw I/Q data
-           SDR.ResetBuffer();                                                 // needed before every Read()
-           int Read=SDR.Read(*Buffer, SamplesToRead);                         // read the time slot raw RF data
-           Buffer->Freq += CurrCenterFreq * (1e-6*GSM_FreqCorr);              // correct the frequency (sign ?)
-           if(OGN_SaveRawData>0)
-           { time_t Time=(time_t)floor(Buffer->Time);
-             struct tm *TM = gmtime(&Time);
-             char FileName[32]; sprintf(FileName, "OGNraw_%04d.%02d.%02d.u8", 1900+TM->tm_year, TM->tm_mon+1, TM->tm_mday);
-             FILE *File=fopen(FileName, "ab");
-             if(File)
-             { SerializeWriteSync(File, OGN_RawDataSync);
-               Buffer->Serialize(File);
-               fclose(File);
-               OGN_SaveRawData--; }
-           }
-           PulseFilt.Process(*Buffer);
-           if(QueueSize()>1) printf("RF_Acq.Exec() ... Half time slot\n");
-           // printf("RF_Acq.Exec() ... SDR.Read() => %d, Time=%16.3f, Freq=%6.1fMHz\n", Read, Buffer->Time, 1e-6*Buffer->Freq);
-           if(Read>0) // RF data Read() successful
-           { while(RawDataQueue.Size())                                       // when a raw data for this slot was requested
-             { Socket *Client; RawDataQueue.Pop(Client);
-               sprintf(Header, "HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nContent-Type: audio/basic\r\nContent-Disposition: attachment; filename=\"time-slot-rf_%14.3f.u8\"\r\n\r\n", Buffer->Time);
-               Client->Send(Header);
-               Client->Send(Buffer->Data, Buffer->Full);
-               Client->SendShutdown(); Client->Close(); delete Client; }
-             if(OutQueue.Size()<4) { OutQueue.Push(Buffer); }
-                              else { OutQueue.Recycle(Buffer); printf("RF_Acq.Exec() ... Dropped a slot\n"); }
-           } else     // RF data Read() failed
-           { SDR.Close(); printf("RF_Acq.Exec() ... SDR.Read() failed => SDR.Close()\n"); continue; }
-           if(ReadGSM) // if we are to read GSM in the second half-slot
-           { SDR.setCenterFreq(GSM_CenterFreq);      // setup for the GSM reception
-             SDR.setTunerGainMode(GSM_GainMode);
-             SDR.setTunerGain(GSM_Gain);
-             GSM_FreqCorr-=(FreqCorr-SDR.getFreqCorrection());
-             SDR.setFreqCorrection(FreqCorr);
-             SampleBuffer<uint8_t> *Buffer = GSM_OutQueue.New();
-             SDR.ResetBuffer();
-             int Read=SDR.Read(*Buffer, GSM_SamplesPerRead);
-             // printf("RF_Acq.Exec() ...(GSM) SDR.Read() => %d, Time=%16.3f, Freq=%6.1fMHz\n", Read, Buffer->Time, 1e-6*Buffer->Freq);
-             if(Read>0)
-             { if(GSM_OutQueue.Size()<3) GSM_OutQueue.Push(Buffer);
-                                  else { GSM_OutQueue.Recycle(Buffer); printf("RF_Acq.Exec() ... Dropped a GSM batch\n"); }
-             }
-             SDR.setTunerGainMode(OGN_GainMode);
-             SDR.setTunerGain(OGN_Gain);                // back to OGN reception setup
-             if(GSM_Scan)
-             { GSM_CenterFreq+=GSM_ScanStep;
-               if(GSM_CenterFreq>=GSM_UppEdge) GSM_CenterFreq=GSM_LowEdge+GSM_ScanStep/2;
-             }
-           }
-           if(ReadGSM | OGN_FreqHopChannels)
-           { SDR.setCenterFreq(NextCenterFreq); CurrCenterFreq=NextCenterFreq; }
-         }
-         else usleep(100000);
-       }
-       else                                                                // if not open yet or was closed due to an error
-       { int Index=(-1);
-         if(DeviceSerial[0]) Index=SDR.getDeviceIndexBySerial(DeviceSerial);
-         if(Index<0) Index=DeviceIndex;
-         if(SDR.Open(Index, OGN_CenterFreq, SampleRate)<0)                    // try to open it
-         { printf("RF_Acq.Exec() ... SDR.Open(%d, , ) fails, retry after 1 sec\n", Index); usleep(1000000); }
-         else
-         { SDR.setOffsetTuning(OffsetTuning);
-           SDR.setBiasTee(BiasTee);
-           SDR.setTunerGainMode(OGN_GainMode);
-           SDR.setTunerGain(OGN_Gain); }
-           SDR.setFreqCorrection(FreqCorr);
-       }
-     }
-
-     SDR.Close();
-     // printf("RF_Acq.Exec() ... Stop\n");
-     return  0; }
-
-   uint32_t FreqHopHash(uint32_t Time)
-   { Time  = (Time<<15) + (~Time);
-     Time ^= Time>>12;
-     Time += Time<<2;
-     Time ^= Time>>4;
-     Time *= 2057;
-     return Time ^ (Time>>16); }
-
-   uint16_t FreqHopChannel1(uint32_t Time)
-   { return FreqHopHash((Time<<1)  )%OGN_FreqHopChannels; }
-
-   uint16_t FreqHopChannel2(uint32_t Time)
-   { return FreqHopHash((Time<<1)+1)%OGN_FreqHopChannels; }
-
-} ;
-
-// ==================================================================================================
-
-template <class Float>
- class Inp_Filter
-{ public:
-
-   Thread Thr;                                      // processing thread
-   volatile int StopReq;
-   RF_Acq *RF;
-
-   int              Enable;
-   ToneFilter<Float> ToneFilt;
-
-   ReuseObjectQueue< SampleBuffer< std::complex<Float> > > OutQueue;
-
-  public:
-
-   Inp_Filter(RF_Acq *RF)
-   { this->RF=RF; Config_Defaults(); Preset(); }
-
-   void Config_Defaults(void)
-   { Enable  = 0; ToneFilt.FFTsize = 32768; ToneFilt.Threshold=32; }
-
-   int Config(config_t *Config)
-   { config_lookup_int(Config,   "RF.ToneFilter.Enable",    &Enable);
-     config_lookup_int(Config,   "RF.ToneFilter.FFTsize",   &ToneFilt.FFTsize);
-     config_lookup_float(Config, "RF.ToneFilter.Threshold", &ToneFilt.Threshold);
-     return 0; }
-
-   int Preset(void) { return ToneFilt.Preset(); }
-
-   int QueueSize(void) { return OutQueue.Size(); }
-   void Start(void)
-   { StopReq=0; Thr.setExec(ThreadExec); Thr.Create(this); }
-
-  ~Inp_Filter()
-   { Thr.Cancel(); }
-
-   double getCPU(void) // get CPU time for this thread
-   {
-#if !defined(__MACH__)
-       struct timespec now; clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now); return now.tv_sec + 1e-9*now.tv_nsec;
-#else
-       return 0;
-#endif
-   }
-
-   static void *ThreadExec(void *Context)
-   { Inp_Filter<Float> *This = (Inp_Filter<Float> *)Context; return This->Exec(); }
-
-   void *Exec(void)
-   { // printf("Inp_Filter.Exec() ... Start\n");
-     while(!StopReq)
-     { if(!Enable) { sleep(1); continue; }
-       double ExecTime=getCPU();
-       SampleBuffer<uint8_t> *InpBuffer = RF->OutQueue.Pop();   // here we wait for a new data batch
-       // printf("Inp_Filter.Exec() ... Input(%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
-       SampleBuffer< std::complex<Float> > *OutBuffer = OutQueue.New();
-       ToneFilt.Process(OutBuffer, InpBuffer);
-       RF->OutQueue.Recycle(InpBuffer);                         // let the input buffer go free
-       // printf("Inp_Filter.Exec() ... Output(%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*OutBuffer->Freq, OutBuffer->Time, OutBuffer->Full/2);
-       if(OutQueue.Size()<4) { OutQueue.Push(OutBuffer); }
-                        else { OutQueue.Recycle(OutBuffer); printf("Inp_Filter.Exec() ... Dropped a slot\n"); }
-       ExecTime=getCPU()-ExecTime; // printf("Inp_FFT.Exec() ... %5.3fsec\n", ExecTime);
-     }
-     // printf("Inp_FFT.Exec() ... Stop\n");
-     return 0; }
-
-   // classical sliding box filter - calc. the sum within box of 2*Radius+1
-   static void BoxSum(Float *Output, Float *Input, int Size, int Radius)
-   { int BoxSize=2*Radius+1;
-     Float Sum=0; int InpIdx=0; int OutIdx=0;
-     for( ; InpIdx<Radius; InpIdx++)
-     { Sum+=Input[InpIdx]; }
-     for( ; InpIdx<BoxSize; InpIdx++)
-     { Sum+=Input[InpIdx]; Output[OutIdx++]=Sum; }
-     for( ; InpIdx<Size; InpIdx++)
-     { Sum+=Input[InpIdx]-Input[InpIdx-BoxSize]; Output[OutIdx++]=Sum; }
-     for( ; OutIdx<Size; )
-     { Sum-=Input[InpIdx-BoxSize]; Output[OutIdx++]=Sum; }
-   }
-
-
-} ;
-
-// ==================================================================================================
-
-template <class Float>
- class Inp_FFT                                      // FFT of the RF data
-{ public:
-
-   Thread Thr;                                      // processing thread
-   volatile int StopReq;
-   RF_Acq *RF;
-   Inp_Filter<Float> *Filter;
-
-   int              FFTsize;
-#ifdef USE_RPI_GPU_FFT
-   RPI_GPU_FFT      FFT;
-#else
-   DFT1d<Float>     FFT;
-#endif
-   Float           *Window;
-
-   SampleBuffer< std::complex<Float> > OutBuffer;
-   int  OutPipe;
-   char OutPipeName[32];
-   const static uint32_t OutPipeSync = 0x254F7D00 + sizeof(Float);
-
-  public:
-   Inp_FFT(RF_Acq *RF, Inp_Filter<Float> *Filter=0)
-   { Window=0; this->RF=RF; this->Filter=Filter; Preset(); OutPipe=(-1); Config_Defaults(); }
-
-   void Config_Defaults(void)
-   { strcpy(OutPipeName, "ogn-rf.fifo"); }
-
-   int Config(config_t *Config)
-   { const char *PipeName = "ogn-rf.fifo";
-     config_lookup_string(Config, "RF.PipeName",   &PipeName);
-     strcpy(OutPipeName, PipeName);
-     return 0; }
-
-  int Preset(void) { return Preset(RF->SampleRate); }
-   int Preset(int SampleRate)
-   { FFTsize=(8*SampleRate)/15625;
-     FFT.PresetForward(FFTsize);
-     Window=(Float *)realloc(Window, FFTsize*sizeof(Float));
-     FFT.SetSineWindow(Window, FFTsize, (Float)(1.0/sqrt(FFTsize)) );
-     return 1; }
-
-  int WriteToPipe(void) // write OutBuffer to the output pipe
-  { if(OutPipe<0)
-    { OutPipe=open(OutPipeName, O_WRONLY);
-      if(OutPipe<0)
-      { printf("Inp_FFT.Exec() ... Cannot open %s\n", OutPipeName);
-        // here we could try to create the missing pipe
-        return -1; } }
-    int Len=SerializeWriteSync(OutPipe, OutPipeSync);
-    if(Len>=0) { Len=SerializeWriteName(OutPipe, "FreqCorr"); }
-    if(Len>=0) { Len=SerializeWriteData(OutPipe, (void *)&(RF->FreqCorr),     sizeof(int)   ); }
-    if(Len>=0) { Len=SerializeWriteData(OutPipe, (void *)&(RF->GSM_FreqCorr), sizeof(float) ); }
-    if(Len>=0) { Len=SerializeWriteSync(OutPipe, OutPipeSync); }
-    if(Len>=0) { Len=SerializeWriteName(OutPipe, "Spectra"); }
-    if(Len>=0) { Len=OutBuffer.Serialize(OutPipe); }
-    if(Len<0) { printf("Inp_FFT.Exec() ... Error while writing to %s\n", OutPipeName); close(OutPipe); OutPipe=(-1); return -1; }
-    return 0; }
-
-   void Start(void)
-   { StopReq=0; Thr.setExec(ThreadExec); Thr.Create(this); }
-
-  ~Inp_FFT()
-   { Thr.Cancel();
-     if(Window) free(Window); }
-
-   double getCPU(void) // get CPU time for this thread
-   {
-#if !defined(__MACH__)
-       struct timespec now; clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now); return now.tv_sec + 1e-9*now.tv_nsec;
-#else
-       return 0;
-#endif
-   }
-
-   static void *ThreadExec(void *Context)
-   { Inp_FFT *This = (Inp_FFT *)Context; return This->Exec(); }
-
-   void *Exec(void)
-   { // printf("Inp_FFT.Exec() ... Start\n");
-     while(!StopReq)
-     { double ExecTime=getCPU();
-#ifndef USE_RPI_GPU_FFT
-       if(Filter && Filter->Enable)
-       { SampleBuffer< std::complex<Float> > *InpBuffer = Filter->OutQueue.Pop();
-         // printf("Inp_FFT.Exec() ... (%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
-         SlidingFFT(OutBuffer, *InpBuffer, FFT, Window);  // Process input samples, produce FFT spectra
-         Filter->OutQueue.Recycle(InpBuffer);
-       }
-       else
-#endif
-       { SampleBuffer<uint8_t> *InpBuffer = RF->OutQueue.Pop(); // here we wait for a new data batch
-         // printf("Inp_FFT.Exec() ... (%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
-         SlidingFFT(OutBuffer, *InpBuffer, FFT, Window);  // Process input samples, produce FFT spectra
-         RF->OutQueue.Recycle(InpBuffer);
-       }
-       WriteToPipe(); // here we send the FFT spectra in OutBuffer to the demodulator
-       ExecTime=getCPU()-ExecTime; // printf("Inp_FFT.Exec() ... %5.3fsec\n", ExecTime);
-     }
-     // printf("Inp_FFT.Exec() ... Stop\n");
-     if(OutPipe>=0) { close(OutPipe); OutPipe=(-1); }
-     return 0; }
-
-} ;
-
-// ==================================================================================================
-
-template <class Float>
- class GSM_FFT                                      // FFT of the GSM RF data
-{ public:
-
-   Thread Thr;                                      // processing thread
-   volatile int StopReq;
-   RF_Acq *RF;                                      // pointer to the RF acquisition
-
-   int              FFTsize;
-   DFT1d<Float>     FFT;
-   Float           *Window;
-
-   SampleBuffer< std::complex<Float> > Spectra;     // (complex) spectra
-   SampleBuffer< Float >               Power;       // spectra power (energy)
-
-   MessageQueue<Socket *>  SpectrogramQueue;        // sockets send to this queue should be written with a most recent spectrogram
-   SampleBuffer<uint8_t>   Image;
-   JPEG                    JpegImage;
-
-   std::vector<Float>  PPM_Values;                  // [ppm] measured frequency correction values (a vector of)
-   Float               PPM_Aver;                    // [ppm] average frequency correction
-   Float               PPM_RMS;                     // [ppm] RMS of the frequency correction
-   int                 PPM_Points;                  // number of measurements taken into the average
-   time_t              PPM_Time;                    // time when correction measured
-   Float            getPPM(void)  const { Float Value=PPM_Aver; return Value; }
-
-  public:
-   GSM_FFT(RF_Acq *RF)
-   { Window=0; this->RF=RF; Preset(); }
-
-   int Preset(void) { return Preset(RF->SampleRate); }
-   int Preset(int SampleRate)
-   { FFTsize=(8*SampleRate)/15625;
-     FFT.PresetForward(FFTsize);
-     Window=(Float *)realloc(Window, FFTsize*sizeof(Float));
-     FFT.SetSineWindow(Window, FFTsize, (Float)(1.0/sqrt(FFTsize)) );
-     PPM_Values.clear(); PPM_Aver=0; PPM_RMS=0; PPM_Points=0; PPM_Time=0;
-     return 1; }
-
-   void Start(void)
-   { StopReq=0; Thr.setExec(ThreadExec); Thr.Create(this); }
-
-  ~GSM_FFT()
-   { Thr.Cancel();
-     if(Window) free(Window); }
-
-   double getCPU(void) // get CPU time for this thread
-   {
-#if !defined(__MACH__)
-       struct timespec now; clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now); return now.tv_sec + 1e-9*now.tv_nsec;
-#else
-       return 0.0;
-#endif
-   }
-
-   static void *ThreadExec(void *Context)
-   { GSM_FFT *This = (GSM_FFT *)Context; return This->Exec(); }
-
-   void *Exec(void)
-   { // printf("GSM_FFT.Exec() ... Start\n");
-     while(!StopReq)
-     { double ExecTime=getCPU();
-       SampleBuffer<uint8_t> *InpBuffer = RF->GSM_OutQueue.Pop();
-       // printf("GSM_FFT.Exec() ... (%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
-       SlidingFFT(Spectra, *InpBuffer, FFT, Window);
-       SpectraPower(Power, Spectra);
-       RF->GSM_OutQueue.Recycle(InpBuffer);
-       if(SpectrogramQueue.Size())
-       { LogImage(Image, Power, (Float)0.33, (Float)32.0, (Float)32.0);
-         JpegImage.Compress_MONO8(Image.Data, Image.Len, Image.Samples() ); }
-       while(SpectrogramQueue.Size())
-       { Socket *Client; SpectrogramQueue.Pop(Client);
-         Client->Send("HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nContent-Type: image/jpeg\r\nRefresh: 10\r\n\r\n");
-         // printf("GSM_FFT.Exec() ... Request for (GSM)spectrogram\n");
-         Client->Send(JpegImage.Data, JpegImage.Size);
-         Client->SendShutdown(); Client->Close(); delete Client; }
-       Process();
-       ExecTime=getCPU()-ExecTime; // printf("GSM_FFT.Exec() ... %5.3fsec\n", ExecTime);
-     }
-     // printf("GSM_FFT.Exec() ... Stop\n");
-     return 0; }
-
-   static const int ChanWidth = 200000; // [Hz] GSM channel width
-   static const int DataRate  = 270833; // [Hz] GSM data rate
-   SampleBuffer<Float> Aver, Peak, PeakPos, Bkg;
-
-   void Process(void)
-   { Float BinWidth=Power.Rate/2;                              // [Hz] FFT bin spectral width
-     int Bins = Power.Len;                                     // [int] number of FFT bins
-     Float FirstBinFreq = Power.Freq-BinWidth*Bins/2;          // [Hz] center frequency of the first FFT bin
-     Float LastBinFreq  = Power.Freq+BinWidth*Bins/2;          // [Hz] center frequency of the one-after-the-last FFT bin
-
-     int Chan = (int)ceil(FirstBinFreq/ChanWidth);             // integer channel number corr. to the first FFT bin (GSM channels are on multiples of 200kHz)
-     for( ; ; Chan++)                                          // loop over (possible) channels in this scan
-     { Float CenterFreq=Chan*ChanWidth; if(CenterFreq>=LastBinFreq) break; // center frequency of the channel
-       Float LowFreq = CenterFreq-0.45*ChanWidth;              // [Hz] lower frequency to measure the channel
-       Float UppFreq = CenterFreq+0.45*ChanWidth;              // [Hz] upper frequency to measure the channel
-       int LowBin=(int)floor((LowFreq-FirstBinFreq)/BinWidth+0.5); // FFT bins corresponding to the channel frequency range
-       int UppBin=(int)floor((UppFreq-FirstBinFreq)/BinWidth+0.5);
-       if( (LowBin<0) || (LowBin>=Bins) ) continue;            // skip this channel if range to measure
-       if( (UppBin<0) || (UppBin>=Bins) ) continue;            // not contained completely in this scan
-       Float AverPower;
-       int Marks=ProcessChan(AverPower, LowBin, UppBin, (CenterFreq-FirstBinFreq)/BinWidth, BinWidth, CenterFreq);
-       if(Marks==1) PPM_Values.pop_back(); // if only one mark found, drop it - likely a false signal
-       // printf("Process: Chan=%d, Freq=%8.3fMHz [%3d-%3d] %+6.1fdB %d\n", Chan, 1e-6*CenterFreq, LowBin, UppBin, 10*log10(AverPower), Marks);
-       // { char FileName[32]; sprintf(FileName, "GSM_%5.1fMHz.dat", 1e-6*CenterFreq);
-       //   FILE *File=fopen(FileName, "wt");
-       //   for(int Idx=0; Idx<Aver.Full; Idx++)
-       //  { fprintf(File, "%5d %12.6f %12.6f %+10.6f %10.6f\n",
-       //                   Idx, Aver[Idx], Peak[Idx], PeakPos[Idx], Bkg[Idx]); }
-       //   fclose(File); }
-     }
-
-     std::sort(PPM_Values.begin(), PPM_Values.end());
-
-     if(PPM_Values.size()>=16)                                         // if at least 16 measured points
-     { Float Aver, RMS; int Margin=PPM_Values.size()/4;
-       AverRMS(Aver, RMS, PPM_Values.data()+Margin, PPM_Values.size()-2*Margin);
-       // printf("PPM = %+7.3f (%5.3f) [%d]\n", Aver, RMS, PPM_Values.size()-2*Margin);
-       if(RMS<0.5)
-       { PPM_Aver=Aver; PPM_RMS=RMS; PPM_Points=PPM_Values.size()-2*Margin; PPM_Time=(time_t)floor(Power.Time+0.5); PPM_Values.clear();
-         printf("GSM freq. calib. = %+7.3f +/- %5.3f ppm, %d points\n", PPM_Aver, PPM_RMS, PPM_Points);
-         Float Corr=RF->GSM_FreqCorr; Corr+=0.25*(PPM_Aver-Corr); RF->GSM_FreqCorr=Corr; }
-       PPM_Values.clear();
-     }
-
-     if(PPM_Values.size()>=8)                                          // if at least 8 measured points
-     { Float Aver, RMS;
-       AverRMS(Aver, RMS, PPM_Values.data()+1, PPM_Values.size()-2);   // calc. the average excluding two extreme points
-       // printf("PPM = %+7.3f (%5.3f) [%d]\n", Aver, RMS, PPM_Values.size()-2);
-       if(RMS<0.5)
-       { PPM_Aver=Aver; PPM_RMS=RMS; PPM_Points=PPM_Values.size()-2; PPM_Time=(time_t)floor(Power.Time+0.5); PPM_Values.clear();
-         printf("GSM freq. calib. = %+7.3f +/- %5.3f ppm, %d points\n", PPM_Aver, PPM_RMS, PPM_Points);
-         Float Corr=RF->GSM_FreqCorr; Corr+=0.25*(PPM_Aver-Corr); RF->GSM_FreqCorr=Corr; }
-     }
-
-   }
-
-   // Average, Peak (with Position) and Background = Average - values around the Peak
-   static void AverPeakBkg(Float &Aver, Float &Peak, Float &PeakPos, Float &Bkg, Float *Data, int Size)
-   { Aver=0; Peak=0; PeakPos=0; int PeakIdx=0;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Float Dat=Data[Idx];
-       if(Dat>Peak) { Peak=Dat; PeakIdx=Idx; }
-       Aver+=Dat; }
-     if(PeakIdx==0)             { Peak+=Data[     1];                    PeakPos=PeakIdx+Data[     1]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
-     else if(PeakPos==(Size-1)) { Peak+=Data[Size-2];                    PeakPos=PeakIdx-Data[Size-2]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
-     else                       { Peak+=Data[PeakIdx+1]+Data[PeakIdx-1]; PeakPos=PeakIdx+(Data[PeakIdx+1]-Data[PeakIdx-1])/Peak; Bkg=(Aver-Peak)/(Size-3); }
-     Aver/=Size; }
-
-   // average and RMS of a data series
-   static void AverRMS(Float &Aver, Float &RMS, Float *Data, int Size)
-   { Aver=0; RMS=0;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Aver+=Data[Idx]; }
-     Aver/=Size;
-     for(int Idx=0; Idx<Size; Idx++)
-     { Float Diff=Data[Idx]-Aver; RMS+=Diff*Diff; }
-     RMS=sqrt(RMS/Size); }
-
-   int ProcessChan(Float &AverPower, int LowBin, int UppBin, Float CenterBin, Float BinWidth, Float CenterFreq)
-   { int Slides = Power.Samples();
-     int Bins = Power.Len;
-     Aver.Allocate(1, Slides); Peak.Allocate(1, Slides); PeakPos.Allocate(1, Slides); Bkg.Allocate(1, Slides);
-     Float *Data = Power.Data;
-     for(int Idx=0; Idx<Slides; Idx++, Data+=Bins)
-     { AverPeakBkg(Aver[Idx], Peak[Idx], PeakPos[Idx], Bkg[Idx], Data+LowBin, UppBin-LowBin+1);
-       PeakPos[Idx]+=LowBin-CenterBin; }
-     Aver.Full=Slides; Peak.Full=Slides; PeakPos.Full=Slides; Bkg.Full=Slides;
-     Float PowerRMS; AverRMS(AverPower, PowerRMS, Aver.Data, Slides);
-     // printf("AverPower=%3.1f, PowerRMS=%3.1f\n", AverPower, PowerRMS);
-     if(PowerRMS>(0.5*AverPower)) return 0;          // skip pulsing channels
-
-     Float AverPeak, PeakRMS; AverRMS(AverPeak, PeakRMS, Peak.Data, Slides);
-     Float AverBkg, BkgRMS; AverRMS(AverBkg, BkgRMS, Bkg.Data, Slides);
-     // printf("AverPeak=%3.1f, PeakRMS=%3.1f, AverBkg=%5.3f, BkgRMS=%5.3f\n", AverPeak, PeakRMS, AverBkg, BkgRMS);
-
-     int Marks=0;
-     Float PeakThres = 4*PeakRMS;
-     Float BkgThres  = 4*BkgRMS;
-     for(int Idx=1; Idx<(Slides-1); Idx++)
-     { Float PeakL=Peak.Data[Idx-1]-AverPeak;
-       Float PeakM=Peak.Data[Idx  ]-AverPeak;
-       Float PeakR=Peak.Data[Idx+1]-AverPeak;
-       Float PeakSum = PeakL+PeakM+PeakR;
-       if(PeakSum<=PeakThres) continue;
-       if(PeakM<PeakL)  continue;
-       if(PeakM<=PeakR) continue;
-       if(PeakM<=((PeakL+PeakR)/2)) continue;
-       Float BkgSum = Bkg.Data[Idx-1]+Bkg.Data[Idx]+Bkg.Data[Idx+1];
-       if((3*AverBkg-BkgSum)<BkgThres) continue;
-       if(Peak.Data[Idx]<(40*Bkg.Data[Idx])) continue;
-       Float PPM = -1e6*(PeakPos.Data[Idx]*BinWidth-(Float)DataRate/4)/CenterFreq;
-       // printf("Mark: PeakSum[%5d]=%8.1f/%6.1f Bkg=%8.3f/%6.3f Peak/Bkg=%8.1f PeakPos=%+7.3f %+7.3fppm\n",
-       //         Idx, PeakSum, PeakThres, 3*AverBkg-BkgSum, BkgThres, Peak.Data[Idx]/Bkg.Data[Idx], PeakPos.Data[Idx], PPM);
-       PPM_Values.push_back(PPM);
-       Marks++; }
-
-     return Marks; }
-
-} ;
-
-// ==================================================================================================
-
-
-template <class Float>
- class HTTP_Server
-{ public:
-
-   int                 Port;      // listenning port
-   Thread              Thr;       // processing thread
-   RF_Acq             *RF;        // pointer to RF acquisition
-   GSM_FFT<Float>     *GSM;
-   char                Host[32];  // Host name
-
-  public:
-   HTTP_Server(RF_Acq *RF, GSM_FFT<Float> *GSM)
-   { this->RF=RF; this->GSM=GSM;
-     Host[0]=0; SocketAddress::getHostName(Host, 32);
-     Config_Defaults(); }
-
-   void Config_Defaults(void)
-   { Port=8080; }
-
-   int Config(config_t *Config)
-   { config_lookup_int(Config, "HTTP.Port", &Port); return 0; }
-
-   void Start(void)
-   { if(Port<=0) return;
-     Thr.setExec(ThreadExec); Thr.Create(this); }
-
-  ~HTTP_Server()
-   { if(Port) Thr.Cancel(); }
-
-   static void *ThreadExec(void *Context)
-   { HTTP_Server *This = (HTTP_Server *)Context; return This->Exec(); }
-
-   void *Exec(void)
-   { printf("HTTP_Server.Exec() ... Start\n");
-     while(1)
-     { Socket Listen;
-       if(Listen.Create_STREAM()<0) { printf("HTTP_Server.Exec() ... Cannot Create_STREAM()\n"); sleep(1); continue; }
-       if(Listen.setReuseAddress()<0) { printf("HTTP_Server.Exec() ... Cannot setReuseAddress()\n"); sleep(1); continue; }
-       if(Listen.Listen(Port)<0) { printf("HTTP_Server.Exec() ... Cannot listen() on port %d\n", Port); sleep(1); continue; }
-       printf("HTTP_Server.Exec() ... Listening on port %d\n", Port);
-       while(1)
-       { Socket *Client = new Socket; SocketAddress ClientAddress;
-         if(Listen.Accept(*Client, ClientAddress)<0) { printf("HTTP_Server.Exec() ... Cannot accept()\n"); sleep(1); break; }
-         printf("HTTP_Server.Exec() ... Client from %s\n", ClientAddress.getIPColonPort());
-         Client->setReceiveTimeout(2.0); Client->setSendTimeout(5.0); Client->setLinger(1, 5);
-         SocketBuffer Request; time_t ConnectTime; time(&ConnectTime);
-         while(1)
-         { if(Client->Receive(Request)<0) { printf("HTTP_Server.Exec() ... Cannot receive()\n"); Client->SendShutdown(); Client->Close(); delete Client; Client=0; break; }
-           if( Request.Len && strstr(Request.Data, "\r\n\r\n") ) break;
-           time_t Now; time(&Now);
-           if((Now-ConnectTime)>2) { printf("HTTP_Server.Exec() ... Request timeout\n"); Client->SendShutdown(); Client->Close(); delete Client; Client=0; break; }
-         }
-         if(Client)
-         { // printf("HTTP_Server.Exec() ... Request[%d]:\n", Request.Len); Request.WriteToFile(stdout); fflush(stdout);
-           ProcessRequest(Client, Request); }
-       }
-       Listen.Close();
-     }
-     printf("HTTP_Server.Exec() ... Stop\n");
-     return 0; }
-
-   int CopyWord(char *Dst, char *Src, int MaxLen)
-   { int Count=0; MaxLen-=1;
-     for( ; ; )
-     { char ch = (*Src++); if(ch<=' ') break;
-       if(Count>=MaxLen) return -1;
-       (*Dst++) = ch; Count++; }
-     (*Dst++)=0;
-     return Count; }
-
-   void ProcessRequest(Socket *Client, SocketBuffer &Request)
-   { if(memcmp(Request.Data, "GET ", 4)!=0) goto BadRequest;
-     char File[64]; if(CopyWord(File, Request.Data+4, 64)<0) goto BadRequest;
-     printf("HTTP_Server.Exec() ... Request for %s\n", File);
-
-          if(strcmp(File, "/")==0)
-     { Status(Client); return; }
-     else if( (strcmp(File, "/status.html")==0)         || (strcmp(File, "status.html")==0) )
-     { Status(Client); return; }
-     else if( (strcmp(File, "/gsm-spectrogram.jpg")==0) || (strcmp(File, "gsm-spectrogram.jpg")==0) )
-     { GSM->SpectrogramQueue.Push(Client); return; }
-     else if( (strcmp(File, "/time-slot-rf.u8")==0)  || (strcmp(File, "time-slot-rf.u8")==0) )
-     { RF->RawDataQueue.Push(Client); return; }
-     // NotFound:
-       Client->Send("HTTP/1.0 404 Not Found\r\n\r\n"); Client->SendShutdown(); Client->Close(); delete Client; return;
-
-     BadRequest:
-       Client->Send("HTTP/1.0 400 Bad Request\r\n\r\n"); Client->SendShutdown(); Client->Close(); delete Client; return;
-   }
-
-   void Status(Socket *Client)
-   { Client->Send("\
-HTTP/1.1 200 OK\r\n\
-Cache-Control: no-cache\r\n\
-Content-Type: text/html\r\n\
-Refresh: 5\r\n\
-\r\n\
-<!DOCTYPE html>\r\n\
-<html>\r\n\
-");
-     // time_t Now; time(&Now);
-     dprintf(Client->SocketFile, "\
-<title>RTLSDR-OGN RF processor " STR(VERSION) " status</title>\n\
-<b>RTLSDR OGN RF processor " STR(VERSION) "/"__DATE__"</b><br /><br />\n\n");
-
-     dprintf(Client->SocketFile, "<table>\n<tr><th>System</th><th></th></tr>\n");
-
-     dprintf(Client->SocketFile, "<tr><td>Host name</td><td align=right><b>%s</b></td></tr>\n", Host);
-     time_t Now; time(&Now);
-     struct tm TM; localtime_r(&Now, &TM);
-     dprintf(Client->SocketFile, "<tr><td>Local time</td><td align=right><b>%02d:%02d:%02d</b></td></tr>\n", TM.tm_hour, TM.tm_min, TM.tm_sec);
-     dprintf(Client->SocketFile, "<tr><td>Software</td><td align=right><b>" STR(VERSION) "</b></td></tr>\n");
-
-#ifndef __MACH__
-     struct sysinfo SysInfo;
-     if(sysinfo(&SysInfo)>=0)
-     { dprintf(Client->SocketFile, "<tr><td>CPU load</td><td align=right><b>%3.1f/%3.1f/%3.1f</b></td></tr>\n",
-                                   SysInfo.loads[0]/65536.0, SysInfo.loads[1]/65536.0, SysInfo.loads[2]/65536.0);
-       dprintf(Client->SocketFile, "<tr><td>RAM [free/total]</td><td align=right><b>%3.1f/%3.1f MB</b></td></tr>\n",
-                                   1e-6*SysInfo.freeram*SysInfo.mem_unit, 1e-6*SysInfo.totalram*SysInfo.mem_unit);
-     }
-#endif
-
-     float CPU_Temperature;
-     if(getCpuTemperature(CPU_Temperature)>=0)
-       dprintf(Client->SocketFile, "<tr><td>CPU temperature</td><td align=right><b>%+5.1f &#x2103;</b></td></tr>\n",    CPU_Temperature);
-     float SupplyVoltage;
-     if(getSupplyVoltage(SupplyVoltage)>=0)
-       dprintf(Client->SocketFile, "<tr><td>Supply voltage</td><td align=right><b>%5.3f V</b></td></tr>\n",    SupplyVoltage);
-     float SupplyCurrent;
-     if(getSupplyCurrent(SupplyCurrent)>=0)
-       dprintf(Client->SocketFile, "<tr><td>Supply current</td><td align=right><b>%5.3f A</b></td></tr>\n",    SupplyCurrent);
-
-     double NtpTime, EstError, RefFreqCorr;
-     if(getNTP(NtpTime, EstError, RefFreqCorr)>=0)
-     { time_t Time = floor(NtpTime);
-       struct tm TM; gmtime_r(&Time, &TM);
-       dprintf(Client->SocketFile, "<tr><td>NTP UTC time</td><td align=right><b>%02d:%02d:%02d</b></td></tr>\n", TM.tm_hour, TM.tm_min, TM.tm_sec);
-       dprintf(Client->SocketFile, "<tr><td>NTP est. error</td><td align=right><b>%3.1f ms</b></td></tr>\n", 1e3*EstError);
-       dprintf(Client->SocketFile, "<tr><td>NTP freq. corr.</td><td align=right><b>%+5.2f ppm</b></td></tr>\n", RefFreqCorr);
-     }
-
-     if(RF->SDR.isOpen())
-     { dprintf(Client->SocketFile, "<tr><th>RTL-SDR device #%d</th><th></th></tr>\n",                                  RF->SDR.DeviceIndex);
-       dprintf(Client->SocketFile, "<tr><td>Name</td><td align=right><b>%s</b></td></tr>\n",                           RF->SDR.getDeviceName());
-       dprintf(Client->SocketFile, "<tr><td>Tuner type</td><td align=right><b>%s</b></td></tr>\n",                     RF->SDR.getTunerTypeName());
-       char Manuf[256], Product[256], Serial[256];
-       RF->SDR.getUsbStrings(Manuf, Product, Serial);
-       dprintf(Client->SocketFile, "<tr><td>Manufacturer</td><td align=right><b>%s</b></td></tr>\n",                    Manuf);
-       dprintf(Client->SocketFile, "<tr><td>Product</td><td align=right><b>%s</b></td></tr>\n",                         Product);
-       dprintf(Client->SocketFile, "<tr><td>Serial</td><td align=right><b>%s</b></td></tr>\n",                          Serial);
-#ifdef NEW_RTLSDR_LIB
-       for(int Stage=0; Stage<8; Stage++)
-       { char Descr[256]; int Gains=RF->SDR.getTunerStageGains(Stage, 0, Descr); if(Gains<=0) break;
-         dprintf(Client->SocketFile, "<tr><td>Tuner stage #%d</td><td align=right><b>%s [%2d]</b></td></tr>\n",  Stage, Descr, Gains);
-       }
-       dprintf(Client->SocketFile, "<tr><td>Tuner bandwidths</td><td align=right><b>[%d]</b></td></tr>\n",             RF->SDR.getTunerBandwidths());
-       dprintf(Client->SocketFile, "<tr><td>Tuner gains</td><td align=right><b>[%d]</b></td></tr>\n",                  RF->SDR.getTunerGains());
-#endif
-       dprintf(Client->SocketFile, "<tr><td>Center frequency</td><td align=right><b>%7.3f MHz</b></td></tr>\n",        1e-6*RF->SDR.getCenterFreq());
-       dprintf(Client->SocketFile, "<tr><td>Sample rate</td><td align=right><b>%5.3f MHz</b></td></tr>\n",             1e-6*RF->SDR.getSampleRate());
-       dprintf(Client->SocketFile, "<tr><td>Frequency correction</td><td align=right><b>%+5.1f ppm</b></td></tr>\n",   RF->FreqCorr + RF->GSM_FreqCorr);
-       uint32_t RtlFreq, TunerFreq; RF->SDR.getXtalFreq(RtlFreq, TunerFreq);
-       dprintf(Client->SocketFile, "<tr><td>RTL Xtal</td><td align=right><b>%8.6f MHz</b></td></tr>\n",    1e-6*RtlFreq);
-       dprintf(Client->SocketFile, "<tr><td>Tuner Xtal</td><td align=right><b>%8.6f MHz</b></td></tr>\n",  1e-6*TunerFreq);
-/*
-       dprintf(Client->SocketFile, "<tr><td>Gain[%d]</td><td align=right><b>", RF->SDR.Gains);
-       for(int Idx=0; Idx<RF->SDR.Gains; Idx++)
-       { dprintf(Client->SocketFile, "%c%3.1f", Idx?',':' ', 0.1*RF->SDR.Gain[Idx]);
-       }
-       dprintf(Client->SocketFile, " [dB]</b></td></tr>\n");
-*/
-     }
-
-     dprintf(Client->SocketFile, "<tr><th>RF</th><th></th></tr>\n");
-     dprintf(Client->SocketFile, "<tr><td>RF.Device</td><td align=right><b>%d</b></td></tr>\n",                       RF->DeviceIndex);
-     if(RF->DeviceSerial[0])
-       dprintf(Client->SocketFile, "<tr><td>RF.DeviceSerial</td><td align=right><b>%s</b></td></tr>\n",               RF->DeviceSerial);
-     dprintf(Client->SocketFile, "<tr><td>RF.SampleRate</td><td align=right><b>%3.1f MHz</b></td></tr>\n",       1e-6*RF->SampleRate);
-     // dprintf(Client->SocketFile, "<tr><td>RF.PipeName</td><td align=right><b>%s</b></td></tr>\n",                  ??->OutPipeName );
-     dprintf(Client->SocketFile, "<tr><td>RF.FreqCorr</td><td align=right><b>%+3d ppm</b></td></tr>\n",               RF->FreqCorr);
-     dprintf(Client->SocketFile, "<tr><td>RF.BiasTee</td><td align=right><b>%d</b></td></tr>\n",                      RF->BiasTee);
-     dprintf(Client->SocketFile, "<tr><td>RF.OffsetTuning</td><td align=right><b>%d</b></td></tr>\n",                 RF->OffsetTuning);
-     dprintf(Client->SocketFile, "<tr><td>Fine calib. FreqCorr</td><td align=right><b>%+5.1f ppm</b></td></tr>\n",    RF->GSM_FreqCorr);
-     dprintf(Client->SocketFile, "<tr><td>RF.PulseFilter.Threshold</td><td align=right><b>%d</b></td></tr>\n",        RF->PulseFilt.Threshold);
-     dprintf(Client->SocketFile, "<tr><td>RF.PulseFilter duty</td><td align=right><b>%5.1f ppm</b></td></tr>\n",    1e6*RF->PulseFilt.Duty);
-     // dprintf(Client->SocketFile, "<tr><td>RF.ToneFilter.Enable</td><td align=right><b>%d</b></td></tr>\n",                  FFT->Filter->Enable);
-     // dprintf(Client->SocketFile, "<tr><td>RF.ToneFilter.FFTsize</td><td align=right><b>%d</b></td></tr>\n",                 FFT->Filter->FFTsize);
-     // dprintf(Client->SocketFile, "<tr><td>RF.ToneFilter.Threshold</td><td align=right><b>%3.1f</b></td></tr>\n",            FFT->Filter->Threshold);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.GainMode</td><td align=right><b>%d</b></td></tr>\n",                 RF->OGN_GainMode);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.Gain</td><td align=right><b>%4.1f dB</b></td></tr>\n",           0.1*RF->OGN_Gain);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.CenterFreq</td><td align=right><b>%5.1f MHz</b></td></tr>\n",   1e-6*RF->OGN_CenterFreq);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.FreqHopChannels</td><td align=right><b>%d</b></td></tr>\n",          RF->OGN_FreqHopChannels);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.StartTime</td><td align=right><b>%5.3f sec</b></td></tr>\n",         RF->OGN_StartTime);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.SensTime</td><td align=right><b>%5.3f sec</b></td></tr>\n", (double)(RF->OGN_SamplesPerRead)/RF->SampleRate);
-     dprintf(Client->SocketFile, "<tr><td>RF.OGN.SaveRawData</td><td align=right><b>%d sec</b></td></tr>\n", RF->OGN_SaveRawData);
-     dprintf(Client->SocketFile, "<tr><td>RF.GSM.CenterFreq</td><td align=right><b>%5.1f MHz</b></td></tr>\n",   1e-6*RF->GSM_CenterFreq);
-     dprintf(Client->SocketFile, "<tr><td>RF.GSM.Gain</td><td align=right><b>%4.1f dB</b></td></tr>\n",           0.1*RF->GSM_Gain);
-     dprintf(Client->SocketFile, "<tr><td>RF.GSM.SensTime</td><td align=right><b>%5.3f sec</b></td></tr>\n", (double)(RF->GSM_SamplesPerRead)/RF->SampleRate);
-
-
-     dprintf(Client->SocketFile, "</table>\n");
-
-     Client->Send("\
-<br />\r\n\
-RF spectrograms:\r\n\
-<a href='gsm-spectrogram.jpg'>GSM frequency calibration</a><br />\r\n\
-<br /><br />\r\n\
-<a href='time-slot-rf.u8'>RF raw data</a> of a time-slot (8-bit unsigned I/Q) - a 2 MB binary file !<br />\r\n\
-");
-
-     Client->Send("</html>\r\n");
-     Client->SendShutdown(); Client->Close(); delete Client; }
-
-} ;
-
-// ==================================================================================================
-
-  RF_Acq             RF;                         // RF input: acquires RF data for OGN and selected GSM frequency
-
-  Inp_Filter<float>  Filter(&RF);                // Coherent interference filter
-
-  Inp_FFT<float>     FFT(&RF, &Filter);          // FFT for OGN demodulator
-  GSM_FFT<float>     GSM(&RF);                   // GSM frequency calibration
-
-  HTTP_Server<float> HTTP(&RF, &GSM);            // HTTP server to show status and spectrograms
-
-void SigHandler(int signum) // Signal handler, when user pressed Ctrl-C or process stops for whatever reason
-{ RF.StopReq=1; }
-
-// ----------------------------------------------------------------------------------------------------
-
-int SetUserValue(const char *Name, float Value)
-{ // printf("%s = %f\n", Name, Value);
-  if(strcmp(Name, "RF.FreqCorr")==0)
-  { RF.FreqCorr=(int)floor(Value+0.5);
-    printf("RF.FreqCorr=%+d ppm\n", RF.FreqCorr);
-    return 1; }
-  if(strcmp(Name, "RF.OGN.Gain")==0)
-  { RF.OGN_Gain=(int)floor(10*Value+0.5);
-    printf("RF.OGN.Gain=%3.1f dB\n", 0.1*RF.OGN_Gain);
-    return 1; }
-  if(strcmp(Name, "RF.OGN.GainMode")==0)
-  { RF.OGN_GainMode=(int)floor(Value+0.5);
-    printf("RF.OGN.GainMode=%d\n", RF.OGN_GainMode);
-    return 1; }
-  if(strcmp(Name, "RF.OGN.SaveRawData")==0)
-  { RF.OGN_SaveRawData=(int)floor(Value+0.5);
-    printf("RF.OGN.SaveRawData=%d\n", RF.OGN_SaveRawData);
-    return 1; }
-  if(strcmp(Name, "RF.GSM.Gain")==0)
-  { RF.GSM_Gain=(int)floor(10*Value+0.5);
-    printf("RF.GSM.Gain=%3.1f dB\n", 0.1*RF.GSM_Gain);
-    return 1; }
-  if(strcmp(Name, "RF.OGN.CenterFreq")==0)
-  { RF.OGN_CenterFreq=(int)floor(1e6*Value+0.5);
-    printf("RF.OGN.CenterFreq=%7.3f MHz\n", 1e-6*RF.OGN_CenterFreq);
-    return 1; }
-  if(strcmp(Name, "RF.GSM.CenterFreq")==0)
-  { RF.GSM_CenterFreq=(int)floor(1e6*Value+0.5);
-    printf("RF.GSM.CenterFreq=%7.3f MHz\n", 1e-6*RF.GSM_CenterFreq);
-    return 1; }
-  if(strcmp(Name, "RF.OGN.FreqHopChannels")==0)
-  { RF.OGN_FreqHopChannels=(int)floor(Value+0.5);
-    printf("RF.OGN_FreqHopChannels=%d\n", RF.OGN_FreqHopChannels);
-    return 1; }
-  if(strcmp(Name, "RF.PulseFilter.Threshold")==0)
-  { RF.PulseFilt.Threshold=(int)floor(Value+0.5);
-    printf("RF.PulseFilter.Threshold=%d\n", RF.PulseFilt.Threshold);
-    return 1; }
-  return 0; }
-
-int PrintUserValues(void)
-{ printf("Settable parameters:\n");
-  printf("RF.FreqCorr=%+d(%+3.1f) ppm\n",      RF.FreqCorr, RF.GSM_FreqCorr);
-  printf("RF.PulseFilter.Threshold=%d",        RF.PulseFilt.Threshold);
-  if(RF.PulseFilt.Threshold) printf(" .Duty=%3.1fppm", 1e6*RF.PulseFilt.Duty);
-  printf("\n");
-  printf("RF.OGN.CenterFreq=%7.3f MHz\n", 1e-6*RF.OGN_CenterFreq);
-  printf("RF.OGN_FreqHopChannels=%d\n",        RF.OGN_FreqHopChannels);
-  printf("RF.OGN.Gain=%3.1f dB\n",         0.1*RF.OGN_Gain);
-  printf("RF.OGN.GainMode=%d\n",               RF.OGN_GainMode);
-  printf("RF.OGN.SaveRawData=%d\n",            RF.OGN_SaveRawData);
-  printf("RF.GSM.CenterFreq=%7.3f MHz\n", 1e-6*RF.GSM_CenterFreq);
-  printf("RF.GSM.Gain=%3.1f dB\n",         0.1*RF.GSM_Gain);
-  return 0; }
-
-int UserCommand(char *Cmd)
-{ if(strchr(Cmd, '\n')==0) return 0;
-  char *Equal = strchr(Cmd, '=');
-  // printf("User command: %s", Cmd);
-  if(Equal)
-  { Equal[0]=0; const char *ValuePtr=Equal+1;
-    char *Name=Cmd;
-    for( ; ; )
-    { char ch=Name[0]; if(ch==0) break;
-      if(ch>' ') break;
-      Name++; }
-    for( ; ; )
-    { Equal--;
-      char ch=Equal[0]; if(ch==0) break;
-      if(ch>' ') break;
-      Equal[0]=0; }
-    float Value;
-    if(sscanf(ValuePtr, "%f", &Value)==1) SetUserValue(Name, Value);
-  }
-  PrintUserValues();
-  return 0; }
-
-// ----------------------------------------------------------------------------------------------------
-
-int main(int argc, char *argv[])
-{
-  const char *ConfigFileName = "rtlsdr-ogn.conf";
-  if(argc>1) ConfigFileName = argv[1];
-
-  config_t Config;
-  config_init(&Config);
-  if(config_read_file(&Config, ConfigFileName)==CONFIG_FALSE)
-  { printf("Could not read %s as configuration file\n", ConfigFileName); config_destroy(&Config); return -1; }
-
-  struct sigaction SigAction;
-  SigAction.sa_handler = SigHandler;              // setup the signal handler (for Ctrl-C or when process is stopped)
-  sigemptyset(&SigAction.sa_mask);
-  SigAction.sa_flags = 0;
-
-  struct sigaction SigIgnore;
-  SigIgnore.sa_handler = SIG_IGN;
-  sigemptyset(&SigIgnore.sa_mask);
-  SigIgnore.sa_flags = 0;
-
-  sigaction(SIGINT,  &SigAction, 0);
-  sigaction(SIGTERM, &SigAction, 0);
-  sigaction(SIGQUIT, &SigAction, 0);
-  sigaction(SIGPIPE, &SigIgnore, 0);              // we want to ignore pipe/fifo read/write errors, we handle them by return codes
-
-  RF.Config_Defaults();
-  RF.Config(&Config);
-
-  Filter.Config_Defaults();
-  Filter.Config(&Config);
-  if(Filter.Enable) Filter.Preset();
-
-  FFT.Config_Defaults();
-  FFT.Config(&Config);
-  FFT.Preset();
-
-  GSM.Preset();
-
-  HTTP.Config_Defaults();
-  HTTP.Config(&Config);
-  HTTP.Start();
-
-  config_destroy(&Config);
-
-  if(Filter.Enable) Filter.Start();
-  FFT.Start();
-  GSM.Start();
-  RF.Start();
-
-  char Cmd[128];
-  while(!RF.StopReq)
-  { if(fgets(Cmd, 128, stdin)==0) break;
-    UserCommand(Cmd); }
-
-  sleep(4);
-  RF.Stop();
-
-  return 0; }
-
-
diff --git a/pulsefilter.h b/pulsefilter.h
deleted file mode 100644
index 964c9a7..0000000
--- a/pulsefilter.h
+++ /dev/null
@@ -1,69 +0,0 @@
-#include <stdint.h>
-
-#include "buffer.h"
-#include "boxfilter.h"
-
-class PulseFilter
-{ public:
-   int Threshold;                                        // apply pulse filter to the the RF samples to remove wideband pulses like radar
-   const static int PulseBoxRadius = 33;
-   const static int PulseBoxSize = 2*PulseBoxRadius+1;
-   BoxPeakSum<int32_t> PulseBox;
-   int Pulses;
-   float Duty;
-
-  public:
-   PulseFilter() { PulseBox.Preset(PulseBoxSize); Threshold=0; Pulses=0; Duty=0; }
-
-   int Process(SampleBuffer<uint8_t> &Buffer, uint8_t Bias=127)
-   { PulseBox.Clear(); Pulses=0;
-     if(Threshold<=0) return 0;
-     int Samples = Buffer.Samples();
-     if(Samples<PulseBoxSize) return 0;
-     // printf("PulseFilter::Process(Buffer[%d]) (%d)\n", Samples, Threshold);
-     uint8_t *Data = Buffer.Data;
-     int Idx;
-     for(Idx=0; Idx<(2*PulseBoxSize); Idx+=2)
-     { int32_t I = Data[Idx  ]-Bias;
-       int32_t Q = Data[Idx+1]-Bias;
-       int32_t Pwr = I*I + Q*Q;
-       PulseBox.Process(Pwr); }
-     for(    ; Idx<(2*Samples); Idx+=2)
-     { int32_t I = Data[Idx  ]-Bias;
-       int32_t Q = Data[Idx+1]-Bias;
-       int32_t Pwr = I*I + Q*Q;
-       PulseBox.Process(Pwr);
-       if(PulseBox.isAtPeak())
-       { int32_t PeakAmpl = PulseBox.PeakSum(1);
-         int32_t BkgNoise = (PulseBox.Sum-PeakAmpl)/(PulseBoxSize-3);
-         if(PeakAmpl>(Threshold*BkgNoise))
-         { // printf("PulseFilter::Process() %06d: %4d+%4d+%4d+%4d+%4d=%5d/%2d\n",
-           //         Idx/2, PulseBox.AtPeak(-2), PulseBox.AtPeak(-1), PulseBox.AtPeak(0), PulseBox.AtPeak(1), PulseBox.AtPeak(2), PeakAmpl, BkgNoise);
-           int32_t Thres = PeakAmpl/2;
-           int PeakIdx = Idx-2*PulseBoxRadius;
-           // printf("PulseFilter::Process() [%+3d,%+3d] [%+3d,%+3d] [%+3d,%+3d]\n", Data[PeakIdx-2]-Bias, Data[PeakIdx-1]-Bias, Data[PeakIdx]-Bias, Data[PeakIdx+1]-Bias, Data[PeakIdx+2]-Bias, Data[PeakIdx+3]-Bias);
-           SetZero(Data+PeakIdx, Bias);
-           if(PulseBox.AtPeak(-1)>Thres)
-           { SetZero(Data+(PeakIdx-2), Bias); SetHalf(Data+(PeakIdx-4), Bias); }
-           else SetHalf(Data+(PeakIdx-2), Bias);
-           if(PulseBox.AtPeak( 1)>Thres)
-           { SetZero(Data+(PeakIdx+2), Bias); SetHalf(Data+(PeakIdx+4), Bias); }
-           else SetHalf(Data+(PeakIdx+2), Bias);
-           // printf("PulseFilter::Process() [%+3d,%+3d] [%+3d,%+3d] [%+3d,%+3d]\n", Data[PeakIdx-2]-Bias, Data[PeakIdx-1]-Bias, Data[PeakIdx]-Bias, Data[PeakIdx+1]-Bias, Data[PeakIdx+2]-Bias, Data[PeakIdx+3]-Bias);
-           Pulses++; }
-       }
-     }
-     // printf("PulseFilter::Process(Buffer[%d]) (%d)  => %d pulses\n", Samples, Threshold, Pulses);
-     Duty = (float)Pulses/Samples;
-     return Pulses; }
-
-   static void SetZero(uint8_t *Data, uint8_t Bias=127)
-   { Data[0]=Bias; Data[1]=Bias; }
-
-   static void SetHalf(uint8_t *Data, uint8_t Bias=127)
-   { int8_t I = Data[0]-Bias; Data[0] = Bias + (I>>1);
-     int8_t Q = Data[1]-Bias; Data[1] = Bias + (Q>>1); }
-
-} ;
-
-
diff --git a/r2fft.h b/r2fft.h
deleted file mode 100644
index 0c6d43a..0000000
--- a/r2fft.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __R2FFT_H__
-#define __R2FFT_H__
-
-#include <stdint.h>
-#include <math.h>
-#include <complex>
-#include <new>
-
-template <class Float>
- class r2FFT // radix-2 FFT
-{ public:    // size must a power of 2: 2,4,8,16,32,64,128,256,...
-
-   int                  Size;          // FFT size (needs to be power of 2)
-   int                 *BitRevIdx;     // Bit-reverse indexing table for data (un)scrambling
-   std::complex<Float> *Twiddle;       // Twiddle factors (sine/cos values)
-
-   r2FFT(int MaxSize)
-   { BitRevIdx=0; Twiddle=0; Preset(MaxSize); }
-
-   r2FFT()
-   { BitRevIdx=0; Twiddle=0; Size=0; }
-
-   ~r2FFT()
-   { Free(); }
-
-   void Free(void)
-   { delete [] BitRevIdx; BitRevIdx=0;
-     delete [] Twiddle; Twiddle=0; 
-     Size=0; }
-
-   // preset tables for given (maximum) processing size
-   int Preset(int MaxSize)
-   { Free();
-     if(MaxSize<4) { return 0; }
-     Size=MaxSize;
-     while((MaxSize&1)==0) MaxSize>>=1;
-     if(MaxSize!=1) { Size=0; return 0; }
-     BitRevIdx = new (std::nothrow) int                 [Size]; if(BitRevIdx==0) { Free(); return 0; }
-     Twiddle   = new (std::nothrow) std::complex<Float> [Size]; if(Twiddle==0)   { Free(); return 0; }
-     // int Size4=Size/4;
-     int Idx, rIdx, Mask, rMask;
-     for(Idx=0; Idx<Size; Idx++)
-     { double Phase=(2*M_PI*Idx)/Size;
-       Twiddle[Idx] = std::complex<Float> ( cos(Phase), -sin(Phase) ); }
-     // for(     ; Idx<Size; Idx++)
-     // { Twiddle[Idx].Re=(-Twiddle[Idx-Size4].Im);
-     //   Twiddle[Idx].Im=  Twiddle[Idx-Size4].Re ; }
-     for(rIdx=0, Idx=0; Idx<Size; Idx++)
-     { for(rIdx=0, Mask=Size/2,rMask=1; Mask; Mask>>=1,rMask<<=1)
-       { if(Idx&Mask) rIdx|=rMask; }
-       BitRevIdx[Idx]=rIdx; }
-     return Size; }
-
-   // scramble/unscramble (I)FFT input
-   template <class Type>
-    void Scramble(Type Data[])
-     { for(int Idx=0; Idx<Size; Idx++)
-       { int rIdx=BitRevIdx[Idx];
-         if(rIdx>Idx)
-         { Type Tmp=Data[Idx]; Data[Idx]=Data[rIdx]; Data[rIdx]=Tmp; }
-       }
-     }
-
-   template <class Type>
-    void Scramble(Type Data[], int ShrinkShift)
-     { int Len=Size>>ShrinkShift;
-       for(int Idx=0; Idx<Len; Idx++)
-       { int rIdx=BitRevIdx[Idx]>>=ShrinkShift;
-         if(rIdx>Idx)
-         { Type Tmp=Data[Idx]; Data[Idx]=Data[rIdx]; Data[rIdx]=Tmp; }
-       }
-     }
-
-   // core process: the classic tripple loop of butterflies
-   // radix-2 FFT: the first and the second pass are by hand
-   // looks like there is no gain by separating the second pass
-   // and even the first pass is in question ?
-   template <class Type>
-    void CoreProc(std::complex<Type> Data[])
-     { int Groups,GroupSize2,Group,Bf,TwidIdx;
-       int Size2=Size/2;
-       for(Bf=0; Bf<Size; Bf+=2) FFT2(Data[Bf],Data[Bf+1]); // first pass
-       // for(Bf=0; Bf<Size; Bf+=4) FFT4(Data[Bf], Data[Bf+1], Data[Bf+2], Data[Bf+3]); // second
-       // for(Groups=Size2/4,GroupSize2=4; Groups; Groups>>=1, GroupSize2<<=1)
-       for(Groups=Size2/2,GroupSize2=2; Groups; Groups>>=1, GroupSize2<<=1)
-         for(Group=0,Bf=0; Group<Groups; Group++,Bf+=GroupSize2)
-           for(TwidIdx=0; TwidIdx<Size2; TwidIdx+=Groups,Bf++)
-           { FFTbf(Data[Bf],Data[Bf+GroupSize2],Twiddle[TwidIdx]); }
-     }
-
-   // radix-2 FFT with a "shrink" factor
-   template <class Type>
-    void CoreProc(std::complex<Type> Data[], int ShrinkShift)
-     { int Groups,GroupSize2,Group,Bf,TwidIdx,TwidIncr;
-       int Len=Size>>ShrinkShift;
-       int Size2=Size/2;
-       int Len2=Len/2;
-       for(Bf=0; Bf<Len; Bf+=2) FFT2(Data[Bf],Data[Bf+1]); // first pass
-       // for(Bf=0; Bf<Len; Bf+=4) FFT4(Data[Bf],Data[Bf+1],Data[Bf+2],Data[Bf+3]); // second
-       for(Groups=Len2/2,TwidIncr=Size2/2,GroupSize2=2;
-           Groups;
-           Groups>>=1, TwidIncr>>=1, GroupSize2<<=1)
-         for(Group=0,Bf=0; Group<Groups; Group++,Bf+=GroupSize2)
-           for(TwidIdx=0; TwidIdx<Size2; TwidIdx+=TwidIncr,Bf++)
-           { FFTbf(Data[Bf],Data[Bf+GroupSize2],Twiddle[TwidIdx]); }
-     }
-
-   // complex FFT process in place, includes unscrambling
-   template <class Type>
-    int Process(std::complex<Type> Data[])
-     { Scramble(Data); CoreProc(Data); return 0; }
-
-   // find the "shrink" factor for processing batches smaller than declared by Preset()
-   int FindShrinkShift(int Len)
-     { int Shift;
-       for(Shift=0; Len<Size; Shift++)
-         Len<<=1;
-       if (Len!=Size) return -1;
-       return Shift; }
-
-   // process data with length smaller than requested by Preset() (but still a power of 2)
-   template <class Type>
-    int Process(std::complex<Type> Data[], int Len)
-     { if(Len<4) return -1;
-       if(Len==Size) { Scramble(Data); CoreProc(Data); return 0; }
-       int ShrinkShift=FindShrinkShift(Len); if(ShrinkShift<0) return -1;
-       Scramble(Data,ShrinkShift); CoreProc(Data,ShrinkShift); return 0; }
-
-   // classic radix-2 butterflies
-   template <class Type>
-    inline void FFTbf(std::complex<Type> &x0, std::complex<Type> &x1, std::complex<Float> &W)
-     { std::complex<Float> x1W;
-       x1W = x1 * W;
-       x1 = x0 - x1W;
-       x0 = x0 + x1W; }
-
-   // special 2-point FFT for the first pass
-   template <class Type>
-    inline void FFT2(std::complex<Type> &x0, std::complex<Type> &x1)
-     { std::complex<Type> x1W;
-       x1W = x1;
-       x1 = x0 - x1;
-       x0 += x1W; }
-/*
-   // special 4-point FFT for the second pass
-   template <class Type>
-    inline void FFT4(std::complex<Type> &x0, std::complex<Type> &x1, std::complex<Type> &x2, std::complex<Type> &x3)
-     { Type x1W;
-       x1W.Re=x2.Re;
-       x1W.Im=x2.Im;
-       x2.Re=x0.Re-x1W.Re;
-       x2.Im=x0.Im-x1W.Im;
-       x0.Re=x0.Re+x1W.Re;
-       x0.Im=x0.Im+x1W.Im;
-       x1W.Re=x3.Im;
-       x1W.Im=(-x3.Re);
-       x3.Re=x1.Re-x1W.Re;
-       x3.Im=x1.Im-x1W.Im;
-       x1.Re=x1.Re+x1W.Re;
-       x1.Im=x1.Im+x1W.Im; }
-*/
-  template <class Type>
-   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
-  { for(int Idx=0; Idx<WindowSize; Idx++)
-    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
-  }
-
-
-} ;
-
-#endif // __R2FFT_H__
diff --git a/r2fft_test.cc b/r2fft_test.cc
deleted file mode 100644
index 337e401..0000000
--- a/r2fft_test.cc
+++ /dev/null
@@ -1,52 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "r2fft.h"
-#include "fft.h"
-
-#define Float double
-
-template <class Type>
- double Power(std::complex<Type> X)
-{ return real(X)*real(X)+imag(X)*imag(X); }
-
-int main(int argc, char *argv[])
-{
-  r2FFT<Float> FFT;
-  DFT1d<Float> RefFFT;
-
-  int FFTsize = 1024;
-  std::complex<Float> Buffer[FFTsize];
-
-  FFT.Preset(FFTsize);
-  RefFFT.PresetForward(FFTsize);
-
-  srand(123456);
-  for(int Idx=0; Idx<FFTsize; Idx++)
-  { Buffer[Idx] = std::complex<Float>((rand()&3)-1.5, (rand()&3)-1.5 );
-    RefFFT.Buffer[Idx]=Buffer[Idx]; }
-
-  FFT.Process(Buffer);
-  RefFFT.Execute();
-
-  double AverPower=0;
-  for(int Idx=0; Idx<FFTsize; Idx++)
-  { AverPower += Power(Buffer[Idx]); }
-  AverPower/=FFTsize;
-  printf("FFT: <Power> = %8.3f\n", AverPower);
-
-  double RefAverPower=0;
-  for(int Idx=0; Idx<FFTsize; Idx++)
-  { RefAverPower += Power(RefFFT.Buffer[Idx]); }
-  RefAverPower/=FFTsize;
-  printf("RefFFT: <Power> = %8.3f\n", AverPower);
-
-  double DiffAverPower=0;
-  for(int Idx=0; Idx<FFTsize; Idx++)
-  { DiffAverPower += Power(Buffer[Idx]-RefFFT.Buffer[Idx]); }
-  DiffAverPower/=FFTsize;
-  printf("FFT-RefFFT: <Power> = %8.3f\n", DiffAverPower);
-
-  return 0; }
-
-
diff --git a/rtlsdr-ogn b/rtlsdr-ogn
deleted file mode 100755
index b4ecc0d..0000000
--- a/rtlsdr-ogn
+++ /dev/null
@@ -1,245 +0,0 @@
-#!/bin/bash
-### BEGIN INIT INFO
-# Provides:          rtlsdr-ogn
-# Required-Start:    $all
-# Required-Stop:
-# Default-Start:     2 3 4 5
-# Default-Stop:      0 1 6
-# Short-Description: OGN receiver
-# Description:       OGN receiver - Open Glider Network - http://glidernet.org/
-### END INIT INFO
-
-# chkconfig: 2345 98 2
-# description: shellbox service for spawning programs
-
-export PATH=$PATH:/usr/local/bin
-
-export HOSTNAME=$(hostname -s)
-
-exe=/usr/bin/procServ
-options="-k ^X --killsig 15 -x ^C -i ^D -c"
-prog=rtlsdr-ogn
-params=
-conf=/etc/rtlsdr-ogn.conf
-logdir=/var/log/$prog
-shells=/var/run/$prog
-chroot=/mnt/ramdisk
-
-if [ -d $chroot ]
-then
-  CHROOT="chroot $chroot"
-fi
-
-fail () {
-  echo $@
-  exit 1
-}
-
-echo_failure () {
-  echo " [failed]"
-}
-
-checkpid () {
-  [ -d /proc/$PID ] 
-}
-
-launch () {
-  if [ "$1" = "-reload" ]
-  then
-    reload=YES
-    shift
-  fi
-  temp=$(mktemp -p $(dirname $shells)) || fail "can't create temporary file"
-  while read PORT USER DIR COMMAND
-  do
-    # check for empty lines and comments
-    [[ $PORT == "" || $PORT == \#* ]] && continue
-    # check if already started shell is still alive
-    if LINE=$(grep "$PORT $USER $DIR $COMMAND" $shells 2> /dev/null)
-    then
-      PID=${LINE%% *}
-      if checkpid $PID
-      then
-        if [ -z "$reload" ] && [ -z "$*" ] || echo "$*" | grep -qE "(^|[[:space:]])$PORT([[:space:]]|$)"
-        then
-          echo "Already running: $PORT $USER $DIR $COMMAND"
-        fi
-        echo "$LINE" >> $temp
-        continue
-      fi
-    fi
-
-    # check if we have to start all shells or only this PORT
-    [ "$*" ] && echo "$*" | grep -qvE "(^|[[:space:]])$PORT([[:space:]]|$)" && continue
-
-    if [ -n "$logdir" ]
-    then
-      [ -d $logdir ] || mkdir -m 777 $logdir
-      LOG=$logdir/$PORT
-      rm -f $LOG
-    else
-      LOG=/dev/null
-    fi
-
-    # Wait for time to be sync before launching
-    while true; do /usr/sbin/ntp-wait -v;  if [ $? -eq 0 ]; then break; fi; sleep 2; done
-
-    # start shellbox as other user
-    echo -n Starting: $PORT $USER $DIR $COMMAND
-    export SHELLBOX=$HOSTNAME:$PORT
-    #pidfile=/var/run/procServ-$PORT.pid
-    pidfile=/tmp/procServ-$PORT.pid
-    rm -f $pidfile
-#    $exe -p $pidfile $options $DIR $params $PORT $COMMAND >> $LOG 2>&1 < /dev/null
-    $CHROOT su $USER -c "$exe -p $pidfile $options $DIR $params $PORT $COMMAND >> $LOG 2>&1 < /dev/null"
-    # check if starting worked or failed
-    sleep 1
-    if [ -e $pidfile ]
-    then
-      PID=$(<$pidfile)
-      echo "$PID $PORT $USER $DIR $COMMAND" >> $temp
-      echo
-    else
-      echo_failure
-      echo
-      cat $LOG
-    fi
-  done < $conf
-  mv $temp $shells
-  chmod 0644 $shells
-}
-
-start () {
-  [ -r $conf ] || fail "$conf not readable"
-  [ -x $exe ] || fail "$exe is not executable"
-  launch $*
-  touch /var/lock/$prog
-}
-
-stopshell() {
-  PID=$1
-  PORT=$2
-  shift
-  echo -n Stopping: $*
-  kill $PID 2> /dev/null || echo_failure
-  echo
-  if [ $logdir ]
-  then
-      echo -e "\n**** stopped ****" >> $logdir/$PORT
-  fi
-}
-
-stop () {
-  # anything to stop?
-  if [ ! -r $shells ]
-  then
-    echo "$prog: No shells started."
-    exit 0
-  fi
-  if [ -z "$1" ]
-  then
-    # kill all shellboxes
-    while read PID PORT ARGS
-    do
-      stopshell $PID $PORT $ARGS
-    done < $shells
-    rm -f $shells
-    rm -f /var/lock/$prog
-  else
-    # kill only selected shellboxes
-    temp=$(mktemp -p $(dirname $shells)) || fail "can't create temporary file"
-    while read PID PORT ARGS
-    do
-      echo "$*" | grep -qE "(^|[[:space:]])$PORT([[:space:]]|$)" && stopshell $PID $PORT $ARGS || echo "$PID $PORT $ARGS" >> $temp
-    done < $shells
-    mv $temp $shells
-    chmod 0644 $shells
-  fi
-}
-
-reload () {
-  echo "Reloading $conf: "
-  [ -r $conf ] || fail "not readable"
-  # anything to stop?
-  if [ -r $shells ]
-  then
-    #first kill all shells that are not configured any more
-    temp=$(mktemp -p $(dirname $shells)) || fail "can't create temporary file"
-    while read PID ARGS
-    do
-      while read PORT USER DIR COMMAND
-      do
-        if [ "$PORT $USER $DIR $COMMAND" = "$ARGS" ]
-        then
-          echo "Keeping: $ARGS"
-          echo "$PID $ARGS" >> $temp
-          continue 2
-        fi
-      done < $conf
-      stopshell $PID $PORT $ARGS
-    done < $shells
-    mv $temp $shells
-    chmod 0644 $shells
-  fi
-  #now start all new shells
-  sleep 1
-  launch -reload
-}
-
-status () {
-  [ -r $conf ] || fail "$conf not readable"
-  if [ "$1" = "-log" ]
-  then
-    log=YES
-    shift
-  fi
-  echo -e "pid\tport\tuser\tdir\t\t\tcommand"
-  while read PORT USER DIR CMD
-  do
-    # check for empty lines and comments
-    [[ $PORT == "" || $PORT == \#* ]] && continue
-
-    # check if we have to report all shells
-    [ "$*" ] &&  echo "$*" | grep -qvE "(^|[[:space:]])$PORT([[:space:]]|$)" && continue
-    
-    if [ "$logdir" -a "$log" ]
-    then
-      echo "-------------------------------------------------------------------"
-    fi
-    
-    if LINE=$(grep "$PORT $USER $DIR $CMD" $shells 2> /dev/null)
-    then 
-      PID=${LINE%% *}
-      if checkpid $PID
-      then
-        echo -n $PID
-      else
-        $SETCOLOR_FAILURE
-        echo -n DEAD
-        $SETCOLOR_NORMAL
-      fi
-    else
-      $SETCOLOR_FAILURE
-      echo -n STOPPED 
-      $SETCOLOR_NORMAL
-    fi
-    echo -e "\t$PORT\t$USER\t$DIR\t$CMD"
-    
-    if [ "$logdir" -a "$log" ]
-    then
-        grep '\*\*\*\*' $logdir/$PORT 2>/dev/null
-    fi
-  done < $conf
-}
-
-CMD=$1
-shift
-case "$CMD" in
-  (start)         start $*;;
-  (stop)          stop $*;;
-  (restart)       stop $*; sleep 1; start $*;; # kill all shells, then start again
-  (reread|reload) reload $*;; # reload shellbox.conf without killing too much
-  (status)        status $*;;
-  (*)             echo "Usage: $0 {start [ports]|stop [ports]|restart [ports]|reload|status [-log] [ports]}" ;;
-esac
-
diff --git a/rtlsdr-ogn.conf b/rtlsdr-ogn.conf
deleted file mode 100644
index 6cbb2d6..0000000
--- a/rtlsdr-ogn.conf
+++ /dev/null
@@ -1,8 +0,0 @@
-#shellbox configuration file
-#Starts commands inside a "box" with a telnet-like server.
-#Contact the shell with: telnet <hostname> <port>
-#Syntax:
-#port  user     directory       command      args
-
-50000  pi /home/pi/rtlsdr-ogn    ./ogn-rf     SampleConfigurationFileNameToChange.conf
-50001  pi /home/pi/rtlsdr-ogn    ./ogn-decode SampleConfigurationFileNameToChange.conf
diff --git a/rtlsdr.h b/rtlsdr.h
deleted file mode 100644
index f1e855d..0000000
--- a/rtlsdr.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-
-#include <time.h>
-#include <sys/time.h>
-
-#include <math.h>
-
-// #include "alloc.h"
-#include "asciitime.h"
-#include "thread.h"
-
-#include "buffer.h"
-
-// =================================================================================
-
-#include <rtl-sdr.h>
-
-class RTLSDR
-{ public:
-   MutEx         Lock;           // for multi-threading
-
-   uint32_t      DeviceIndex;    // RTL dongle index
-   rtlsdr_dev_t *Device;         // RTL dongle handle
-   int           Gains;          // number of possible gain settings
-   int           Gain[64];       // [0.1 dB] list of possible gain settings
-
-   int           Bandwidths;
-   int           Bandwidth[16];
-
-   int           Stages;
-   int           StageGains[8];
-   char          StageName[8][32];
-   int           StageGain[8][32];
-
-   uint64_t      BytesRead;      // Counts number of bytes read (1 sample = 2 bytes: I/Q)
-   int         (*Callback)(uint8_t *Buffer, int Samples, double SampleTime, double SamplePeriod, void *Contex);
-   void         *CallbackContext;
-
-#ifndef __MACH__ // _POSIX_TIMERS
-   clockid_t     RefClock;           // CLOCK_REALTIME, CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW
-#endif
-
-   double        SampleTime;         // [sec] time when a batch of samples starts
-   double        StartTime;          // [sec] time when acquisition started
-   double        AverPeriod;         // [sec] averaging period for TimeRef, TimeRef_DMS and SamplePeriod
-   double        SamplePeriod;       // [sec] time per sample
-   double        PrevTime;           // [sec]
-   double        SampleTime_DMS;     // [sec^2] mean square variation of SampleTime
-
-  public:
-   RTLSDR()
-   { DeviceIndex=0; Device=0; Callback=0; CallbackContext=0; // Gain=0;
-     AverPeriod=100.0;
-#ifndef __MACH__ // _POSIX_TIMERS
-     RefClock=CLOCK_REALTIME;
-#endif
-   }
-
-  ~RTLSDR()
-   { Close(); }
-
-   bool isOpen(void) const { return Device!=0; }
-
-   void Close(void)
-   { if(Device)
-     { // printf("RTLSDR::Close() => %3.1f MB read, %3.1f samples/sec\n", BytesRead/(1024*1024.0), 1.0/SamplePeriod);
-       rtlsdr_cancel_async(Device); rtlsdr_close(Device); }
-     // free(Gain); Gain=0;
-     Gains=0; Stages=0; Bandwidths=0;
-     // free(SampleTimePipe); free(SampleIdxPipe); PipeSize=0; SampleTimePipe=0; SampleIdxPipe=0;
-     Device=0; Callback=0; }
-
-   static int  getNumberOfDevices(void)            { return rtlsdr_get_device_count(); }            // number of connected devices (USB RTL dongles)
-
-   static int  getDeviceUsbStrings(uint32_t DeviceIndex, char *Manufacturer, char *Product, char *Serial)
-             { return rtlsdr_get_device_usb_strings(DeviceIndex, Manufacturer, Product, Serial); }  // USB description strings
-   int         getUsbStrings(char *Manufacturer, char *Product, char *Serial)
-             { return rtlsdr_get_usb_strings(Device, Manufacturer, Product, Serial); }  // USB description strings
-             // { return rtlsdr_get_device_usb_strings(DeviceIndex, Manufacturer, Product, Serial); }  // USB description strings
-
-   static const char *getDeviceName(uint32_t DeviceIndex) { return rtlsdr_get_device_name(DeviceIndex); }  // name of given device
-          const char *getDeviceName(void)                 { return rtlsdr_get_device_name(DeviceIndex); }  // name of this device open by this object
-
-   int     getTunerType(void) { return rtlsdr_get_tuner_type(Device); }
-   const char *getTunerTypeName(void)
-   { const char *TunerType[7] = { "UNKNOWN", "E4000", "FC0012", "FC0013", "FC2580", "R820T", "R828D" } ;
-     int Type=getTunerType(); if((Type<0)&&(Type>=7)) Type=0; return TunerType[Type]; }
-
-   int     getXtalFreq(uint32_t &RtlFreq, uint32_t &TunerFreq) { return rtlsdr_get_xtal_freq(Device, &RtlFreq, &TunerFreq); }
-   int     setXtalFreq(uint32_t  RtlFreq, uint32_t  TunerFreq) { return rtlsdr_set_xtal_freq(Device,  RtlFreq,  TunerFreq); }
-
-   int     ReadEEPROM (uint8_t *Data, uint8_t Offset, uint16_t Size) { return rtlsdr_read_eeprom (Device, Data, Offset, Size); } // read  the EEPROM
-   int     WriteEEPROM(uint8_t *Data, uint8_t Offset, uint16_t Size) { return rtlsdr_write_eeprom(Device, Data, Offset, Size); } // write the EEPROM
-
-   int     setOffsetTuning(int ON=1) { return rtlsdr_set_offset_tuning(Device, ON); }
-   int     getOffsetTuning(void)     { return rtlsdr_get_offset_tuning(Device);     }
-
-   int     setCenterFreq(uint32_t Frequency)    { return rtlsdr_set_center_freq(Device, Frequency); } // [Hz]
-  uint32_t getCenterFreq(void)                  { return rtlsdr_get_center_freq(Device); } // (fast call)
-
-   int     setFreqCorrection(int PPM)           { return rtlsdr_set_freq_correction(Device, PPM); } // [PPM] (Part-Per-Million)
-   int     getFreqCorrection(void)              { return rtlsdr_get_freq_correction(Device); } // (fast call)
-
-#ifdef NEW_RTLSDR_LIB
-   int setTunerBandwidth(int Bandwidth) { return rtlsdr_set_tuner_bandwidth(Device, Bandwidth); }    // [Hz] a new (advanced) function
-   // int getTunerBandwidth(void)     { int Bandwidth; return rtlsdr_get_tuner_bandwidth(Device, &Bandwidth); return Bandwidth; }
-   int getTunerBandwidths(int *Bandwidth=0) { return rtlsdr_get_tuner_bandwidths(Device, Bandwidth); }
-#endif
-
-   int getTunerGains(int *Gain=0)           { return rtlsdr_get_tuner_gains(Device, Gain); }
-#ifdef NEW_RTLSDR_LIB
-   int getTunerStageGains(int Stage, int32_t *Gain, char *Description=0) { return rtlsdr_get_tuner_stage_gains(Device, Stage, Gain, Description); }
-   int setTunerStageGain(int Stage, int Gain) { return rtlsdr_set_tuner_stage_gain(Device, Stage, Gain); }
-#endif
-   int setTunerGain(int Gain) { return rtlsdr_set_tuner_gain(Device, Gain); }    // [0.1 dB]    set tuner gain when in manual mode
-   int getTunerGain(void)     { return rtlsdr_get_tuner_gain(Device); }
-
-   // note: new gain modes are possible with the more advanced drivers: 2=Linearity, 3=Sensitivity
-   int setTunerGainMode(int Manual=1) { return rtlsdr_set_tuner_gain_mode(Device, Manual); }  // set radio-tuner gain mode: manual or automatic
-   int setTunerGainManual(int Manual=1) { return setTunerGainMode(Manual); }                  // set manual mode
-   int setTunerGainAuto(void) { return setTunerGainManual(0); }                               // set automatic mode
-
-   int setTestMode(int Test=1) { return rtlsdr_set_testmode(Device, Test); }  // Enable/Disable test mode - a counter is send, not real data
-   int ResetBuffer(void) { return rtlsdr_reset_buffer(Device); }              // obligatory, the docs say, before you start reading
-
-   int setBiasTee(int On=1) { return rtlsdr_set_bias_tee(Device, On); }       // turn on or off the T-bias circuit to power extenal LNA: never use with DC-shorted antennas !
-
-   double getTime(void) const                                                 // read the system time at this very moment
-#ifndef __MACH__ // _POSIX_TIMERS
-   { struct timespec now; clock_gettime(RefClock, &now); return now.tv_sec + 1e-9*now.tv_nsec; }
-#else                                                                         // for OSX, there is no clock_gettime()
-   { struct timeval now; gettimeofday(&now, 0); return now.tv_sec + 1e-6*now.tv_usec; }
-#endif
-
-    int     setSampleRate(uint32_t SampleRate)  { SamplePeriod = 1.0/SampleRate; SampleTime_DMS=0.0001*0.0001;
-                                                  return rtlsdr_set_sample_rate(Device, SampleRate); } // [samples-per-second]
-   uint32_t getSampleRate(void)                 { return rtlsdr_get_sample_rate(Device); }
-
-   int getDeviceIndexBySerial(const char *Serial) { return rtlsdr_get_index_by_serial(Serial); }
-
-   int Open(uint32_t DeviceIndex=0, uint32_t Frequency=868000000, uint32_t SampleRate=2048000) // open given device (by the index)
-   { Close();
-
-     this->DeviceIndex=DeviceIndex;
-     if(rtlsdr_open(&Device, DeviceIndex)<0)                                                   // open the RTLSDR device
-     { printf("Cannot open device #%d\n", DeviceIndex); Device=0; return -1; }
-     if(setCenterFreq(Frequency)<0)                                                            // set the desired frequency
-     { printf("Cannot set the frequency %d for device #%d\n", Frequency, DeviceIndex); }
-     if(setSampleRate(SampleRate)<0)                                                           // set the desired sample rate
-     { printf("Cannot set the sample rate %d for device #%d\n", SampleRate, DeviceIndex); }
-     printf("RTLSDR::Open(%d,%d,%d) => %s, %8.3f MHz, %5.3f Msps\n",
-            DeviceIndex, Frequency, SampleRate, getDeviceName(), 1e-6*getCenterFreq(), 1e-6*getSampleRate());
-
-     Gains=getTunerGains(Gain);                                                  // get list of possible tuner gains
-#ifdef NEW_RTLSDR_LIB
-     for(Stages=0; Stages<8; Stages++)
-     { StageGains[Stages]=getTunerStageGains(Stages, StageGain[Stages], StageName[Stages]);
-       if(StageGains[Stages]<=0) break; }
-#endif
-     PrintGains();
-
-#ifdef NEW_RTLSDR_LIB
-     Bandwidths=getTunerBandwidths(Bandwidth);
-     PrintBandwidths();
-#endif
-
-     if(ResetBuffer()<0)                                                                        // reset the buffers (after the manual...)
-     { printf("Cannot reset buffer for device #%d\n", DeviceIndex); }
-     return 1; }
-
-   void PrintGains(void) const
-   {
-#ifdef NEW_RTLSDR_LIB
-     for(int Stage=0; Stage<Stages; Stage++)
-     { printf("RTLSDR::%s[%d] =", StageName[Stage], StageGains[Stage]);
-       for(int Idx=0; Idx<StageGains[Stage]; Idx++) printf(" %+5.1f", 0.1*StageGain[Stage][Idx]); printf(" [dB]\n"); }
-#endif
-     printf("RTLSDR::Gain[%d] =", Gains); for(int Idx=0; Idx<Gains; Idx++) printf(" %+5.1f", 0.1*Gain[Idx]); printf(" [dB]\n"); }
-
-   void PrintBandwidths(void) const
-   { printf("RTLSDR::Bandwidth[%d] =", Bandwidths); for(int Idx=0; Idx<Bandwidths; Idx++) printf(" %5.3f", 1e-6*Bandwidth[Idx]); printf(" [MHz]\n"); }
-
-   double SampleTimeJitter(void) { return sqrt(SampleTime_DMS); }
-
-   static void StaticCallback(unsigned char *Buffer, uint32_t Len, void *Contex)          // callback that receives the data
-   { RTLSDR *This = (RTLSDR *)Contex; return This->ClassCallback(Buffer, Len); }          // "This" points now to this class instance
-
-   void ClassCallback(unsigned char *Buffer, uint32_t Len)                                // callback but already in this class instance
-   { Lock.Lock();
-     int Samples = Len/2;                                                                 // number of samples is half the buffer size
-     BytesRead+=Len;                                                                      // count number of bytes read
-     double ReadTime=getTime();                                                           // read the time at this moment
-/*
-     uint32_t PrevSampleIdx=SampleIdxPipe[PipeWrite];                                     // previous SampleIdx
-     PipeWrite++; if(PipeWrite>=PipeSize) PipeWrite=0;                                    // advance pipe write pointer
-     double FirstSampleTime = SampleTimePipe[PipeRead];
-     uint32_t FirstSampleIdx  = SampleIdxPipe[PipeRead];
-     if(PipeWrite==PipeRead) { PipeRead++; if(PipeRead>=PipeSize) PipeRead=0; }
-     SampleTimePipe[PipeWrite]=ReadTime;                                                  // ReadTime -> Pipe
-     SampleIdxPipe[PipeWrite]=PrevSampleIdx+Samples;                                      // next SampleIdx -> Pipe
-     double   SampleTimeDiff = ReadTime-FirstSampleTime;
-     uint32_t SampleIdxDiff  = (PrevSampleIdx+Samples)-FirstSampleIdx;;
-*/
-     double AcqTime = Samples * SamplePeriod;                                             // time it took to acquire these samples
-     double AverWeight = AcqTime / AverPeriod; // ratio: acquisition period : averaging period
-
-     int Ret=0;
-     if(Callback)
-     { Ret=(*(Callback))(Buffer, Samples,                                 // buffer, number of samples
-                         SampleTime - Samples*SamplePeriod, SamplePeriod, // SampleTime = time of the first sample, SamplePeriod = time period of one sample
-                         CallbackContext);
-     }
-     if(Ret) CancelAsync();                                               // call the user callback, if it returns non-zero, then stop data acquisition
-
-     SampleTime += Samples * SamplePeriod;            // increment predicted time for this batch
-     double TimeDiff = ReadTime - SampleTime;         // difference: time read now versus predicted time
-     SampleTime += 0.125*TimeDiff;                    // follow the ReadTime with weight 1/8 (a bit arbitrary...)
-     SampleTime_DMS += AverWeight * (TimeDiff*TimeDiff - SampleTime_DMS); // integrate the difference RMS
-
-     double PeriodDiff = (ReadTime - PrevTime) - AcqTime; // difference: measured time period to acquire this batch versus predicted time period
-     SamplePeriod += AverWeight*(PeriodDiff/Samples);
-     PrevTime = ReadTime;
-
-     // printf("%14.3f (%+7.3f:%+7.3f ms): RTLSDR::Callback( , %d, ) => %10.1f (%10.1f) samples/sec, %6.3f ms\r",
-     //        ReadTime, 1e3*TimeDiff, 1e3*PeriodDiff, Len, 1.0/SamplePeriod, SampleIdxDiff/SampleTimeDiff, 1e3*SampleTimeJitter() );
-/*
-     char Time[24]; AsciiTime_DDDDDHHMMSSFFF(Time, ReadTime);
-     printf("%s (%+7.3f:%+7.3f ms): RTLSDR::Callback( , %d, ) => %10.1f samples/sec, %6.3f ms\r",
-            Time, 1e3*TimeDiff, 1e3*PeriodDiff, Len, 1.0/SamplePeriod, 1e3*SampleTimeJitter() );
-     fflush(stdout);
-*/
-     Lock.Unlock(); }
-
-   // read in async. mode, call Callback() for the data being received, block, wait and return when Callback() returns non-zero
-   int ReadAsync(int (*Callback)(uint8_t *Buffer, int Samples, double SampleTime, double SamplePeriod, void *Contex)=0, void *Contex=0,
-                 int Buffers=0, int BlockSize=0)
-   { this->Callback = Callback; StartTime=SampleTime=PrevTime=getTime();
-     this->CallbackContext = Contex;
-     // SampleTimePipe[0]=SampleTime; SampleIdxPipe[0]=0; PipeWrite=0; PipeRead=0;
-     return rtlsdr_read_async(Device, StaticCallback, this, Buffers, BlockSize); }
-
-   int CancelAsync(void) { return rtlsdr_cancel_async(Device); }
-
-   // read directly given number of samples (remember to ResetBuffer() !)
-   int Read(uint8_t *Buffer, int Samples)
-   { Samples&=0xFFFFFF00;                 // number of samples must be a multiply of 256
-     int BufferSize = 2*Samples;
-     int ReadSize=0;
-     if(rtlsdr_read_sync(Device, Buffer, BufferSize, &ReadSize)<0) return -1;
-     return ReadSize/2; }
-
-   int Read(SampleBuffer<uint8_t> &Buffer, int Samples)
-   { if(Buffer.Allocate(2,Samples)<=0) return 0;
-     int ReadSamples=Read(Buffer.Data, Samples);
-     double Time = getTime();
-     if(ReadSamples>0)
-     { Buffer.Full=ReadSamples*2;
-       Buffer.Rate=getSampleRate();
-       Buffer.Freq=getCenterFreq();
-       Buffer.Time=Time-(double)ReadSamples/Buffer.Rate; }
-     // printf("RTLSDR::Read( , %d) => %d, %7.3fMHz %14.3fsec\n", Samples, ReadSamples, 1e-6*getCenterFreq(), Buffer.Time );
-     return ReadSamples;
-   }
-
-} ;
-
-// =================================================================================
-
diff --git a/scripts/rtlsdr-ogn b/scripts/rtlsdr-ogn
new file mode 100755
index 0000000..b4ecc0d
--- /dev/null
+++ b/scripts/rtlsdr-ogn
@@ -0,0 +1,245 @@
+#!/bin/bash
+### BEGIN INIT INFO
+# Provides:          rtlsdr-ogn
+# Required-Start:    $all
+# Required-Stop:
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: OGN receiver
+# Description:       OGN receiver - Open Glider Network - http://glidernet.org/
+### END INIT INFO
+
+# chkconfig: 2345 98 2
+# description: shellbox service for spawning programs
+
+export PATH=$PATH:/usr/local/bin
+
+export HOSTNAME=$(hostname -s)
+
+exe=/usr/bin/procServ
+options="-k ^X --killsig 15 -x ^C -i ^D -c"
+prog=rtlsdr-ogn
+params=
+conf=/etc/rtlsdr-ogn.conf
+logdir=/var/log/$prog
+shells=/var/run/$prog
+chroot=/mnt/ramdisk
+
+if [ -d $chroot ]
+then
+  CHROOT="chroot $chroot"
+fi
+
+fail () {
+  echo $@
+  exit 1
+}
+
+echo_failure () {
+  echo " [failed]"
+}
+
+checkpid () {
+  [ -d /proc/$PID ] 
+}
+
+launch () {
+  if [ "$1" = "-reload" ]
+  then
+    reload=YES
+    shift
+  fi
+  temp=$(mktemp -p $(dirname $shells)) || fail "can't create temporary file"
+  while read PORT USER DIR COMMAND
+  do
+    # check for empty lines and comments
+    [[ $PORT == "" || $PORT == \#* ]] && continue
+    # check if already started shell is still alive
+    if LINE=$(grep "$PORT $USER $DIR $COMMAND" $shells 2> /dev/null)
+    then
+      PID=${LINE%% *}
+      if checkpid $PID
+      then
+        if [ -z "$reload" ] && [ -z "$*" ] || echo "$*" | grep -qE "(^|[[:space:]])$PORT([[:space:]]|$)"
+        then
+          echo "Already running: $PORT $USER $DIR $COMMAND"
+        fi
+        echo "$LINE" >> $temp
+        continue
+      fi
+    fi
+
+    # check if we have to start all shells or only this PORT
+    [ "$*" ] && echo "$*" | grep -qvE "(^|[[:space:]])$PORT([[:space:]]|$)" && continue
+
+    if [ -n "$logdir" ]
+    then
+      [ -d $logdir ] || mkdir -m 777 $logdir
+      LOG=$logdir/$PORT
+      rm -f $LOG
+    else
+      LOG=/dev/null
+    fi
+
+    # Wait for time to be sync before launching
+    while true; do /usr/sbin/ntp-wait -v;  if [ $? -eq 0 ]; then break; fi; sleep 2; done
+
+    # start shellbox as other user
+    echo -n Starting: $PORT $USER $DIR $COMMAND
+    export SHELLBOX=$HOSTNAME:$PORT
+    #pidfile=/var/run/procServ-$PORT.pid
+    pidfile=/tmp/procServ-$PORT.pid
+    rm -f $pidfile
+#    $exe -p $pidfile $options $DIR $params $PORT $COMMAND >> $LOG 2>&1 < /dev/null
+    $CHROOT su $USER -c "$exe -p $pidfile $options $DIR $params $PORT $COMMAND >> $LOG 2>&1 < /dev/null"
+    # check if starting worked or failed
+    sleep 1
+    if [ -e $pidfile ]
+    then
+      PID=$(<$pidfile)
+      echo "$PID $PORT $USER $DIR $COMMAND" >> $temp
+      echo
+    else
+      echo_failure
+      echo
+      cat $LOG
+    fi
+  done < $conf
+  mv $temp $shells
+  chmod 0644 $shells
+}
+
+start () {
+  [ -r $conf ] || fail "$conf not readable"
+  [ -x $exe ] || fail "$exe is not executable"
+  launch $*
+  touch /var/lock/$prog
+}
+
+stopshell() {
+  PID=$1
+  PORT=$2
+  shift
+  echo -n Stopping: $*
+  kill $PID 2> /dev/null || echo_failure
+  echo
+  if [ $logdir ]
+  then
+      echo -e "\n**** stopped ****" >> $logdir/$PORT
+  fi
+}
+
+stop () {
+  # anything to stop?
+  if [ ! -r $shells ]
+  then
+    echo "$prog: No shells started."
+    exit 0
+  fi
+  if [ -z "$1" ]
+  then
+    # kill all shellboxes
+    while read PID PORT ARGS
+    do
+      stopshell $PID $PORT $ARGS
+    done < $shells
+    rm -f $shells
+    rm -f /var/lock/$prog
+  else
+    # kill only selected shellboxes
+    temp=$(mktemp -p $(dirname $shells)) || fail "can't create temporary file"
+    while read PID PORT ARGS
+    do
+      echo "$*" | grep -qE "(^|[[:space:]])$PORT([[:space:]]|$)" && stopshell $PID $PORT $ARGS || echo "$PID $PORT $ARGS" >> $temp
+    done < $shells
+    mv $temp $shells
+    chmod 0644 $shells
+  fi
+}
+
+reload () {
+  echo "Reloading $conf: "
+  [ -r $conf ] || fail "not readable"
+  # anything to stop?
+  if [ -r $shells ]
+  then
+    #first kill all shells that are not configured any more
+    temp=$(mktemp -p $(dirname $shells)) || fail "can't create temporary file"
+    while read PID ARGS
+    do
+      while read PORT USER DIR COMMAND
+      do
+        if [ "$PORT $USER $DIR $COMMAND" = "$ARGS" ]
+        then
+          echo "Keeping: $ARGS"
+          echo "$PID $ARGS" >> $temp
+          continue 2
+        fi
+      done < $conf
+      stopshell $PID $PORT $ARGS
+    done < $shells
+    mv $temp $shells
+    chmod 0644 $shells
+  fi
+  #now start all new shells
+  sleep 1
+  launch -reload
+}
+
+status () {
+  [ -r $conf ] || fail "$conf not readable"
+  if [ "$1" = "-log" ]
+  then
+    log=YES
+    shift
+  fi
+  echo -e "pid\tport\tuser\tdir\t\t\tcommand"
+  while read PORT USER DIR CMD
+  do
+    # check for empty lines and comments
+    [[ $PORT == "" || $PORT == \#* ]] && continue
+
+    # check if we have to report all shells
+    [ "$*" ] &&  echo "$*" | grep -qvE "(^|[[:space:]])$PORT([[:space:]]|$)" && continue
+    
+    if [ "$logdir" -a "$log" ]
+    then
+      echo "-------------------------------------------------------------------"
+    fi
+    
+    if LINE=$(grep "$PORT $USER $DIR $CMD" $shells 2> /dev/null)
+    then 
+      PID=${LINE%% *}
+      if checkpid $PID
+      then
+        echo -n $PID
+      else
+        $SETCOLOR_FAILURE
+        echo -n DEAD
+        $SETCOLOR_NORMAL
+      fi
+    else
+      $SETCOLOR_FAILURE
+      echo -n STOPPED 
+      $SETCOLOR_NORMAL
+    fi
+    echo -e "\t$PORT\t$USER\t$DIR\t$CMD"
+    
+    if [ "$logdir" -a "$log" ]
+    then
+        grep '\*\*\*\*' $logdir/$PORT 2>/dev/null
+    fi
+  done < $conf
+}
+
+CMD=$1
+shift
+case "$CMD" in
+  (start)         start $*;;
+  (stop)          stop $*;;
+  (restart)       stop $*; sleep 1; start $*;; # kill all shells, then start again
+  (reread|reload) reload $*;; # reload shellbox.conf without killing too much
+  (status)        status $*;;
+  (*)             echo "Usage: $0 {start [ports]|stop [ports]|restart [ports]|reload|status [-log] [ports]}" ;;
+esac
+
diff --git a/scripts/rtlsdr-ogn.conf b/scripts/rtlsdr-ogn.conf
new file mode 100644
index 0000000..6cbb2d6
--- /dev/null
+++ b/scripts/rtlsdr-ogn.conf
@@ -0,0 +1,8 @@
+#shellbox configuration file
+#Starts commands inside a "box" with a telnet-like server.
+#Contact the shell with: telnet <hostname> <port>
+#Syntax:
+#port  user     directory       command      args
+
+50000  pi /home/pi/rtlsdr-ogn    ./ogn-rf     SampleConfigurationFileNameToChange.conf
+50001  pi /home/pi/rtlsdr-ogn    ./ogn-decode SampleConfigurationFileNameToChange.conf
diff --git a/serialize.h b/serialize.h
deleted file mode 100644
index f442ed9..0000000
--- a/serialize.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef __SERIALIZE_H__
-#define __SERIALIZE_H__
-
-#include <stdint.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-
-inline int SerializeWriteSync(int Stream, uint32_t Sync)               { return write(Stream, &Sync, sizeof(uint32_t)); }
-inline int SerializeWriteName(int Stream, const char *Name)            { return write(Stream, Name, strlen(Name)+1); }
-inline int SerializeWriteData(int Stream, const void *Data, int Bytes) { return write(Stream, Data, Bytes); }
-inline int SerializeReadData (int Stream, void *Data, int Bytes)       { return read (Stream, Data, Bytes); }
-
-inline int SerializeWriteSync(FILE *Stream, uint32_t Sync)               { return fwrite(&Sync, 1, sizeof(uint32_t), Stream); }
-inline int SerializeWriteName(FILE *Stream, const char *Name)            { return fwrite(Name,  1, strlen(Name)+1,   Stream); }
-inline int SerializeWriteData(FILE *Stream, const void *Data, int Bytes) { return fwrite(Data,  1, Bytes,            Stream); }
-inline int SerializeReadData (FILE *Stream, void *Data, int Bytes)       { return fread (Data,  1, Bytes,            Stream); }
-
-int SerializeFindSync(int Stream, uint32_t Sync);
-int SerializeReadName(int Stream, char *Name, int MaxBytes);
-
-int SerializeFindSync(FILE *Stream, uint32_t Sync);
-int SerializeReadName(FILE *Stream, char *Name, int MaxBytes);
-
-#endif // __SERIALIZE_H__
diff --git a/socket.h b/socket.h
deleted file mode 100644
index 1c98480..0000000
--- a/socket.h
+++ /dev/null
@@ -1,601 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-
-// =========================================================================================
-
-#ifndef __SOCKET_H__
-#define __SOCKET_H__
-
-#include <netdb.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-// #include <netinet/ip_icmp.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/sendfile.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-
-#include <stdlib.h>
-#include <errno.h>
-#include <unistd.h>
-#include <string.h>
-#include <math.h>
-
-#ifdef __MACH__
-#define MSG_NOSIGNAL 0
-#endif
-
-
-class SocketAddress                    // IP address and port
-{ public:
-
-   struct sockaddr_in Address;
-
-  private:
-
-   static const int TmpStringLen = 64;
-   char TmpString[TmpStringLen];
-
-  public:
-
-   SocketAddress()
-     { Init(); }
-
-   void Init(void)
-     { Address.sin_family = AF_INET; setIP(); }
-
-   // set IP and port from an ASCII string: "IP:port", IP can be numeric or a host name
-   int set(const char *HostColonPort)
-     { const char *Colon=strchr(HostColonPort,':');
-       if(Colon==0) return setIP(HostColonPort);
-       int Port; if(sscanf(Colon+1,"%d",&Port)!=1) return -1;
-       if((Port<0)||(Port>0xFFFF)) return -1;
-       setPort((unsigned short)Port);
-       int Len=Colon-HostColonPort; if(Len>=TmpStringLen) return -1;
-       memcpy(TmpString, HostColonPort, Len); TmpString[Len]='\0';
-       int Error = setIP(TmpString);
-       return Error; }
-
-   // set only the IP (includes DNS name resolve)
-   int setIP(const char *AsciiHost)
-     { in_addr_t IP=inet_addr(AsciiHost);
-       if(IP != (in_addr_t)(-1)) { Address.sin_addr.s_addr=IP; return 0; }
-       struct hostent *Host = gethostbyname(AsciiHost); if(Host==0) return -1;
-       char *AddrPtr=Host->h_addr_list[0];              if(AddrPtr==0) return -1;
-       memcpy(&Address.sin_addr, Host->h_addr_list[0],  Host->h_length);
-       return 0; }
-
-   // set the IP from a 32-bit integer
-   int setIP(unsigned long IP=INADDR_ANY)
-     { Address.sin_addr.s_addr = htonl(IP); return 0; }
-
-   // get IP as a 32-bit integer
-   unsigned long getIP(void) const
-     { return ntohl(Address.sin_addr.s_addr); }
-
-   // is the address defined already ?
-   bool isSetup(void) const
-     { return getIP()!=INADDR_ANY; }
-
-   int setBroadcast(void)
-     { Address.sin_addr.s_addr = htonl(INADDR_BROADCAST); return 0; }
-
-   // set the port
-   int setPort(unsigned short Port)
-     { Address.sin_port = htons(Port); return 0; }
-
-   // get the port
-   unsigned short getPort(void) const
-     { return ntohs(Address.sin_port); }
-
-   // get IP as an ASCII string (to print)
-   char *getAsciiIP(void) const
-     { return inet_ntoa(Address.sin_addr); }
-
-   // get my own host name
-   char *getHostName(void) { return getHostName(TmpString, TmpStringLen); }
-
-   static char *getHostName(char *Name, int NameLen)
-     { if(gethostname(Name, NameLen)<0) return 0;
-       return Name; }
-
-   // get the "IP:port" ASCII string, IP will be numeric
-   char *getIPColonPort(void)
-     { char *IP = getAsciiIP(); if(IP==0) return IP;
-       if(strlen(IP)>(TmpStringLen-8)) return 0;
-       unsigned short Port=getPort();
-       sprintf(TmpString, "%s:%d", IP, Port);
-       return TmpString; }
-
-} ;
-
-class SocketBuffer             // data buffer for IP sockets
-{ public:
-
-   char *Data;                 //         data storage
-   size_t Allocated;           // [bytes] allocated
-   size_t Len;                 // [bytes] filled with data
-   size_t Done;                // [bytes] processed
-   static const size_t AllocUnit = 4096; // allocation step
-
-  public:
-
-   SocketBuffer()
-     { Data=0; Allocated=0; Len=0; Done=0; }
-
-   ~SocketBuffer()
-     { Free(); }
-
-   void Free(void)
-     { if(Data) { free(Data); Data=0; }
-       Allocated=0; Len=0; Done=0; }
-
-   size_t Relocate(size_t Size)
-     { if(Size<=Allocated) return Allocated;
-       // printf("Relocate(%d)",Size);
-       size_t Units=(Size+AllocUnit-1)/AllocUnit; Size=Units*AllocUnit;
-       // printf(" => Units=%d, Size=%d\n", Units, Size);
-       Data=(char *)realloc(Data, Size); if(Data==0) Free(); else Allocated=Size;
-       return Allocated; }
-
-   int NullTerm(void)        // put null byte at the end, thus it can be treated as a null-terminated string
-     { if(Relocate(Len+1)<=0) return 0;
-       Data[Len]=0;
-       return Len; }
-
-   void Clear(void)
-     { Len=0; Done=0; }
-
-   bool isDone(void) const   // is all data processed ?
-     { return Done==Len; }
-
-   int Delete(size_t Ofs, size_t DelLen) // delete some part of the data (involves memory move)
-     { if(Ofs>=Len) return 0;
-       if((Ofs+DelLen)>Len) DelLen=Len-Ofs;
-       memcpy(Data+Ofs, Data+Ofs+DelLen, Len-DelLen); Len-=DelLen;
-       Data[Len]=0; return DelLen; }
-
-   int SearchLineTerm(int StartIdx=0) // search for a line terminator: \r or \n
-     { size_t Idx; char Term=0;
-       for( Idx=StartIdx; Idx<Len; Idx++)
-       { Term=Data[Idx];
-         if((Term=='\r')||(Term=='\n')) break; }
-       if(Idx>=Len) return -1;        // return -1 if terminator not found
-       return Idx-StartIdx; }         // return the line length (not including the terminator)
-
-   int ReadFromFile(char *FileName)
-     { FILE *File = fopen(FileName,"r"); if(File==0) return -1;
-       int Total=0;
-       for( ; ; )
-       { if(Relocate(Len+AllocUnit)<0) { fclose(File); return -1; }
-         int ToRead = Allocated-Len;
-         int Read = fread(Data+Len, 1, ToRead, File);
-         if(Read<0) { fclose(File); return -1; }
-         Len+=Read; Total+=Read; if(Read!=ToRead) break;
-       }
-       fclose(File);
-       return Total; }
-
-   int WriteToFile(FILE *File=stdout) const
-     { int ToWrite = Len-Done; if(ToWrite<0) ToWrite=0;
-       int Written = fwrite(Data+Done, 1, ToWrite, File);
-       if(Written<0) return Written;
-       return Written==ToWrite ? Written:-1; }
-
-   int WriteToFile(const char *FileName) const
-     { FILE *File = fopen(FileName,"w"); if(File==0) return -1;
-       int ToWrite = Len-Done; if(ToWrite<0) ToWrite=0;
-       int Written = fwrite(Data+Done, 1, ToWrite, File);
-       fclose(File);
-       if(Written<0) return Written;
-       return Written==ToWrite ? Written:-1; }
-
-// -----------------------------------------------------------------------------
-
-   int LineLen(size_t Ofs=0, size_t MaxLen=256) const
-   { size_t Idx=Ofs;
-     for( ; Idx<Len; Idx++)
-     { char Byte=Data[Idx]; if( (Byte=='\r') || (Byte=='\n') ) break; }
-     return Idx-Ofs; }
-
-   int EOL(size_t Ofs) const
-   { if(Ofs>=Len) return 0;
-     char Byte1=Data[Ofs];
-     if( (Byte1!='\r') && (Byte1!='\n') ) return 0;
-     Ofs++;
-     if(Ofs>=Len) return 1;
-     char Byte2=Data[Ofs];
-     if( (Byte2!='\r') && (Byte2!='\n') ) return 1;
-     if(Byte2==Byte1) return 1;
-     return 2; }
-
-   int getStatus(void) const
-   { char Protocol[16]; int Status=0;
-     int FirstLineLen=LineLen(0, 128);
-     if(FirstLineLen<=8) return -1;
-     if(FirstLineLen>=128) return -1;
-     if(sscanf(Data, "%s %d", Protocol, &Status)!=2) return -1;
-     return Status; }
-
-   int getHeaderLen(void) const
-   { size_t Idx=0;
-     for( ; ; )
-     { int Len=LineLen(Idx);
-       int TermLen=EOL(Idx+Len);
-       Idx+=Len+TermLen;
-       if(Len==0) break; }
-     return Idx; }
-
-   int FindTag(const char *Tag, size_t Ofs=0)
-   { size_t TagLen=strlen(Tag);
-     for(size_t Idx=Ofs; Idx<Len; Idx++)
-     { char Byte=Data[Idx]; if(Byte!='<') continue;
-       if((Idx+1+TagLen)>=Len) return -1;
-       if(memcmp(Tag, Data+Idx+1, TagLen)==0) return Idx-Ofs; }
-     return -1; }
-
-   int TagLen(size_t Ofs=0) const
-   { for(size_t Idx=Ofs+1; Idx<Len; Idx++)
-     { char Byte=Data[Idx]; if(Byte=='>') return Idx-Ofs+1; }
-     return -1; }
-
-// -----------------------------------------------------------------------------
-
-} ;
-
-class Socket                   // IP socket
-{ public:
-
-   int SocketFile;
-   // unsigned long BytesSent, BytesReceived;
-
-  public:
-
-   Socket()
-     { SocketFile=(-1); }
-
-   ~Socket()
-     { Close(); }
-
-   // create a socket
-   int Create(int Type=SOCK_STREAM, int Protocol=IPPROTO_TCP)
-     { Close();
-       SocketFile=socket(PF_INET, Type, Protocol);
-       return SocketFile; }
-   int Create_STREAM(void) { return Create(SOCK_STREAM, IPPROTO_TCP); }
-   int Create_DGRAM(void) { return Create(SOCK_DGRAM, 0); }
-
-   int Copy(int NewSocketFile)
-     { Close();
-       return SocketFile=NewSocketFile; }
-
-   // set connect/read/write to be blocking or not
-   int setBlocking(int Block=1)
-     { int Flags = fcntl(SocketFile,F_GETFL,0);
-       if(Block) Flags &= ~O_NONBLOCK;
-            else Flags |=  O_NONBLOCK;
-       return fcntl(SocketFile,F_SETFL,Flags); }
-
-   int setNonBlocking(void)
-     { return setBlocking(0); }
-
-   // avoids waiting (in certain cases) till the socket closes completely after the previous server exits
-   int setReuseAddress(int Set=1)
-     { return setsockopt(SocketFile, SOL_SOCKET, SO_REUSEADDR, &Set, sizeof(Set)); }
-
-   int setKeepAlive(int KeepAlive=1) // keep checking if connection alive while no data is transmitted
-     { return setsockopt(SocketFile, SOL_SOCKET, SO_KEEPALIVE, &KeepAlive, sizeof(KeepAlive)); }
-
-   int setLinger(int ON, int Seconds) // gracefull behavior on socket close
-     { struct linger Linger; Linger.l_onoff=ON; Linger.l_linger=Seconds;
-       return setsockopt(SocketFile, SOL_SOCKET, SO_LINGER, &Linger, sizeof(Linger)); }
-
-   int setNoDelay(int ON=1)
-   { return setsockopt(SocketFile, IPPROTO_TCP, TCP_NODELAY, &ON, sizeof(ON)); }
-
-   int setSendBufferSize(int Bytes)
-     { return setsockopt(SocketFile, SOL_SOCKET, SO_SNDBUF, &Bytes, sizeof(Bytes)); }
-
-   int getSendBufferSize(void)
-     { int Bytes=0; socklen_t Size;
-       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_SNDBUF, &Bytes, &Size);
-       return Error<0 ? -1:Bytes; }
-
-   int setReceiveBufferSize(int Bytes)
-     { return setsockopt(SocketFile, SOL_SOCKET, SO_RCVBUF, &Bytes, sizeof(Bytes)); }
-
-   int getReceiveBufferSize(void)
-     { int Bytes=0; socklen_t Size;
-       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_RCVBUF, &Bytes, &Size);
-       return Error<0 ? -1:Bytes; }
-
-/* on Cygwin send and receive timeouts seem to have no effect ...
-#ifdef __WINDOWS__
-   int setReceiveTimeout(double Seconds) // a blocking receive() will not wait forever
-   { long Time = (long)floor(1000*Seconds+0.5);
-     return setsockopt(SocketFile, SOL_SOCKET, SO_RCVTIMEO, &Time, sizeof(Time)); }
-
-   int setSendTimeout(double Seconds)   // a blocking send() will not wait forever
-   { long Time = (long)floor(1000*Seconds+0.5);
-      return setsockopt(SocketFile, SOL_SOCKET, SO_SNDTIMEO, &Time, sizeof(Time)); }
-#endif
-*/
-
-#ifdef __CYGWIN__  // dummy routine for Cygwin, only to satify the compiler
-   int setReceiveTimeout(double Seconds) { return -1; }
-   int setSendTimeout(double Seconds) { return -1; }
-#else
-   int setReceiveTimeout(double Seconds) // a blocking receive() will not wait forever
-     { struct timeval Time;
-       Time.tv_sec  = (long)floor(Seconds);
-       Time.tv_usec = (long)floor(1000000*(Seconds-Time.tv_sec)+0.5);
-       return setsockopt(SocketFile, SOL_SOCKET, SO_RCVTIMEO, &Time, sizeof(Time)); }
-
-   int setSendTimeout(double Seconds)   // a blocking send() will not wait forever
-     { struct timeval Time;
-       Time.tv_sec  = (long)floor(Seconds);
-       Time.tv_usec = (long)floor(1000000*(Seconds-Time.tv_sec)+0.5);
-       return setsockopt(SocketFile, SOL_SOCKET, SO_SNDTIMEO, &Time, sizeof(Time)); }
-#endif
-
-#if defined(__MACH__) || defined(__CYGWIN__)
-#else
-   int getMTU(void)
-     { int Bytes;
-       if(ioctl(SocketFile, SIOCGIFMTU, &Bytes)<0) return -1;
-       return Bytes; }
-#endif
-
-   int getReceiveQueue(void)
-     { int Bytes;
-       if(ioctl(SocketFile, FIONREAD, &Bytes)<0) return -1;
-       return Bytes; }
-
-   int getError(void)
-     { int ErrorCode=0;
-       socklen_t Size=sizeof(ErrorCode);
-       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_ERROR, &ErrorCode, &Size);
-       return Error<0 ? -1:ErrorCode; }
-
-   int isListenning(void)
-     { int Yes=0;
-       socklen_t Size=sizeof(Yes);
-       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_ACCEPTCONN, &Yes, &Size);
-       return Error<0 ? -1:Yes; }
-
-   // listen for incoming UDP connections (become a UDP server)
-   int Listen_DGRAM(unsigned short ListenPort)
-     { if(SocketFile<0) { if(Create_DGRAM()<0) return -1; }
-
-       setReuseAddress(1);
-
-       struct sockaddr_in ListenAddress;
-       ListenAddress.sin_family      = AF_INET;
-       ListenAddress.sin_addr.s_addr = htonl(INADDR_ANY);
-       ListenAddress.sin_port        = htons(ListenPort);
-
-       if(bind(SocketFile, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress))<0)
-       { Close(); return -1; }
-
-       return 0; }
-
-   // listen for incoming TCP connections (become a TCP server)
-   int Listen(unsigned short ListenPort, int MaxConnections=8)
-     { if(SocketFile<0) { if(Create()<0) return -1; }
-
-       setReuseAddress(1);
-
-       struct sockaddr_in ListenAddress;
-       ListenAddress.sin_family      = AF_INET;
-       ListenAddress.sin_addr.s_addr = htonl(INADDR_ANY);
-       ListenAddress.sin_port        = htons(ListenPort);
-
-       if(bind(SocketFile, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress))<0)
-       { Close(); return -1; }
-
-       if(listen(SocketFile, MaxConnections)<0)
-       { Close(); return -1; }
-
-       return 0; }
-
-   // accept a new client (when being a server)
-   int Accept(Socket &ClientSocket, SocketAddress &ClientAddress)
-     { ClientSocket.Close();
-       socklen_t ClientAddressLength=sizeof(ClientAddress.Address);
-       return ClientSocket.SocketFile=accept(SocketFile, (struct sockaddr *) &(ClientAddress.Address), &ClientAddressLength); }
-
-   // connect to a remote server
-   int Connect(SocketAddress &ServerAddress)
-     { if(SocketFile<0) { if(Create_STREAM()<0) return -1; } // if no socket yet, create a STREAM-type one.
-       socklen_t ServerAddressLength=sizeof(ServerAddress.Address);
-       return connect(SocketFile, (struct sockaddr *) &(ServerAddress.Address), ServerAddressLength); }
-
-   // send data (on a connected socket)
-   int Send(void *Message, int Bytes, int Flags=MSG_NOSIGNAL)
-     { return send(SocketFile, Message, Bytes, Flags); }
-
-   int Send(const char *Message)
-     { return Send((void *)Message, strlen(Message)); }
-
-   int Send(SocketBuffer &Buffer, int Flags=MSG_NOSIGNAL)
-     { size_t Bytes = Buffer.Len-Buffer.Done; // if(Bytes>4096) Bytes=4096;
-       int SentBytes=Send(Buffer.Data+Buffer.Done, Bytes, Flags);
-       if(SentBytes>0) Buffer.Done+=SentBytes;
-       return SentBytes; }
-
-   int SendFile(const char *FileName)
-   { int File=open(FileName, O_RDONLY); if(File<0) return File;
-     struct stat Stat; fstat(File, &Stat); int Size=Stat.st_size;
-     int Ret=sendfile(SocketFile, File, 0, Size);
-     close(File);
-     return Ret; }
-
-   // send data (on a non-connected socket)
-   int SendTo(const void *Message, int Bytes, SocketAddress Address, int Flags=MSG_NOSIGNAL)
-     { socklen_t AddressLength=sizeof(Address.Address);
-       return sendto(SocketFile, Message, Bytes, Flags, (struct sockaddr *) &(Address.Address), AddressLength); }
-
-   int SendTo(const void *Message, int Bytes, int Flags=MSG_NOSIGNAL)
-     { return sendto(SocketFile, Message, Bytes, Flags, 0, 0); }
-
-   // say: I won't send any more data on this connection
-   int SendShutdown(void)
-     { return shutdown(SocketFile, SHUT_WR); }
-
-#ifndef __CYGWIN__ // Cygwin C++ does not know abour TIOCOUTQ ?
-   int getSendQueue(void)
-     { int Bytes;
-       ioctl(SocketFile, TIOCOUTQ, &Bytes);
-       return Bytes; }
-#endif
-
-   // receive data (on a stream socket)
-   int Receive(void *Message, int MaxBytes, int Flags=MSG_NOSIGNAL)
-     { int Len=recv(SocketFile, Message, MaxBytes, Flags);
-       if(Len>=0) return Len;
-       return errno==EWOULDBLOCK ? 0:Len; }
-
-   // receive (stream) data into a buffer
-   int Receive(SocketBuffer &Buffer, int Flags=MSG_NOSIGNAL)
-     { size_t NewSize=Buffer.Len+Buffer.AllocUnit/2;
-       size_t Allocated=Buffer.Relocate(NewSize);
-       int MaxBytes=Allocated-Buffer.Len-1;
-       int ReceiveBytes=Receive(Buffer.Data+Buffer.Len, MaxBytes, Flags);
-       // printf("Allocated = %d, Receive(%d) => %d\n", Allocated, MaxBytes, ReceiveBytes);
-       if(ReceiveBytes>0) { Buffer.Len+=ReceiveBytes; Buffer.Data[Buffer.Len]=0; }
-       return ReceiveBytes; }
-
-   // receive data (on a non-connected socket)
-   int ReceiveFrom(void *Message, int MaxBytes, SocketAddress &Address, int Flags=MSG_NOSIGNAL)
-     { socklen_t AddressLength=sizeof(Address.Address);
-       return recvfrom(SocketFile, Message, MaxBytes, Flags, (struct sockaddr *) &(Address.Address), &AddressLength); }
-
-   // tell if socket is open
-   int isOpen(void)
-     { return SocketFile>=0; }
-
-   // close the socket
-   int Close(void)
-     { if(SocketFile>=0) close(SocketFile);
-       SocketFile=(-1); return 0; }
-
-   // get the local IP and port
-   int getLocalAddress(SocketAddress &Address)
-     { socklen_t AddressLength=sizeof(Address.Address);
-       return getsockname(SocketFile, (struct sockaddr *) &(Address.Address), &AddressLength); }
-
-   // get the remote IP and port
-   int getRemoteAddress(SocketAddress &Address)
-     { socklen_t AddressLength=sizeof(Address.Address);
-       return getpeername(SocketFile, (struct sockaddr *) &(Address.Address), &AddressLength); }
-
-   static void CopyNetToHost(uint32_t *Dst, uint32_t *Src, int Words)
-   { for( ; Words; Words--) (*Dst++) = ntohl(*Src++); }
-
-   static void CopyHostoNet(uint32_t *Dst, uint32_t *Src, int Words)
-   { for( ; Words; Words--) (*Dst++) = htonl(*Src++); }
-
-} ;
-
-class UDP_Sender
-{ public:
-   Socket Sock;
-   const static int MaxDest = 4;
-   SocketAddress Dest[MaxDest];
-
-  public:
-   void ClearDest(void)                                                     // clear the list of destination IP's
-   { for(int Idx=0; Idx<MaxDest; Idx++)
-     { Dest[Idx].setIP((long unsigned int)0); }
-   }
-
-   int Open(void)           { ClearDest(); return Sock.Create_DGRAM(); }
-   int Close(void)          { return Sock.Close(); }
-   int setNonBlocking(void) { return Sock.setNonBlocking(); }
-
-   int addDest(const char *Addr)
-   { for(int Idx=0; Idx<MaxDest; Idx++)
-     { if(Dest[Idx].getIP()==0)
-       { if(Dest[Idx].set(Addr)<0) return -1;
-         return Idx; }
-     }
-     return -1; }
-/*
-   int addBroadcast(void)
-   { int Idx;
-     for( Idx=0; Idx<MaxDest; Idx++)
-     { if(Dest[Idx].getIP()==0)
-       { if(Dest[Idx].SetIP(INADDR_BROADCAST)<0) return -1;
-         return Idx; }
-     }
-     return -1; }
-*/
-   void PrintDest(void)
-   { printf("Dest[] =");
-     for(int Idx=0; Idx<MaxDest; Idx++)
-     { if(Dest[Idx].getIP()==0) continue;
-       printf(" %s", Dest[Idx].getIPColonPort()); }
-     printf("\n");
-   }
-
-   int Send(uint32_t *Msg, int Words)
-   { return Send((void *)Msg, Words*sizeof(uint32_t)); }
-
-   int Send(void *Msg, int Bytes)
-   { int Count=0;
-     for( int Idx=0; Idx<MaxDest; Idx++)
-     { if(Dest[Idx].getIP()==0) continue;
-       if(Sock.SendTo(Msg, Bytes, Dest[Idx])<0) continue;
-       Count++; }
-     return Count; }
-
-   int Receive(void *Msg, int MaxBytes, SocketAddress &Source)
-   { return Sock.ReceiveFrom(Msg, MaxBytes, Source); }
-
-} ;
-
-class UDP_Receiver
-{ public:
-   Socket Sock;
-
-  public:
-   int Open(int Port)       { return Sock.Listen_DGRAM(Port); }
-   int Close(void)          { return Sock.Close(); }
-   int setNonBlocking(void) { return Sock.setNonBlocking(); }
-   // int getPort(void) const  { return Sock.}
-
-   int Receive(void *Msg, int MaxBytes, SocketAddress &Source)
-   { return Sock.ReceiveFrom(Msg, MaxBytes, Source); }
-
-   int Receive(uint32_t *Msg, int MaxWords, SocketAddress &Source)
-   { int Words=Sock.ReceiveFrom(Msg, MaxWords*sizeof(uint32_t), Source);
-     return Words<0 ? Words:Words/sizeof(uint32_t); }
-
-} ;
-
-#endif // of __SOCKET_H__
-
-// =========================================================================================
-
diff --git a/src/alloc.h b/src/alloc.h
new file mode 100644
index 0000000..9d2ebe1
--- /dev/null
+++ b/src/alloc.h
@@ -0,0 +1,28 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef __ALLOC_H__
+#define __ALLOC_H__
+#include <stdlib.h>
+
+template<class Type>
+ int Malloc(Type *&Data, size_t Size)
+{ Data = (Type *)malloc(Size*sizeof(Type)); return Data ? Size:0; }
+
+#endif
diff --git a/src/asciitime.h b/src/asciitime.h
new file mode 100644
index 0000000..c3284e1
--- /dev/null
+++ b/src/asciitime.h
@@ -0,0 +1,60 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifndef __ASCIITIME_H__
+#define __ASCIITIME_H__
+/*
+int SplitTime(int &Hour, int &Min, int &Sec, double &Frac, double Time)
+{ int UnixTime = (int)floor(Time); Frac=Time-UnixTime;
+  const int SecondsPerDay = 24*60*60;
+  int Day = UnixTime/SecondsPerDay;
+  UnixTime -= Day*SecondsPerDay;
+  Hour = UnixTime/3600; UnixTime-=Hour*3600;
+  Min  = UnixTime/60;   UnixTime-=Min*60;
+  Sec  = UnixTime;
+  return Day; }
+
+void AsciiTime_HHMMSSFFF(char *String, double Time)
+{ int Hour, Min, Sec; double Frac;
+  SplitTime(Hour, Min, Sec, Frac, Time);
+  sprintf(String, "%02d:%02d:%02d.%03d", Hour, Min, Sec, (int)floor(Frac*1000)); }
+
+void AsciiTime_DDDDDHHMMSSFFF(char *String, double Time)
+{ int Hour, Min, Sec; double Frac;
+  int Day=SplitTime(Hour, Min, Sec, Frac, Time);
+  sprintf(String, "%05d:%02d:%02d:%02d.%03d", Day, Hour, Min, Sec, (int)floor(Frac*1000)); }
+
+int Time_HHMMSS(time_t Time)
+{ uint32_t DayTime=Time%86400;
+  uint32_t Hour=DayTime/3600; DayTime-=Hour*3600;
+  uint32_t Min=DayTime/60; DayTime-=Min*60;
+  uint32_t Sec=DayTime;
+  return 10000*Hour + 100*Min + Sec; }
+
+int Format_HHMMSS(char *Str, time_t Time)
+{ uint32_t DayTime=Time%86400;
+  uint32_t Hour=DayTime/3600; DayTime-=Hour*3600;
+  uint32_t Min=DayTime/60; DayTime-=Min*60;
+  uint32_t Sec=DayTime;
+  uint32_t HourH=Hour/10; Str[0]='0'+HourH; Str[1]='0'+(Hour-10*HourH);
+  uint32_t  MinH=Min /10; Str[2]='0'+MinH;  Str[3]='0'+(Min -10*MinH);
+  uint32_t  SecH=Sec /10; Str[4]='0'+SecH;  Str[5]='0'+(Sec -10*SecH);
+  return 6; }
+*/
+#endif
diff --git a/src/boxfilter.h b/src/boxfilter.h
new file mode 100644
index 0000000..53c62c5
--- /dev/null
+++ b/src/boxfilter.h
@@ -0,0 +1,161 @@
+#ifndef __BOXFILTER_H__
+#define __BOXFILTER_H__
+
+#include <stdlib.h>
+#include <math.h>
+
+#include "alloc.h"
+
+// ===========================================================================================
+
+template <class Type>
+ class BoxPeakSum
+{ public:
+   int   Size;       // How many samples to remember
+   Type *Pipe;       // storage for Size most recent signals
+   int   Ptr;        // most recent signal position
+   Type  Peak;       // max. signal value
+   int   PeakPtr;    // position of max. signal
+   Type  Sum;        // sum of all signals in the Pipe
+
+  public:
+   BoxPeakSum()  { Size=0; Pipe=0; Clear(); }
+  ~BoxPeakSum()  { Free(); }
+   void Free(void) { free(Pipe); Size=0; Pipe=0; Clear(); }
+
+   void Print(void)
+   { printf("BoxPeakSum[%d]", Size);
+     for(int Idx=0; Idx<Size; Idx++)
+     { printf(" %3.1f", Pipe[Idx]); }
+     printf(" %3.1f/%3.1f %d/%d\n", Peak, Sum, PeakPtr, Ptr); }
+
+   int Preset(int Size)
+   { Free();
+     this->Size=Size;
+     if(Malloc(Pipe, Size)<=0) return -1;
+     Clear(); return Size; }
+
+   void Clear(void)
+   { Ptr=0; Peak=0; PeakPtr=0; Sum=0; for(int Idx=0; Idx<Size; Idx++) Pipe[Idx]=0; }
+
+   void ReCalc(void)
+   { Sum=0; Peak=Pipe[0]; PeakPtr=0;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Type Sig=Pipe[Idx]; Sum+=Sig;
+       if(Sig>Peak) { Peak=Sig; PeakPtr=Idx; }
+     }
+   }
+
+   // Type operator[](int Idx)
+   // { Idx+=PeakPtr; if(Idx>=Size) Idx-=Size; return Pipe[Idx]; }
+
+   Type GetPipe(int Delay=0)
+   { int Idx = Ptr-Delay; if(Idx<0) Idx+=Size; return Pipe[Idx]; }
+
+   void Process(Type Input)
+   { Ptr+=1; if(Ptr>=Size) Ptr=0;
+     Sum -=  Pipe[Ptr];
+     Sum += (Pipe[Ptr]=Input);
+     if(Input>Peak) { Peak=Input; PeakPtr=Ptr; }
+     if((Ptr==0) || (Ptr==PeakPtr) ) ReCalc(); }
+
+   int isAtPeak(void)
+   { int AntiPtr=Ptr-Size/2; if(AntiPtr<0) AntiPtr+=Size;
+     return AntiPtr==PeakPtr; } // return 1 when peak is in the center of the pipeline
+
+   Type AtPeak(int Ofs=0)
+   { int Idx=PeakPtr+Ofs;
+     if(Idx>=Size) Idx-=Size;
+     else if(Idx<0) Idx+=Size;
+     return Pipe[Idx]; }
+
+   Type PeakSum(int Radius=0)
+   { Type Sum=0; if(Radius>(Size/2)) Radius=Size/2;
+     int Count=2*Radius+1;
+     int Idx=PeakPtr-Radius; if(Idx<0) Idx+=Size;
+     for( ; Count>0; Count--)
+     { Sum+=Pipe[Idx++]; if(Idx>=Size) Idx-=Size; }
+     return Sum; }
+
+   template <class FitType>
+     int FitGauss(FitType &Peak, FitType &Pos, FitType &Sigma, Type Bias=0, int LogFit=0)
+   { int Idx = Ptr-PeakPtr; if(Idx<0) Idx+=Size; // Idx = distance from the current sample to the peak
+     Peak=this->Peak; Pos=(-Idx); Sigma=0; if( (Idx==0) || (Idx==(Size-1)) ) return -1;
+     Idx=PeakPtr;                              Type C=Pipe[Idx]-Bias; if(C<=0) return -2; // center
+     Idx=(PeakPtr-1); if(Idx<0) Idx+=Size;     Type L=Pipe[Idx]-Bias; if(L<=0) return -2; // left (before center)
+     Idx=(PeakPtr+1); if(Idx>=Size) Idx-=Size; Type R=Pipe[Idx]-Bias; if(R<=0) return -2; // right (after center)
+     if(LogFit) { C=log(C); R=log(R); L=log(L); }
+     FitType A = (R+L)/2-C; if(A>=0) return -3;     // parabole coeff: A, B, C
+     FitType B = (R-L)/2;
+     FitType D = B*B-4*A*C;                         // Delta
+     Peak = (-D/(4*A)); if(LogFit) Peak=exp(Peak); // interpolated maximum value
+     Pos += -B/(2*A);                              // interpolated position
+     if(LogFit) Sigma = sqrt(-0.5/A);              // interpolated width
+           else Sigma = sqrt(-0.5*Peak/A);
+     return 3; }
+
+   int FitTriangle(double &Peak, double &Pos)
+   { int Idx = Ptr-PeakPtr; if(Idx<0) Idx+=Size; // Idx = distance from the current sample to the peak
+     Peak=this->Peak; Pos=(-Idx); if( (Idx<2) || (Idx>=(Size-2)) ) return -1;
+     Idx=PeakPtr;                              Type C=Pipe[Idx]; // center
+     Idx=(PeakPtr-1); if(Idx<0) Idx+=Size;     Type L=Pipe[Idx]; // left (before center)
+     Idx=(PeakPtr+1); if(Idx>=Size) Idx-=Size; Type R=Pipe[Idx]; // right (after center)
+     if(R==L) return 2;
+     if(R>L)
+     { Idx=(PeakPtr+2); if(Idx>=Size) Idx-=Size; Type RR=Pipe[Idx]; // next right
+       double X = (-C+2*R-RR)/(-L+C+R-RR); Peak=C+X*(C-L); Pos+=X; }
+     else
+     { Idx=(PeakPtr-2); if(Idx<0) Idx+=Size;     Type LL=Pipe[Idx]; // next left
+       double X = (-LL+2*L-C)/(LL-L-C+R); Peak=C+X*(R-C); Pos+=X; }
+     return 2; }
+
+} ;
+
+// ===========================================================================================
+
+template <class Type, class SumType=Type>
+ class BoxSumFilter
+{ public:
+   int   Size;            // box size
+   Type *Pipe;            // box storage
+   int   Ptr;             // pipe pointer
+   SumType Output;        // filter output = sum of all elements in the box
+   int   RoundsPerRecalc; // how often to recalculate
+   int   RoundsToRecalc;  // recalc. counter
+
+  public:
+   BoxSumFilter() { Size=0; Pipe=0; Clear(); }
+  ~BoxSumFilter() { Free(); }
+   void Free(void) { free(Pipe); Size=0; Pipe=0; }
+
+   int Preset(int Size, int RoundsPerRecalc=4)
+   { Free();
+     this->Size=Size; this->RoundsPerRecalc=RoundsPerRecalc;
+     if(Malloc(Pipe, Size)<=0) return -1;
+     Clear(); return Size; }
+
+   void Clear(Type Zero=0)
+   { Ptr=0; Output=Size*(SumType)Zero; for(int Idx=0; Idx<Size; Idx++) Pipe[Idx]=Zero; RoundsToRecalc=RoundsPerRecalc; }
+
+   void ReCalc(void)
+   { Output=0; for(int Idx=0; Idx<Size; Idx++) Output+=Pipe[Idx]; }
+
+   Type Process(Type Input)
+   { Ptr+=1; if(Ptr>=Size) Ptr=0;
+     Output-=Pipe[Ptr];
+     Output+=(Pipe[Ptr]=Input);
+     if( (Ptr==0) && RoundsPerRecalc )
+     { RoundsToRecalc--;
+       if(RoundsToRecalc==0)
+       { ReCalc(); RoundsToRecalc=RoundsPerRecalc; }
+     }
+     return Output; }
+
+   SumType Average(void) { return Output/Size; }
+   Type operator[](int Delay) { int Idx=Ptr-Delay; if(Idx<0) Idx+=Size; return Pipe[Idx]; }
+} ;
+
+
+// ===========================================================================================
+
+#endif // __BOXFILTER_H__
diff --git a/src/buffer.h b/src/buffer.h
new file mode 100644
index 0000000..e7908dc
--- /dev/null
+++ b/src/buffer.h
@@ -0,0 +1,593 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __BUFFER_H_
+#define __BUFFER_H_
+
+#include <unistd.h>
+
+#include <string.h>
+
+#include "fft.h"
+#include "r2fft.h"
+
+#include "serialize.h"
+
+// ==================================================================================================
+
+template <class Type>
+ class SampleBuffer  // a buffer to hold a batch of samples
+{ public:
+   int32_t Size;  // allocated size ot data
+   int32_t Full;  // number of values in the buffer
+   int32_t Len;   // number of values per sample
+
+   double Rate;   // [Hz]  sampling rate
+   double Time;   // [sec] time when samples were acquired
+   double Freq;   // [Hz]  RF frequency where samples were acquired
+
+   Type  *Data;  // (allocated) storage
+
+  public:
+   SampleBuffer() { Size=0; Data=0; Full=0; Len=1; }
+  ~SampleBuffer() { Free(); }
+
+   void Free(void) { if(Data) delete [] Data; Data=0; Size=0; Full=0; }
+
+   int Allocate(int NewSize)
+   { if(NewSize<=Size) { Full=0; return Size; } // for timing eficiency: do not reallocate if same or bigger size already allocated
+     Free();
+     Data = new (std::nothrow) Type [NewSize]; if(Data==0) { Size=0; Full=0; return Size; }
+     Size=NewSize; return Size; }
+
+   int Allocate(int NewLen, int Samples)
+   { Allocate(NewLen*Samples); Len=NewLen; return Size; }
+
+   int Samples(void) const { return Full/Len; }                // number of samples
+   Type *SamplePtr(int Idx) const { return Data+Idx*Len; }     // pointer to an indexed sample
+   Type &operator [](int Idx) { return Data[Idx]; }            // reference to an indexed value
+
+   Type *Sample(int Idx) { return Data + Idx*Len; }
+
+   template <class OtherType>                                  // allocate after another SampleBuffer
+    int Allocate(SampleBuffer<OtherType> &Buffer)
+   { Allocate(Buffer.Size);
+     Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time; Freq=Buffer.Freq; return Size; }
+
+   void Set(Type Value=0)
+   { Type *DataPtr=Data; for(int Idx=0; Idx<Size; Idx++) (*DataPtr++)=Value; }
+
+   double Average(void) const
+   { double Sum=0;
+     for(int Idx=0; Idx<Full; Idx++) Sum+=Data[Idx];
+     return Sum/Full; }
+
+   void Crop(int Head, int Tail)
+   { int NewFull=Full-(Head+Tail)*Len;
+     if(Head)
+     { memmove(Data, Data+Head*Len, NewFull*sizeof(Type));
+       Time+=Head/Rate; }
+     Full=NewFull; }
+
+   int Copy(SampleBuffer<Type> &Buffer)                        // allocate and copy from another SampleBuffer
+   { Allocate(Buffer.Size); memcpy(Data, Buffer.Data, Size*sizeof(Type));
+     Full=Buffer.Full; Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time; Freq=Buffer.Freq; return Size; }
+
+   int CopySample(SampleBuffer<Type> &Buffer, int Idx)         // copy just one sample (but can be more than one value)
+   { Allocate(Buffer->Len);
+     Full=Buffer.Len; Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time+Idx/Rate; Freq=Buffer.Freq;
+     memcpy(Data, Buffer.Data + Idx*Len, Len*sizeof(Type));
+     return Size; }
+
+   template <class OtherType>
+    int CopySampleSum(SampleBuffer<OtherType> &Buffer)                     // copy the sum of all samples
+   { return CopySampleSum(Buffer, 0, Buffer.Samples()-1); }
+
+   template <class OtherType>
+    int CopySampleSum(SampleBuffer<OtherType> &Buffer, int Idx1, int Idx2) // copy the sum of several samples
+   { Allocate(Buffer.Len);
+     Full=Buffer.Len; Len=Buffer.Len; Rate=Buffer.Rate; Time=Buffer.Time+0.5*(Idx1+Idx2)/Rate; Freq=Buffer.Freq;
+     for(int Idx=0; Idx<Len; Idx++) { Data[Idx]=0; }
+     for(int sIdx=Idx1; sIdx<=Idx2; sIdx++)
+     { Type *sPtr = Buffer.Data + sIdx*Len;
+       for(int Idx=0; Idx<Len; Idx++) { Data[Idx]+=sPtr[Idx]; }
+     }
+     return Size; }
+
+   template <class ScaleType>
+    void operator *= (ScaleType Scale)
+   { for(int Idx=0; Idx<Full; Idx++) Data[Idx]*=Scale; }
+
+   int WritePlotFile(const char *FileName, int StartIdx=0, int Values=0) const
+   { if(Values==0) Values=Size-StartIdx;
+     FILE *File=fopen(FileName, "wt"); if(File==0) return 0;
+     fprintf(File, "# %d x %d, Time=%17.6fsec, Freq=%10.6fMHz, Rate=%8.6fMHz\n", Samples(), Len, Time, 1e-6*Freq, 1e-6*Rate);
+     for(int Idx=StartIdx; Idx<Size; Idx++)
+     { if((Idx-StartIdx)>=Values) break;
+       fprintf(File, "%4d: %+12.6f\n", Idx, Data[Idx] ); }
+     fclose(File); return Size; }
+
+   int WriteComplexPlotFile(const char *FileName, int StartIdx=0, int Values=0) const
+   { if(Values==0) Values=Size-StartIdx;
+     FILE *File=fopen(FileName, "wt"); if(File==0) return 0;
+     fprintf(File, "# %d x %d, Time=%17.6fsec, Freq=%10.6fMHz, Rate=%8.6fMHz\n", Samples(), Len, Time, 1e-6*Freq, 1e-6*Rate);
+     fprintf(File, "# Index      Real         Imag         Magn  Phase[deg]\n");
+     for(int Idx=StartIdx; Idx<Size; Idx++)
+     { if((Idx-StartIdx)>=Values) break;
+       fprintf(File, "%4d: %+12.6f %+12.6f %12.6f %+9.3f\n", Idx, real(Data[Idx]), imag(Data[Idx]), sqrt(norm(Data[Idx])), (180/M_PI)*arg(Data[Idx]) ); }
+     fclose(File); return Size; }
+
+  template <class StreamType>
+   int Serialize(StreamType File) // write SampleBuffer to a file/socket
+   { int Total=0, Bytes;
+     Bytes=SerializeWriteData(File, &Size, sizeof(int32_t)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeWriteData(File, &Full, sizeof(int32_t)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeWriteData(File, &Len , sizeof(int32_t)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeWriteData(File, &Rate, sizeof(double)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeWriteData(File, &Time, sizeof(double)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeWriteData(File, &Freq, sizeof(double)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeWriteData(File,  Data, Full*sizeof(Type)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     return Total; }
+
+  template <class StreamType>
+   int Deserialize(StreamType File)  // read SampleBuffer from a file/socket
+   { int Total=0, Bytes;
+     int32_t NewSize=0;
+     Bytes=SerializeReadData(File, &NewSize, sizeof(int32_t)); if(Bytes<0) return -1;
+     if(NewSize<0) return -1;
+     Total+=Bytes;
+     if(Allocate(NewSize)==0) return -2;
+     Bytes=SerializeReadData(File, &Full, sizeof(int32_t)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeReadData(File, &Len , sizeof(int32_t)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeReadData(File, &Rate, sizeof(double)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeReadData(File, &Time, sizeof(double)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeReadData(File, &Freq, sizeof(double)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     Bytes=SerializeReadData(File,  Data, Full*sizeof(Type)); if(Bytes<0) return -1;
+     Total+=Bytes;
+     return Total; }
+
+   int Write(FILE *File) // write all samples onto a binary file (with header)
+   { if(fwrite(&Size, sizeof(Size), 1, File)!=1) return -1;
+     if(fwrite(&Full, sizeof(Full), 1, File)!=1) return -1;
+     if(fwrite(&Len,  sizeof(Len),  1, File)!=1) return -1;
+     if(fwrite(&Rate, sizeof(Rate), 1, File)!=1) return -1;
+     if(fwrite(&Time, sizeof(Time), 1, File)!=1) return -1;
+     if(fwrite(&Freq, sizeof(Freq), 1, File)!=1) return -1;
+     if(fwrite(Data,  sizeof(Type), Size, File)!=(size_t)Size) return -1;
+     return 1; }
+
+   int Read(FILE *File) // read samples from a binary file (with header)
+   { if(fread(&Size, sizeof(Size), 1, File)!=1) return -1;
+     if(fread(&Full, sizeof(Full), 1, File)!=1) return -1;
+     if(fread(&Len,  sizeof(Len),  1, File)!=1) return -1;
+     if(fread(&Rate, sizeof(Rate), 1, File)!=1) return -1;
+     if(fread(&Time, sizeof(Time), 1, File)!=1) return -1;
+     if(fread(&Freq, sizeof(Freq), 1, File)!=1) return -1;
+     Allocate(Size);
+     if(fread(Data,  sizeof(Type), Size, File)!=(size_t)Size) return -1;
+     return 1; }
+
+   int ReadRaw(FILE *File, int Len, int MaxSamples, double Rate=1) // read samples from a raw binary file
+   { Allocate(Len, MaxSamples); this->Rate=Rate;
+     int Read=fread(Data,  Len*sizeof(Type), MaxSamples, File);
+     Full=Len*Read; return Full; }
+
+   int ReadRaw(const char *FileName, int Len, int MaxSamples, double Rate=1)
+   { FILE *File=fopen(FileName, "rb"); if(!File) return -1;
+     int Ret=ReadRaw(File, Len, MaxSamples, Rate);
+     fclose(File); return Ret; }
+} ;
+
+// ==================================================================================================
+
+// Note 1: the sliding FFT routines below take sliding step = half the FFT window size (thus SineWindow should be used)
+// Note 2: the FFT output spectra have the two halfs swapped around thus the FFT amplitude corresponding to the center frequency is in the middle
+
+template <class Float>
+ int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer<uint8_t> &Input,
+                InpSlideFFT<Float> &FFT, Float InpBias=127.38)
+{ return SlidingFFT(Output, Input, FFT.FwdFFT, FFT.Window, InpBias); }
+
+template <class Float> // do sliding FFT over a buffer of (complex 8-bit) samples, produce (float/double complex) spectra
+ int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer<uint8_t> &Input,
+                DFT1d<Float> &FwdFFT, Float *Window, Float InpBias=127.38)
+{ int WindowSize = FwdFFT.Size;                                                        // FFT object and Window shape are prepared already
+  int WindowSize2=WindowSize/2;                                                        // Slide step
+  int InpSamples=Input.Full/2;                                                         // number of complex,8-bit input samples
+  // printf("SlidingFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSamples);
+  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
+  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
+  uint8_t *InpData = Input.Data;
+  std::complex<Float> *OutData = Output.Data;
+  int Slides=0;
+  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // first slide is special
+    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
+    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
+      InpData+=2; }
+    FwdFFT.Execute();                                             // execute FFT
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // copy spectra into the output buffer
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // swap around the two halfs
+    InpData-=2*WindowSize2; Slides++; }
+  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
+  { std::complex<Float> *Buffer = FwdFFT.Buffer;
+    for( int Bin=0; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
+      InpData+=2; }
+    FwdFFT.Execute();
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    InpData-=2*WindowSize2; Slides++; }
+  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // and the last slide: special
+    for( int Bin=0; Bin<WindowSize2; Bin++)
+    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
+      InpData+=2; }
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = 0; }
+    FwdFFT.Execute();
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    InpData-=2*WindowSize2; Slides++; }
+
+  Output.Full=Slides*WindowSize;
+  return Slides; }
+
+// --------------------------------------------------------------------------------------------------
+
+template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
+ int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
+                DFT1d<Float> &FwdFFT, Float *Window)
+{ int WindowSize = FwdFFT.Size;                                                        // FFT object and Window shape are prepared already
+  int WindowSize2=WindowSize/2;                                                        // Slide step
+  int InpSamples=Input.Full;                                                           // number of complex float/double samples
+  // printf("SlidingFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSamples);
+  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
+  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
+  std::complex<Float> *InpData = Input.Data;
+  std::complex<Float> *OutData = Output.Data;
+  int Slides=0;
+  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // first slide is special
+    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
+    { Buffer[Bin] = Window[Bin]*InpData[Bin-WindowSize2]; }
+    FwdFFT.Execute();                                             // execute FFT
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // copy spectra into the output buffer
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // swap around the two halfs
+    Slides++; }
+  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
+  { std::complex<Float> *Buffer = FwdFFT.Buffer;
+    for( int Bin=0; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
+    FwdFFT.Execute();
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    InpData+=WindowSize2; Slides++; }
+  { std::complex<Float> *Buffer = FwdFFT.Buffer;                  // and the last slide: special
+    for( int Bin=0; Bin<WindowSize2; Bin++)
+    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = 0; }
+    FwdFFT.Execute();
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    InpData+=WindowSize2; Slides++; }
+
+  Output.Full=Slides*WindowSize;
+  return Slides; }
+
+template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
+ int ReconstrFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
+                 DFT1d<Float> &InvFFT, Float *Window)
+{ int WindowSize = InvFFT.Size;                                                        // FFT object and Window shape are prepared already
+  int WindowSize2=WindowSize/2;                                                        // Slide step
+  int InpSlides=Input.Samples();                                                       //
+  // printf("ReconstrFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSlides);
+  Output.Allocate(1, (InpSlides+1)*WindowSize2);                                     // output is complex time-linear samples
+  Output.Rate=Input.Rate*WindowSize2; Output.Time=Input.Time-1.0/Input.Rate; Output.Freq=Input.Freq;
+  std::complex<Float> *InpData = Input.Data;
+  std::complex<Float> *OutData = Output.Data;
+  int Slides=0;
+  { std::complex<Float> *Buffer = InvFFT.Buffer;
+    memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
+    memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
+    InvFFT.Execute();
+    for(int Idx=0; Idx<WindowSize; Idx++)
+    { OutData[Idx]=Window[Idx]*Buffer[Idx]; }
+    OutData+=WindowSize2; Slides++; InpSlides--; }
+  for( ; InpSlides; )
+  { std::complex<Float> *Buffer = InvFFT.Buffer;
+    memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
+    memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
+    InvFFT.Execute();
+    for(int Idx=0; Idx<WindowSize2; Idx++)
+    { OutData[Idx]+=Window[Idx]*Buffer[Idx]; }
+    for(int Idx=WindowSize2; Idx<WindowSize; Idx++)
+    { OutData[Idx]=Window[Idx]*Buffer[Idx]; }
+    OutData+=WindowSize2; Slides++; InpSlides--; }
+
+  Output.Full=(Slides+1)*WindowSize2;
+  return Slides; }
+
+// ==================================================================================================
+// Sliding FFT with r2FFT (no open-source restrictions)
+
+template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
+ int SlidingFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
+                r2FFT<Float> &FFT, Float *Window, std::complex<Float> *Buffer)
+{ int WindowSize = FFT.Size;                                                        // FFT object and Window shape are prepared already
+  int WindowSize2=WindowSize/2;                                                        // Slide step
+  int InpSamples=Input.Full;                                                           // number of complex float/double samples
+  // printf("SlidingFFT() %d point FFT, %d input samples\n", FFT.Size, InpSamples);
+  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
+  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
+  std::complex<Float> *InpData = Input.Data;
+  std::complex<Float> *OutData = Output.Data;
+  int Slides=0;
+  {                                                                 // first slide is special
+    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
+    { Buffer[Bin] = Window[Bin]*InpData[Bin-WindowSize2]; }
+    FFT.Process(Buffer);                                            // execute FFT
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // copy spectra into the output buffer
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;  // swap around the two halfs
+    Slides++; }
+  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
+  {
+    for( int Bin=0; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
+    FFT.Process(Buffer);
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    InpData+=WindowSize2; Slides++; }
+  {                                                                // and the last slide: special
+    for( int Bin=0; Bin<WindowSize2; Bin++)
+    { Buffer[Bin] = Window[Bin]*InpData[Bin]; }
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = 0; }
+    FFT.Process(Buffer);
+    memcpy(OutData, Buffer+WindowSize2, WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    memcpy(OutData, Buffer,             WindowSize2*sizeof(std::complex<Float>)); OutData+=WindowSize2;
+    InpData+=WindowSize2; Slides++; }
+
+  Output.Full=Slides*WindowSize;
+  return Slides; }
+
+template <class Float> // do sliding FFT over a buffer of float/double complex samples, produce (float/double complex) spectra
+ int ReconstrFFT(SampleBuffer< std::complex<Float> > &Output, SampleBuffer< std::complex<Float> > &Input,
+                 r2FFT<Float> &FFT, Float *Window, std::complex<Float> *Buffer)
+{ int WindowSize = FFT.Size;                                                           // FFT object and Window shape are prepared already
+  int WindowSize2=WindowSize/2;                                                        // Slide step
+  int InpSlides=Input.Samples();                                                       //
+  // printf("ReconstrFFT() %d point FFT, %d input samples\n", FwdFFT.Size, InpSlides);
+  Output.Allocate(1, (InpSlides+1)*WindowSize2);                                     // output is complex time-linear samples
+  Output.Rate=Input.Rate*WindowSize2; Output.Time=Input.Time-1.0/Input.Rate; Output.Freq=Input.Freq;
+  std::complex<Float> *InpData = Input.Data;
+  std::complex<Float> *OutData = Output.Data;
+  int Slides=0;
+  {
+    // memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
+    // memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
+    for(int Idx=0; Idx<WindowSize2; Idx++)
+    { Buffer[WindowSize2+Idx] = conj(InpData[Idx]); }
+    InpData+=WindowSize2;
+    for(int Idx=0; Idx<WindowSize2; Idx++)
+    { Buffer[            Idx] = conj(InpData[Idx]); }
+    InpData+=WindowSize2;
+    FFT.Process(Buffer);
+    for(int Idx=0; Idx<WindowSize; Idx++)
+    { OutData[Idx]=Window[Idx]*conj(Buffer[Idx]); }
+    OutData+=WindowSize2; Slides++; InpSlides--; }
+  for( ; InpSlides; )
+  {
+    // memcpy(Buffer+WindowSize2, InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // copy spectra into the output buffer
+    // memcpy(Buffer,             InpData, WindowSize2*sizeof(std::complex<Float>)); InpData+=WindowSize2;  // swap around the two halfs
+    for(int Idx=0; Idx<WindowSize2; Idx++)
+    { Buffer[WindowSize2+Idx] = conj(InpData[Idx]); }
+    InpData+=WindowSize2;
+    for(int Idx=0; Idx<WindowSize2; Idx++)
+    { Buffer[            Idx] = conj(InpData[Idx]); }
+    InpData+=WindowSize2;
+    FFT.Process(Buffer);
+    for(int Idx=0; Idx<WindowSize2; Idx++)
+    { OutData[Idx]+=Window[Idx]*conj(Buffer[Idx]); }
+    for(int Idx=WindowSize2; Idx<WindowSize; Idx++)
+    { OutData[Idx]=Window[Idx]*conj(Buffer[Idx]); }
+    OutData+=WindowSize2; Slides++; InpSlides--; }
+
+  Output.Full=(Slides+1)*WindowSize2;
+  return Slides; }
+
+// ==================================================================================================
+
+#ifdef USE_RPI_GPU_FFT
+
+// template <class Float> // do sliding FFT over a buffer of (complex 8-bit) samples, produce (float/double complex) spectra
+ int SlidingFFT(SampleBuffer< std::complex<float> > &Output, SampleBuffer<uint8_t> &Input,
+                RPI_GPU_FFT &FwdFFT, float *Window, float InpBias=127.38)
+{ int Jobs = FwdFFT.Jobs;
+  int WindowSize = FwdFFT.Size;                                                        // FFT object and Window shape are prepared already
+  int WindowSize2=WindowSize/2;                                                          // Slide step
+  int InpSamples=Input.Full/2;                                                         // number of complex,8-bit input samples
+  // printf("SlidingFFT(RPI_GPU_FFT) %d point FFT, %d jobs/GPU, %d input samples\n", FwdFFT.Size, Jobs, InpSamples);
+  Output.Allocate((InpSamples/WindowSize2+1)*WindowSize); Output.Len=WindowSize;         // output is rows of spectral data
+  Output.Rate=Input.Rate/WindowSize2; Output.Time=Input.Time; Output.Freq=Input.Freq;
+
+  uint8_t *InpData = Input.Data;
+  std::complex<float> *OutData = Output.Data;
+  int Slides=0; int Job=0;
+  { std::complex<float> *Buffer = FwdFFT.Input(Job);                // first slide is special
+    for( int Bin=0; Bin<WindowSize2; Bin++) { Buffer[Bin] = 0; }    // half the window is empty
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)                // the other half contains the first input samples
+    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
+      InpData+=2; }
+    Job++; InpData-=2*WindowSize2; }
+  for( ; InpSamples>=WindowSize; InpSamples-=WindowSize2)           // now the following slides
+  { std::complex<float> *Buffer = FwdFFT.Input(Job);
+    for( int Bin=0; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias) );
+      InpData+=2; }
+    Job++; InpData-=2*WindowSize2;
+    if(Job>=Jobs)
+    { FwdFFT.Execute();
+      for(int J=0; J<Jobs; J++)
+      { memcpy(OutData, FwdFFT.Output(J)+WindowSize2, WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2;
+        memcpy(OutData, FwdFFT.Output(J),             WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2; }
+      Slides+=Jobs; Job=0;
+    }
+  }
+  { std::complex<float> *Buffer = FwdFFT.Input(Job);                  // and the last slide: special
+    for( int Bin=0; Bin<WindowSize2; Bin++)
+    { Buffer[Bin] = std::complex<float>( Window[Bin]*(InpData[0]-InpBias), Window[Bin]*(InpData[1]-InpBias));
+      InpData+=2; }
+    for( int Bin=WindowSize2; Bin<WindowSize; Bin++)
+    { Buffer[Bin] = 0; }
+    Job++; InpData-=2*WindowSize2;
+    { FwdFFT.Execute();
+      for(int J=0; J<Job; J++)
+      { memcpy(OutData, FwdFFT.Output(J)+WindowSize2, WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2;
+        memcpy(OutData, FwdFFT.Output(J),             WindowSize2*sizeof(std::complex<float>)); OutData+=WindowSize2; }
+      Slides+=Job; Job=0;
+    }
+  }
+
+  // printf("SlidingFFT(RPI_GPU_FFT) %d slides\n", Slides);
+  Output.Full=Slides*WindowSize;
+  return Slides; }
+
+#endif
+
+// ==================================================================================================
+
+template <class Float>
+ inline Float Power(Float *X)
+{ Float Re=X[0]; Float Im=X[1]; return Re*Re+Im*Im; }
+
+template <class Float>
+ inline Float Power(std::complex<Float> &X)
+{ Float Re=real(X); Float Im=imag(X); return Re*Re+Im*Im; }
+
+template <class Float>  // convert (complex) spectra to power (energy)
+ void SpectraPower(SampleBuffer<Float> &Output, SampleBuffer< std::complex<Float> > &Input)
+{ Output.Allocate(Input); int WindowSize=Input.Len;
+  std::complex<Float> *InpData=Input.Data;
+  Float *OutData=Output.Data;
+  int Slides=Input.Full/Input.Len;
+  for( int Slide=0; Slide<Slides; Slide++)
+  { for( int Bin=0; Bin<WindowSize; Bin++)
+    { OutData[Bin] = Power(InpData[Bin]); }
+    InpData+=WindowSize; OutData+=WindowSize; }
+  Output.Time=Input.Time; Output.Rate=Input.Rate; Output.Freq=Input.Freq;
+  Output.Full=Input.Full; }
+
+template <class Float>  // convert (complex) spectra to power (energy) - at same time calc. the average spectra power
+ Float SpectraPower(SampleBuffer<Float> &Output, SampleBuffer< std::complex<Float> > &Input, int LowBin, int Bins)
+{ int WindowSize=Input.Len;
+  int Slides=Input.Full/WindowSize;
+  Output.Allocate(Bins,Slides);
+  Float *OutData=Output.Data;
+  double Sum=0;
+  for( int Slide=0; Slide<Slides; Slide++)
+  { std::complex<Float> *InpData=Input.Data+(Slide*WindowSize+LowBin);
+    for( int Bin=0; Bin<Bins; Bin++)
+    { Sum += OutData[Bin] = Power(InpData[Bin]); }
+    OutData+=Bins; }
+  Output.Full=Bins*Slides;
+  Output.Time=Input.Time; Output.Rate=Input.Rate; // Output.Freq=Input.Freq;
+  return Sum/Output.Full; }
+
+template <class Float>
+ Float SpectraPowerLogHist(int *LogHist, SampleBuffer<Float> &Power, Float Median)
+{ Float Thres[3];
+  Thres[0]=Median; Thres[1]=2*Median; Thres[2]=4*Median;
+  LogHist[0]=0;    LogHist[1]=0;      LogHist[2]=0;      LogHist[3]=0;
+  for(int Idx=0; Idx<Power.Full; Idx++)
+  { Float Pwr=Power.Data[Idx];
+    if(Pwr<Thres[0]) { LogHist[0]++; continue; }
+    if(Pwr<Thres[1]) { LogHist[1]++; continue; }
+    if(Pwr<Thres[2]) { LogHist[2]++; continue; }
+    LogHist[3]++;
+  }
+  if(LogHist[1]==0) return 0;
+  return -Median/log((double)LogHist[1]/LogHist[0]); } // return estimated sigma of the noise
+
+template <class Float>
+ Float SpectraPowerLogHist(SampleBuffer<Float> &Power, Float Median)
+{ int LogHist[4]; return SpectraPowerLogHist(LogHist, Power, Median); }
+
+template <class Float>
+ Float SpectraPowerLogHist(int *LogHist, SampleBuffer<Float> &Power, Float Median, int HistSize)
+{ Float Thres[HistSize-1];
+  LogHist[0]=0; Thres[0]=Median;
+  for(int Bin=1; Bin<(HistSize-1); Bin++)
+  { LogHist[Bin]=0; Thres[Bin]=2*Thres[Bin-1]; }
+  LogHist[HistSize-1]=0;
+  for(int Idx=0; Idx<Power.Full; Idx++)
+  { Float Pwr=Power.Data[Idx];
+    int Bin;
+    for(Bin=0; Bin<(HistSize-1); Bin++)
+    { if(Pwr<Thres[Bin]) { LogHist[Bin]+=1; break; } }
+    if(Bin==(HistSize-1)) LogHist[HistSize-1]+=1;
+  }
+  if(LogHist[1]==0) return 0;
+  return -Median/log((double)LogHist[1]/LogHist[0]); } // return estimated sigma of the noise
+
+template <class Float>
+ Float SpectraPowerLogHist(SampleBuffer<Float> &Power, Float Median, int HistSize)
+{ int LogHist[HistSize]; return SpectraPowerLogHist(LogHist, Power, Median, HistSize); }
+
+// ==================================================================================================
+
+template <class Float>       // write an image (.pgm) spectrogram file out of the spectra power data
+ int Spectrogram(const Float *Power, int Slides, int SpectraSize, const char *ImageFileName, Float RefPwr=1.00)
+{
+  FILE *ImageFile=0; if(ImageFileName) ImageFile=fopen(ImageFileName, "wb");
+  if(ImageFile==0) return -1;
+  fprintf(ImageFile, "P5\n%5d %6d\n255\n", SpectraSize, Slides);
+  uint8_t ImageLine[SpectraSize];
+  for(int Slide=0; Slide<Slides; Slide++)
+  { for(int Idx=0; Idx<SpectraSize; Idx++)
+    { Float Pwr = (*Power++);
+      int Pixel=0;
+      if(Pwr>0) Pixel = (int)floor(16+100.0*log10(Pwr/RefPwr)+0.5);
+      if(Pixel<0) { Pixel=0; } else if(Pixel>255) { Pixel=255; }
+      ImageLine[Idx]=Pixel; }
+    fwrite(ImageLine, 1, SpectraSize, ImageFile);
+  }
+  fclose(ImageFile); return Slides*SpectraSize; }
+
+template <class Float>
+ int Spectrogram(SampleBuffer<Float> &SpectraPower, const char *ImageFileName, Float RefPwr=1.00)
+{ return Spectrogram(SpectraPower.Data, SpectraPower.Samples(), SpectraPower.Len, ImageFileName, RefPwr); }
+
+// ==================================================================================================
+
+#endif // __BUFFER_H_
diff --git a/src/fft.h b/src/fft.h
new file mode 100644
index 0000000..5850ac6
--- /dev/null
+++ b/src/fft.h
@@ -0,0 +1,368 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __FFT_H__
+#define __FFT_H__
+
+#include <stdint.h>
+#include <math.h>
+
+// #include <cmath> // for M_PI in C++11 - no, does not work
+#include <complex>
+#include <new>
+
+#include <fftw3.h>
+
+// ===========================================================================================
+
+template <class Float>
+ class DFT1d
+{ public:
+   std::complex<Float> *Buffer; // input and output buffer
+   fftw_plan            Plan;   // FFTW specific
+   int                  Size;   // [FFT points]
+   int                  Sign;   // forward or backward (inverse)
+
+  public:
+   DFT1d() { Buffer=0; Plan=0; Size=0; Sign=0; }
+
+  ~DFT1d() { Free(); }
+
+  void Free(void)
+   { if(Buffer) { fftw_destroy_plan(Plan); fftw_free(Buffer); Buffer=0; Size=0; Sign=0; } }
+
+  int Preset(int Size, int Sign)
+  { if( (Size==this->Size) && (Sign==this->Sign) ) return Size;
+    Free();
+    Buffer = (std::complex<Float> *)fftw_malloc(Size*sizeof(std::complex<Float>)); if(Buffer==0) return -1;
+    Plan = fftw_plan_dft_1d(Size, (fftw_complex *)Buffer, (fftw_complex *)Buffer, Sign, FFTW_MEASURE);
+    this->Size=Size; this->Sign=Sign; return Size; }
+
+  int PresetForward(int Size) { return Preset(Size, FFTW_FORWARD); }
+  int PresetBackward(int Size) { return Preset(Size, FFTW_BACKWARD); }
+
+  template <class Type>
+   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
+  { for(int Idx=0; Idx<WindowSize; Idx++)
+    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
+  }
+
+  std::complex<Float>& operator [] (int Idx) { return Buffer[Idx]; }  // access to input/output buffer
+
+  void Execute(void) { return fftw_execute(Plan); }
+
+  void PrintPlan(void) { fftw_print_plan(Plan); printf("\n"); }
+
+} ;
+
+// ----------------------------------------------------------------------------------------------
+
+template <>
+ class DFT1d <float>
+{ public:
+   std::complex<float> *Buffer;
+   fftwf_plan           Plan;
+   int                  Size;
+   int                  Sign;
+
+  public:
+   DFT1d() { Buffer=0; Plan=0; Size=0; Sign=0; }
+
+  ~DFT1d() { Free(); }
+
+  void Free(void)
+   { if(Buffer) { fftwf_destroy_plan(Plan); fftwf_free(Buffer); Buffer=0; Size=0; Sign=0; } }
+
+  int Preset(int Size, int Sign)
+  { if( (Size==this->Size) && (Sign==this->Sign) ) return Size;
+    Free();
+    Buffer = (std::complex<float> *)fftwf_malloc(Size*sizeof(std::complex<float>)); if(Buffer==0) return -1;
+    Plan = fftwf_plan_dft_1d(Size, (fftwf_complex *)Buffer, (fftwf_complex *)Buffer, Sign, FFTW_MEASURE);
+    this->Size=Size; this->Sign=Sign; return Size; }
+
+  int PresetForward(int Size) { return Preset(Size, FFTW_FORWARD); }
+  int PresetBackward(int Size) { return Preset(Size, FFTW_BACKWARD); }
+
+  template <class Type>
+   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
+  { for(int Idx=0; Idx<WindowSize; Idx++)
+    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
+  }
+
+  std::complex<float>& operator [] (int Idx) { return Buffer[Idx]; }  // access to input/output buffer
+
+  void Execute(void) { return fftwf_execute(Plan); }
+
+  void PrintPlan(void) { fftwf_print_plan(Plan); printf("\n"); }
+
+} ;
+
+// ===========================================================================================
+
+template <class Float=double>
+ class InpSlideFFT
+{ public:
+   DFT1d<Float>         FwdFFT;       // forward FFT
+   int                  WindowSize;   // Window size = FFT size
+   int                  SlideSize;    // slide step for sliding-window FFT
+   Float               *Window;       // Window shape (Hanning)
+   std::complex<Float> *Pipe;         // input circular buffer
+   int                  Ptr;          // wrap-around input buffer pointer
+   std::complex<Float> *Output;       // pointer to FFT spectra
+
+  public:
+   InpSlideFFT() { WindowSize=0; Window=0; Pipe=0; }
+  ~InpSlideFFT() { Free(); }
+   void Free(void)  { delete [] Window; delete [] Pipe; Window=0; Pipe=0; WindowSize=0; }
+
+   int Size(void) const { return FwdFFT.Size; }
+   int Preset(int Size)
+   { // if(Size==WindowSize) return Size;
+     Free();                                             // deallocate everything
+     if(FwdFFT.PresetForward(Size)<0) return -1;         // setup forward FFT
+     WindowSize=Size;
+     Window = new (std::nothrow) Float               [WindowSize]; if(Window==0) return -1;
+     Pipe   = new (std::nothrow) std::complex<Float> [WindowSize]; if(Pipe==0) return -1;
+     SetSineWindow(); return Size; }                     // return FFT size (or negative when allocations failed)
+
+   void Clear(void) { for(int Idx=0; Idx<WindowSize; Idx++) { Pipe[Idx]=0; } Ptr=WindowSize-SlideSize; }
+
+   void SetHannWindow(int Slide=0)
+   { Float Scale=1.0/sqrt(WindowSize);                  // scale factor (forward+backward FFT scale data up by size)
+     for(int Idx=0; Idx<WindowSize; Idx++)
+     { Window[Idx]=Scale*(1.0-cos((2*M_PI*Idx)/WindowSize)); }
+     if(Slide==0) Slide=WindowSize/4;
+     SlideSize=Slide; Clear(); }
+
+   void SetSineWindow(int Slide=0)
+   { Float Scale=1.0/sqrt(WindowSize);
+     for(int Idx=0; Idx<WindowSize; Idx++)
+     { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
+   if(Slide==0) Slide=WindowSize/2;
+   SlideSize=Slide; Clear(); }
+
+   void SetGaussWindow(double Sigma, int Slide)
+   { int WindowSize2 = WindowSize/2;
+     for(int Idx=0; Idx<WindowSize; Idx++)
+     { double D=Idx-WindowSize2;
+       Window[Idx]=exp(-(D*D)/(2*Sigma*Sigma)); }
+   SlideSize=Slide; Clear(); }
+
+   void PrintWindow(void)
+   { printf("InpSlideFFT::Window[%d] =", WindowSize);
+     for(int Idx=0; Idx<WindowSize; Idx++)
+       printf(" %+5.3f", Window[Idx]);
+     printf("\n"); }
+
+   int Process(const uint8_t *Input, Float Bias=127.38)       // process exactly one slide [SlideSize] of samples
+   { int Idx;
+     if(Input)                                                    //
+     { for(Idx=0; Idx<SlideSize; Idx++)                           // enter new samples into the Pipe
+       { std::complex<Float> CmpxInput(Input[0]-Bias, Input[1]-Bias);
+         Pipe[Ptr++] = CmpxInput; Input+=2;
+         if(Ptr>=WindowSize) Ptr=0; }
+     } else                                                       // if no Input given
+     { for(Idx=0; Idx<SlideSize; Idx++)                           // enter zeros into the pipe
+       { Pipe[Ptr++] = 0; if(Ptr>=WindowSize) Ptr=0; }
+     }
+     return ProcessWindow(); }
+
+  template <class InpFloat>
+   int Process(std::complex<InpFloat> *Input)                      // process exactly one slide [SlideSize] of samples
+   { int Idx;
+     if(Input)
+     { for(Idx=0; Idx<SlideSize; Idx++)                            // enter new samples into the Pipe
+       { Pipe[Ptr++] = Input[Idx]; if(Ptr>=WindowSize) Ptr=0; }
+     } else
+     { for(Idx=0; Idx<SlideSize; Idx++)                           // enter zeros into the pipe
+       { Pipe[Ptr++] = 0; if(Ptr>=WindowSize) Ptr=0; }
+     }
+     return ProcessWindow(); }
+
+   int ProcessWindow(void)
+   { int Idx;
+     for(Idx=0; Ptr<WindowSize; Idx++)                            // multiply by the Window and copy to FwdFFT buffer
+     { FwdFFT[Idx] = Window[Idx]*Pipe[Ptr++]; }
+     Ptr=0;
+     for(     ; Idx<WindowSize; Idx++)
+     { FwdFFT[Idx] = Window[Idx]*Pipe[Ptr++]; }
+     FwdFFT.Execute();                                             // execute forward FFT
+     Output = FwdFFT.Buffer;                                       // spectra in now in FwdFFT.Buffer
+     return SlideSize; }
+
+} ;
+
+// ===========================================================================================
+
+template <class Float=double>
+ class OutSlideFFT
+{ public:
+   DFT1d<Float>         BwdFFT;       // backward FFT
+   int                  WindowSize;   // Window size = FFT size
+   int                  SlideSize;    // slide step for sliding-window FFT
+   Float               *Window;       // Window shape (Hanning)
+   std::complex<Float> *Pipe;         // output circular buffer
+   int                  Ptr;          // wrap-around input buffer pointer
+   std::complex<Float> *Input;        // here the input spectra are to be placed
+   std::complex<Float> *Output;       // the output samples (beware of circular buffering)
+
+  public:
+   OutSlideFFT() { WindowSize=0; Window=0; Pipe=0; Input=0; Output=0; }
+  ~OutSlideFFT() { Free(); }
+   void Free(void)  { delete [] Window; delete [] Pipe; Window=0; Pipe=0; WindowSize=0; }
+
+   int Size(void) const { return BwdFFT.Size; }
+   int Preset(int Size)
+   { // if(Size==WindowSize) return Size;                   // to avoid reallocations
+     Free();                                             // deallocate everything
+     if(BwdFFT.PresetBackward(Size)<0) return -1;        // setup forward FFT
+     WindowSize=Size;
+     Input = BwdFFT.Buffer;                              // here the input spectra is to be place
+     Window = new (std::nothrow) Float               [WindowSize]; if(Window==0) return -1;
+     Pipe   = new (std::nothrow) std::complex<Float> [WindowSize]; if(Pipe==0) return -1;
+     SetSineWindow(); return Size; }                     // return FFT size (or negative when allocations failed)
+
+   void Clear(void) { for(int Idx=0; Idx<WindowSize; Idx++) { Pipe[Idx]=0; } Ptr=WindowSize-SlideSize; Output=Pipe+Ptr; }
+
+   void SetHannWindow(int Slide=0)
+   { double Scale=0.5/sqrt(WindowSize);                  // scale factor (forward+backward FFT scale data up by size)
+     for(int Idx=0; Idx<WindowSize; Idx++)
+     { Window[Idx]=Scale*(1.0-cos((2*M_PI*Idx)/WindowSize)); }
+     if(Slide==0) Slide=WindowSize/4;
+     SlideSize=Slide; Clear(); }
+
+   void SetSineWindow(int Slide=0)
+   { double Scale=0.5/sqrt(WindowSize);
+     for(int Idx=0; Idx<WindowSize; Idx++)
+     { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
+   if(Slide==0) Slide=WindowSize/2;
+   SlideSize=Slide; Clear(); }
+
+   void SetGaussWindow(double Sigma, int Slide)
+   { int WindowSize2 = WindowSize/2;
+     for(int Idx=0; Idx<WindowSize; Idx++)
+     { double D=Idx-WindowSize2;
+       Window[Idx]=exp(-(D*D)/(2*Sigma*Sigma)); }
+   SlideSize=Slide; Clear(); }
+
+   void PrintWindow(void)
+   { printf("OutSlideFFT::Window[%d] =", WindowSize);
+     for(int Idx=0; Idx<WindowSize; Idx++)
+       printf(" %+5.3f", Window[Idx]);
+     printf("\n"); }
+
+   int Process(void)                                     // spectra to be processed must be in Input
+   { int Idx;
+     BwdFFT.Execute();
+
+     for(Idx=0; Idx<SlideSize; Idx++)
+     { Pipe[Ptr++] = 0;
+       if(Ptr>=WindowSize) Ptr=0; }
+
+     Output = Pipe+Ptr;
+
+     for(Idx=0; Ptr<WindowSize; Idx++)
+     { Pipe[Ptr++] += Input[Idx]*Window[Idx]; }
+     Ptr=0;
+     for(     ; Idx<WindowSize; Idx++)
+     { Pipe[Ptr++] += Input[Idx]*Window[Idx]; }
+
+     return SlideSize; }
+
+   template <class SpectraType>
+    int Process(std::complex<SpectraType> *Spectra)
+   { for(int Idx=0; Idx<WindowSize; Idx++)
+     { Input[Idx] = Spectra[Idx]; }
+     return Process(); }
+
+   template <class SpectraType, class MaskType>
+    int Process(std::complex<SpectraType> *Spectra, MaskType *Mask)
+   { for(int Idx=0; Idx<WindowSize; Idx++)
+     { Input[Idx] = Spectra[Idx]*Mask[Idx]; }
+     return Process(); }
+
+   template <class OutType>
+    int GetOutput(std::complex<OutType> *Output, int Decimate=1) // Decimate must be a 1,2,4,8,16,...
+   { int Idx, OutPtr = Ptr;
+     for(Idx=0; Idx<SlideSize; Idx+=Decimate)
+     { (*Output++)=Pipe[OutPtr]; OutPtr+=Decimate; if(OutPtr>=WindowSize) OutPtr-=WindowSize; }
+     return SlideSize/Decimate; }
+
+} ; 
+
+// ===========================================================================================
+
+#ifdef USE_RPI_GPU_FFT     // the following code is Raspberry PI specific
+
+#include "mailbox.h"
+#include "gpu_fft.h"
+
+class RPI_GPU_FFT
+{ public:
+
+   struct GPU_FFT *FFT;
+   int MailBox;
+   int Size;
+   int Sign;
+   int Jobs;
+
+  public:
+   RPI_GPU_FFT()
+   { MailBox=mbox_open(); FFT=0; Size=0; Sign=0; Jobs=0; }
+
+  ~RPI_GPU_FFT()
+   { Free(); mbox_close(MailBox); }
+
+   void Free(void)
+   { if(FFT==0) return;
+     gpu_fft_release(FFT);
+     FFT=0; Size=0; Sign=0; Jobs=0; }
+
+   int Preset(int Size, int Sign, int Jobs=32)
+   { if( FFT && (Size==this->Size) && (Sign==this->Sign) && (Jobs==this->Jobs) ) return Size;
+     Free(); if(Size<256) return -1;
+     int LogN;
+     for(LogN=8; LogN<=22; LogN++)
+     { if(Size==(1<<LogN)) break; }
+     if(LogN>22) return -1;
+     int Err=gpu_fft_prepare(MailBox, LogN, Sign, Jobs, &FFT);
+     if(Err<0) { FFT=0; Size=0; return Err; } // -1 => firmware up todate ?, -2 => Size not supported ?, -3 => not enough GPU memory
+     this->Size=Size; this->Sign=Sign; this->Jobs=Jobs; return Size; }
+
+   int PresetForward (int Size, int Jobs=32) { return Preset(Size, GPU_FFT_FWD, Jobs); }
+   int PresetBackward(int Size, int Jobs=32) { return Preset(Size, GPU_FFT_REV, Jobs); }
+
+   std::complex<float> *Input (int Job=0) { return (std::complex<float> *)(FFT->in  + Job*FFT->step); }
+   void Execute(void) { gpu_fft_execute(FFT); }
+   std::complex<float> *Output(int Job=0) { return (std::complex<float> *)(FFT->out + Job*FFT->step); }
+
+  template <class Type>
+   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
+  { for(int Idx=0; Idx<WindowSize; Idx++)
+    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
+  }
+
+} ;
+
+#endif
+
+// ===========================================================================================
+
+#endif // of  __FFT_H__
diff --git a/src/gpu_fft.c b/src/gpu_fft.c
new file mode 100644
index 0000000..5bda67b
--- /dev/null
+++ b/src/gpu_fft.c
@@ -0,0 +1,135 @@
+/*
+BCM2835 "GPU_FFT" release 3.0
+Copyright (c) 2015, Andrew Holme.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <string.h>
+
+#include "gpu_fft.h"
+
+#define GPU_FFT_BUSY_WAIT_LIMIT (5<<12) // ~1ms
+
+typedef struct GPU_FFT_COMPLEX COMPLEX;
+
+int gpu_fft_prepare(
+    int mb,         // mailbox file_desc
+    int log2_N,     // log2(FFT_length) = 8...22
+    int direction,  // GPU_FFT_FWD: fft(); GPU_FFT_REV: ifft()
+    int jobs,       // number of transforms in batch
+    struct GPU_FFT **fft) {
+
+    unsigned info_bytes, twid_bytes, data_bytes, code_bytes, unif_bytes, mail_bytes;
+    unsigned size, *uptr, vc_tw, vc_data;
+    int i, q, shared, unique, passes, ret;
+
+    struct GPU_FFT_BASE *base;
+    struct GPU_FFT_PTR ptr;
+    struct GPU_FFT *info;
+
+    if (gpu_fft_twiddle_size(log2_N, &shared, &unique, &passes)) return -2;
+
+    info_bytes = 4096;
+    data_bytes = (1+((sizeof(COMPLEX)<<log2_N)|4095));
+    code_bytes = gpu_fft_shader_size(log2_N);
+    twid_bytes = sizeof(COMPLEX)*16*(shared+GPU_FFT_QPUS*unique);
+    unif_bytes = sizeof(int)*GPU_FFT_QPUS*(5+jobs*2);
+    mail_bytes = sizeof(int)*GPU_FFT_QPUS*2;
+
+    size  = info_bytes +        // header
+            data_bytes*jobs*2 + // ping-pong data, aligned
+            code_bytes +        // shader, aligned
+            twid_bytes +        // twiddles
+            unif_bytes +        // uniforms
+            mail_bytes;         // mailbox message
+
+    ret = gpu_fft_alloc(mb, size, &ptr);
+    if (ret) return ret;
+
+    // Header
+    info = (struct GPU_FFT *) ptr.arm.vptr;
+    base = (struct GPU_FFT_BASE *) info;
+    gpu_fft_ptr_inc(&ptr, info_bytes);
+
+    // For transpose
+    info->x = 1<<log2_N;
+    info->y = jobs;
+
+    // Ping-pong buffers leave results in or out of place
+    info->in = info->out = ptr.arm.cptr;
+    info->step = data_bytes / sizeof(COMPLEX);
+    if (passes&1) info->out += info->step * jobs; // odd => out of place
+    vc_data = gpu_fft_ptr_inc(&ptr, data_bytes*jobs*2);
+
+    // Shader code
+    memcpy(ptr.arm.vptr, gpu_fft_shader_code(log2_N), code_bytes);
+    base->vc_code = gpu_fft_ptr_inc(&ptr, code_bytes);
+
+    // Twiddles
+    gpu_fft_twiddle_data(log2_N, direction, ptr.arm.fptr);
+    vc_tw = gpu_fft_ptr_inc(&ptr, twid_bytes);
+
+    uptr = ptr.arm.uptr;
+
+    // Uniforms
+    for (q=0; q<GPU_FFT_QPUS; q++) {
+        *uptr++ = vc_tw;
+        *uptr++ = vc_tw + sizeof(COMPLEX)*16*(shared + q*unique);
+        *uptr++ = q;
+        for (i=0; i<jobs; i++) {
+            *uptr++ = vc_data + data_bytes*i;
+            *uptr++ = vc_data + data_bytes*i + data_bytes*jobs;
+        }
+        *uptr++ = 0;
+        *uptr++ = (q==0); // For mailbox: IRQ enable, master only
+
+        base->vc_unifs[q] = gpu_fft_ptr_inc(&ptr, sizeof(int)*(5+jobs*2));
+    }
+
+    if ((jobs<<log2_N) <= GPU_FFT_BUSY_WAIT_LIMIT) {
+        // Direct register poking with busy wait
+        base->vc_msg = 0;
+    }
+    else {
+        // Mailbox message
+        for (q=0; q<GPU_FFT_QPUS; q++) {
+            *uptr++ = base->vc_unifs[q];
+            *uptr++ = base->vc_code;
+        }
+
+        base->vc_msg = ptr.vc;
+    }
+
+    *fft = info;
+    return 0;
+}
+
+unsigned gpu_fft_execute(struct GPU_FFT *info) {
+    return gpu_fft_base_exec(&info->base, GPU_FFT_QPUS);
+}
+
+void gpu_fft_release(struct GPU_FFT *info) {
+    gpu_fft_base_release(&info->base);
+}
diff --git a/src/gpu_fft.h b/src/gpu_fft.h
new file mode 100644
index 0000000..8b1cb08
--- /dev/null
+++ b/src/gpu_fft.h
@@ -0,0 +1,101 @@
+/*
+BCM2835 "GPU_FFT" release 3.0
+Copyright (c) 2015, Andrew Holme.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef __GPU_FFT__
+#define __GPU_FFT__
+
+#define GPU_FFT_QPUS 8
+
+#define GPU_FFT_PI 3.14159265358979323846
+
+#define GPU_FFT_FWD 0 // forward FFT
+#define GPU_FFT_REV 1 // inverse FFT
+
+struct GPU_FFT_COMPLEX {
+    float re, im;
+};
+
+struct GPU_FFT_PTR {
+    unsigned vc;
+    union { struct GPU_FFT_COMPLEX *cptr;
+            void                   *vptr;
+            char                   *bptr;
+            float                  *fptr;
+            unsigned               *uptr; } arm;
+};
+
+struct GPU_FFT_BASE {
+    int mb;
+    unsigned handle, size, vc_msg, vc_code, vc_unifs[GPU_FFT_QPUS], peri_size;
+    volatile unsigned *peri;
+};
+
+struct GPU_FFT {
+    struct GPU_FFT_BASE base;
+    struct GPU_FFT_COMPLEX *in, *out;
+    int x, y, step;
+};
+
+int gpu_fft_prepare(
+    int mb,         // mailbox file_desc
+    int log2_N,     // log2(FFT_length) = 8...22
+    int direction,  // GPU_FFT_FWD: fft(); GPU_FFT_REV: ifft()
+    int jobs,       // number of transforms in batch
+    struct GPU_FFT **fft);
+
+unsigned gpu_fft_execute(
+    struct GPU_FFT *info);
+
+void gpu_fft_release(
+    struct GPU_FFT *info);
+
+// private
+int           gpu_fft_twiddle_size(int, int *, int *, int *);
+void          gpu_fft_twiddle_data(int, int, float *);
+unsigned int  gpu_fft_shader_size(int);
+unsigned int *gpu_fft_shader_code(int);
+
+// gpu_fft_base:
+
+unsigned gpu_fft_base_exec (
+    struct GPU_FFT_BASE *base,
+    int num_qpus);
+
+int gpu_fft_alloc (
+    int mb,
+    unsigned size,
+    struct GPU_FFT_PTR *ptr);
+
+void gpu_fft_base_release(
+    struct GPU_FFT_BASE *base);
+
+unsigned gpu_fft_ptr_inc (
+    struct GPU_FFT_PTR *ptr,
+    int bytes);
+
+#endif // __GPU_FFT__
diff --git a/src/gpu_fft_shaders.c b/src/gpu_fft_shaders.c
new file mode 100644
index 0000000..f8e3bfe
--- /dev/null
+++ b/src/gpu_fft_shaders.c
@@ -0,0 +1,102 @@
+/*
+BCM2835 "GPU_FFT" release 3.0
+Copyright (c) 2015, Andrew Holme.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+static unsigned int shader_256[] = {
+    #include "hex/shader_256.hex"
+};
+static unsigned int shader_512[] = {
+    #include "hex/shader_512.hex"
+};
+static unsigned int shader_1k[] = {
+    #include "hex/shader_1k.hex"
+};
+static unsigned int shader_2k[] = {
+    #include "hex/shader_2k.hex"
+};
+static unsigned int shader_4k[] = {
+    #include "hex/shader_4k.hex"
+};
+static unsigned int shader_8k[] = {
+    #include "hex/shader_8k.hex"
+};
+static unsigned int shader_16k[] = {
+    #include "hex/shader_16k.hex"
+};
+static unsigned int shader_32k[] = {
+    #include "hex/shader_32k.hex"
+};
+static unsigned int shader_64k[] = {
+    #include "hex/shader_64k.hex"
+};
+static unsigned int shader_128k[] = {
+    #include "hex/shader_128k.hex"
+};
+static unsigned int shader_256k[] = {
+    #include "hex/shader_256k.hex"
+};
+static unsigned int shader_512k[] = {
+    #include "hex/shader_512k.hex"
+};
+static unsigned int shader_1024k[] = {
+    #include "hex/shader_1024k.hex"
+};
+static unsigned int shader_2048k[] = {
+    #include "hex/shader_2048k.hex"
+};
+static unsigned int shader_4096k[] = {
+    #include "hex/shader_4096k.hex"
+};
+
+static struct {
+    unsigned int size, *code;
+}
+shaders[] = {
+    {sizeof(shader_256), shader_256},
+    {sizeof(shader_512), shader_512},
+    {sizeof(shader_1k), shader_1k},
+    {sizeof(shader_2k), shader_2k},
+    {sizeof(shader_4k), shader_4k},
+    {sizeof(shader_8k), shader_8k},
+    {sizeof(shader_16k), shader_16k},
+    {sizeof(shader_32k), shader_32k},
+    {sizeof(shader_64k), shader_64k},
+    {sizeof(shader_128k), shader_128k},
+    {sizeof(shader_256k), shader_256k},
+    {sizeof(shader_512k), shader_512k},
+    {sizeof(shader_1024k), shader_1024k},
+    {sizeof(shader_2048k), shader_2048k},
+    {sizeof(shader_4096k), shader_4096k}
+};
+
+unsigned int  gpu_fft_shader_size(int log2_N) {
+    return shaders[log2_N-8].size;
+}
+
+unsigned int *gpu_fft_shader_code(int log2_N) {
+    return shaders[log2_N-8].code;
+}
diff --git a/src/gpu_fft_twiddles.c b/src/gpu_fft_twiddles.c
new file mode 100644
index 0000000..5323650
--- /dev/null
+++ b/src/gpu_fft_twiddles.c
@@ -0,0 +1,315 @@
+/*
+BCM2835 "GPU_FFT" release 3.0
+Copyright (c) 2015, Andrew Holme.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <math.h>
+
+#include "gpu_fft.h"
+
+#define ALPHA(dx) (2*pow(sin((dx)/2),2))
+#define  BETA(dx) (sin(dx))
+
+static double k[16] = {0,8,4,4,2,2,2,2,1,1,1,1,1,1,1,1};
+static double m[16] = {0,0,0,1,0,1,2,3,0,1,2,3,4,5,6,7};
+
+/****************************************************************************/
+
+static float *twiddles_base_16(double two_pi, float *out, double theta) {
+    int i;
+    for (i=0; i<16; i++) {
+        *out++ = cos(two_pi/16*k[i]*m[i] + theta*k[i]);
+        *out++ = sin(two_pi/16*k[i]*m[i] + theta*k[i]);
+    }
+    return out;
+}
+
+static float *twiddles_base_32(double two_pi, float *out, double theta) {
+    int i;
+    for (i=0; i<16; i++) {
+        *out++ = cos(two_pi/32*i + theta);
+        *out++ = sin(two_pi/32*i + theta);
+    }
+    return twiddles_base_16(two_pi, out, 2*theta);
+}
+
+static float *twiddles_base_64(double two_pi, float *out) {
+    int i;
+    for (i=0; i<32; i++) {
+        *out++ = cos(two_pi/64*i);
+        *out++ = sin(two_pi/64*i);
+    }
+    return twiddles_base_32(two_pi, out, 0);
+}
+
+/****************************************************************************/
+
+static float *twiddles_step_16(double two_pi, float *out, double theta) {
+    int i;
+    for (i=0; i<16; i++) {
+        *out++ = ALPHA(theta*k[i]);
+        *out++ =  BETA(theta*k[i]);
+    }
+    return out;
+}
+
+static float *twiddles_step_32(double two_pi, float *out, double theta) {
+    int i;
+    for (i=0; i<16; i++) {
+        *out++ = ALPHA(theta);
+        *out++ =  BETA(theta);
+    }
+    return twiddles_step_16(two_pi, out, 2*theta);
+}
+
+static float *twiddles_step_64(double two_pi, float *out, double theta) {
+    int i;
+    for (i=0; i<32; i++) {
+        *out++ = ALPHA(theta);
+        *out++ =  BETA(theta);
+    }
+    return twiddles_step_32(two_pi, out, 2*theta);
+}
+
+/****************************************************************************/
+
+static void twiddles_256(double two_pi, float *out) {
+    double N=256;
+    int q;
+
+    out = twiddles_base_16(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_16(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_512(double two_pi, float *out) {
+    double N=512;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_16(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_1k(double two_pi, float *out) {
+    double N=1024;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_2k(double two_pi, float *out) {
+    double N=2048;
+    int q;
+
+    out = twiddles_base_64(two_pi, out);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_4k(double two_pi, float *out) {
+    double N=4096;
+    int q;
+
+    out = twiddles_base_16(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 16);
+    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_16(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_8k(double two_pi, float *out) {
+    double N=8192;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 16);
+    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_16(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_16k(double two_pi, float *out) {
+    double N=16384;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 16);
+    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_16(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_32k(double two_pi, float *out) {
+    double N=32768;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_64k(double two_pi, float *out) {
+    double N=65536;
+    int q;
+
+    out = twiddles_base_64(two_pi, out);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_128k(double two_pi, float *out) {
+    double N=128*1024;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 16*16);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 16);
+    out = twiddles_step_16(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_16(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_256k(double two_pi, float *out) {
+    double N=256*1024;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 32*16);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_512k(double two_pi, float *out) {
+    double N=512*1024;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_16(two_pi, out, two_pi/N * 32*32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_1024k(double two_pi, float *out) {
+    double N=1024*1024;
+    int q;
+
+    out = twiddles_base_32(two_pi, out, 0);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32*32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_2048k(double two_pi, float *out) {
+    double N=2048*1024;
+    int q;
+
+    out = twiddles_base_64(two_pi, out);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32*32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+static void twiddles_4096k(double two_pi, float *out) {
+    double N=4096*1024;
+    int q;
+
+    out = twiddles_base_64(two_pi, out);
+    out = twiddles_step_64(two_pi, out, two_pi/N * 32*32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * 32);
+    out = twiddles_step_32(two_pi, out, two_pi/N * GPU_FFT_QPUS);
+
+    for (q=0; q<GPU_FFT_QPUS; q++)
+        out = twiddles_base_32(two_pi, out, two_pi/N*q);
+}
+
+/****************************************************************************/
+
+static struct {
+    int passes, shared, unique;
+    void (*twiddles)(double, float *);
+}
+shaders[] = {
+    {2, 2, 1, twiddles_256},
+    {2, 3, 1, twiddles_512},
+    {2, 4, 2, twiddles_1k},
+    {2, 6, 2, twiddles_2k},
+    {3, 3, 1, twiddles_4k},
+    {3, 4, 1, twiddles_8k},
+    {3, 5, 1, twiddles_16k},
+    {3, 6, 2, twiddles_32k},
+    {3, 8, 2, twiddles_64k},
+    {4, 5, 1, twiddles_128k},
+    {4, 6, 2, twiddles_256k},
+    {4, 7, 2, twiddles_512k},
+    {4, 8, 2, twiddles_1024k},
+    {4,10, 2, twiddles_2048k},
+    {4,12, 2, twiddles_4096k}
+};
+
+int gpu_fft_twiddle_size(int log2_N, int *shared, int *unique, int *passes) {
+    if (log2_N<8 || log2_N>22) return -1;
+    *shared = shaders[log2_N-8].shared;
+    *unique = shaders[log2_N-8].unique;
+    *passes = shaders[log2_N-8].passes;
+    return 0;
+}
+
+void gpu_fft_twiddle_data(int log2_N, int direction, float *out) {
+    shaders[log2_N-8].twiddles((direction==GPU_FFT_FWD?-2:2)*GPU_FFT_PI, out);
+}
diff --git a/src/gsm_scan.cc b/src/gsm_scan.cc
new file mode 100644
index 0000000..70712fc
--- /dev/null
+++ b/src/gsm_scan.cc
@@ -0,0 +1,296 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+
+#include <math.h>
+
+#include <vector>
+#include <algorithm>
+
+#include "rtlsdr.h"
+#include "buffer.h"
+#include "fft.h"
+#include "image.h"
+
+#define FloatType float
+
+// ==================================================================================================================
+
+const int GSM_ChannelWidth = 200000; // [Hz]
+const int GSM_DataRate     = 270833; // [bps]
+
+// ==================================================================================================================
+
+   template <class Float>
+    void AverPeakBkg(Float &Aver, Float &Peak, Float &PeakPos, Float &Bkg, Float *Data, int Size)
+   { Aver=0; Peak=0; PeakPos=0; int PeakIdx=0;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Float Dat=Data[Idx];
+       if(Dat>Peak) { Peak=Dat; PeakIdx=Idx; }
+       Aver+=Dat; }
+     if(PeakIdx==0)             { Peak+=Data[     1];                    PeakPos=PeakIdx+Data[     1]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
+     else if(PeakPos==(Size-1)) { Peak+=Data[Size-2];                    PeakPos=PeakIdx-Data[Size-2]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
+     else                       { Peak+=Data[PeakIdx+1]+Data[PeakIdx-1]; PeakPos=PeakIdx+(Data[PeakIdx+1]-Data[PeakIdx-1])/Peak; Bkg=(Aver-Peak)/(Size-3); }
+     Aver/=Size; }
+
+   template <class Float>
+    void AverRMS(Float &Aver, Float &RMS, Float *Data, int Size) // classical average and RMS of a data series
+   { Aver=0; RMS=0;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Aver+=Data[Idx]; }
+     Aver/=Size;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Float Diff=Data[Idx]-Aver; RMS+=Diff*Diff; }
+     RMS=sqrt(RMS/Size); }
+
+   template <class Float>
+    int ProcessChan(std::vector<Float> &PPM_Values, Float &AverPower,
+                    int LowBin, int UppBin, Float CenterBin, Float BinWidth, Float CenterFreq,
+                    SampleBuffer<Float> &Power)
+   { int Slides = Power.Samples();
+     int Bins = Power.Len;
+     SampleBuffer<Float> Aver, Peak, PeakPos, Bkg;
+     Aver.Allocate(1, Slides); Peak.Allocate(1, Slides); PeakPos.Allocate(1, Slides); Bkg.Allocate(1, Slides);
+     Float *Data = Power.Data;
+     for(int Idx=0; Idx<Slides; Idx++, Data+=Bins)
+     { AverPeakBkg(Aver[Idx], Peak[Idx], PeakPos[Idx], Bkg[Idx], Data+LowBin, UppBin-LowBin+1);
+       PeakPos[Idx]+=LowBin-CenterBin; }
+     Aver.Full=Slides; Peak.Full=Slides; PeakPos.Full=Slides; Bkg.Full=Slides;
+     Float PowerRMS; AverRMS(AverPower, PowerRMS, Aver.Data, Slides);
+     // printf("AverPower=%3.1f, PowerRMS=%3.1f\n", AverPower, PowerRMS);
+     if(PowerRMS>(0.5*AverPower)) return 0;                                   // skip pulsing channels
+
+     Float AverPeak, PeakRMS; AverRMS(AverPeak, PeakRMS, Peak.Data, Slides);
+     Float AverBkg, BkgRMS; AverRMS(AverBkg, BkgRMS, Bkg.Data, Slides);
+     // printf("AverPeak=%3.1f, PeakRMS=%3.1f, AverBkg=%5.3f, BkgRMS=%5.3f\n", AverPeak, PeakRMS, AverBkg, BkgRMS);
+
+     int Marks=0;
+     Float PeakThres = 4*PeakRMS;
+     Float BkgThres  = 4*BkgRMS;
+     for(int Idx=1; Idx<(Slides-1); Idx++)
+     { Float PeakL=Peak.Data[Idx-1]-AverPeak;
+       Float PeakM=Peak.Data[Idx  ]-AverPeak;
+       Float PeakR=Peak.Data[Idx+1]-AverPeak;
+       Float PeakSum = PeakL+PeakM+PeakR;
+       if(PeakSum<=PeakThres) continue;
+       if(PeakM<PeakL)  continue;
+       if(PeakM<=PeakR) continue;
+       if(PeakM<=((PeakL+PeakR)/2)) continue;
+       Float BkgSum = Bkg.Data[Idx-1]+Bkg.Data[Idx]+Bkg.Data[Idx+1];
+       if((3*AverBkg-BkgSum)<BkgThres) continue;
+       if(Peak.Data[Idx]<(32*Bkg.Data[Idx])) continue;
+       Float PPM = -1e6*(PeakPos.Data[Idx]*BinWidth-(Float)GSM_DataRate/4)/CenterFreq;
+       // printf("Mark: PeakSum[%5d]=%8.1f/%6.1f Bkg=%8.3f/%6.3f Peak/Bkg=%8.1f PeakPos=%+7.3f %+7.3fppm\n",
+       //         Idx, PeakSum, PeakThres, 3*AverBkg-BkgSum, BkgThres, Peak.Data[Idx]/Bkg.Data[Idx], PeakPos.Data[Idx], PPM);
+       PPM_Values.push_back(PPM);
+       Marks++; }
+
+     return Marks; }
+/*
+   template <class Float>
+    int EstimatePPM(double &EstPPM, SampleBuffer<Float> &Power)
+   { int Slides = Power.Samples();
+     int Bins = Power.Len;
+     double Sum[Bins];
+     for(int Bin=0; Bin<Bins; Bin++)
+     { Sum[Bin]=0; }
+     Float *Data = Power.Data;
+     for(int Slide=0; Slide<Slides; Slide++)
+     { for(int Bin=0; Bin<Bins; Bin++)
+       { Sum[Bin]+=Data[Bin]; }
+       Data+=Bins; }
+     double I=0, Q=0;
+     for(int Bin=0; Bin<Bins; Bin++)
+     { double Phase=(10.0*Bin)/Bins; Phase-=floor(Phase); Phase*=2*M_PI;
+       double LogPwr = Sum[Bin];
+       I += LogPwr*cos(Phase);
+       Q += LogPwr*sin(Phase); }
+     printf("EstimatePPM(%7.3fMHz, %dx%d) I/Q=%+8.1f/%+8.1f\n", 1e-6*Power.Freq, Slides, Bins, I, Q);
+     return 0; }
+*/
+// ==================================================================================================================
+
+  const char *OptionHelp = "\
+  --device <device index>         [int] RTLSDR device index\n\
+  --serial <serial number>        [string] RTLSDR device serial number\n\
+  --ppm <crystal correction>      [ppm] receiver crystal correction\n\
+  --gain <receiver gain>          [dB] receiver gain [default is auto-gain]\n\
+  --offset-tuning                      enable offset tuning - for E4000 tuner\n\
+  --gsm-850                            scan the GSM-850 band for USA and Canada (default is E-GSM for Europe)\n\
+" ;
+
+int main(int argc, char **argv)
+{ 
+  RTLSDR SDR;     // DVB-T device with the RTL2832U control chip
+
+  int RxDevice       =         0;    // [Index] device index for RTLSDR device
+  int RxCrystalCorr  =         0;    // [PPM] crystal frequency correction for the DVB-T receiver
+  int RxGain         =       200;    // [0.1dB] receiver gain - low default gain for the GSM band as signals are strong
+  int RxOffsetTuning =         0;    // [bool]
+  int SampleRate     =   2000000;    // [Hz] => single scan takes 10 GSM channels (0.2MHz/channel)
+  int LowerFreq      = 920000000;    // [Hz] => scan whole E-GSM band
+  int UpperFreq      = 960000000;    // [Hz]
+  // int LowerFreq      = 868000000;    // [Hz] => scan whole GSM-850 band
+  // int UpperFreq      = 900000000;    // [Hz]
+  int GuardBand      =    100000;    // [Hz] first channel starts at 921.0 + 0.1 = 921.1 MHz
+  int FFTsize        =      1024;    // [FFT bins] => FFT resolution = 3200000/1024 = ~6.4kHz/bin
+  int SamplesPerScan =    500000;    // 0.250sec of RF data per scan
+
+  int arg=1;
+  for( ; arg<argc; )
+  {
+    if(memcmp(argv[arg],"--",2)==0)
+    { char *OptName=argv[arg]+2;
+      if(strcmp(OptName,"help")==0)
+      { printf("Usage: %s [options]\n%s", argv[0], OptionHelp); exit(0); }
+      else if(strcmp(OptName,"device")==0)
+      { if(sscanf(argv[++arg], "%d", &RxDevice)!=1)
+        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
+        arg++; }
+      else if(strcmp(OptName,"serial")==0)
+      { int Index=SDR.getDeviceIndexBySerial(argv[++arg]);
+        if(Index<0)
+        { printf("Device with serial %s not found (%d)\n", argv[arg], Index); exit(0); }
+        RxDevice=Index;
+        arg++; }
+      else if(strcmp(OptName,"ppm")==0)
+      { if(sscanf(argv[++arg], "%d", &RxCrystalCorr)!=1)
+        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
+        arg++; }
+      else if(strcmp(OptName,"gain")==0)
+      { float Gain;
+        if(sscanf(argv[++arg], "%f", &Gain)!=1)
+        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
+        RxGain = (int)floor(10*Gain+0.5);
+        arg++; }
+      else if(strcmp(OptName,"offset-tuning")==0)
+      { RxOffsetTuning=1;
+        arg++; }
+      else if(strcmp(OptName,"gsm-850")==0)
+      { LowerFreq = 868000000; UpperFreq = 900000000;
+        arg++; }
+      else if( (strcmp(OptName,"sample-rate")==0) || (strcmp(OptName,"bandwidth")==0) )
+      { if(sscanf(argv[++arg], "%d", &SampleRate)!=1)
+        { printf("Not a valid number: %s for option %s\n", argv[arg], OptName); exit(0); }
+        arg++; }
+    }
+    else if(argv[arg][0]=='-')
+    { printf("Unknown option: %s\n", argv[arg]); exit(0);
+    }
+    else
+    { printf("File names not allowed, only options\n"); exit(0);
+      arg++; }
+  }
+
+  int CenterFreq     = (LowerFreq+UpperFreq)/2;                      // [Hz] center frequency of the scan
+  int FreqStep       = SampleRate;                                   // [Hz] scanning step
+  int FFTsize2       = FFTsize/2;
+  int Scans          = (UpperFreq-LowerFreq-2*GuardBand+FreqStep-1)/FreqStep;    // number of scan to cover the desired band
+      UpperFreq      =  LowerFreq+Scans*FreqStep+2*GuardBand;                    // [Hz]
+      CenterFreq     = (LowerFreq+UpperFreq)/2;                                  // [Hz]
+
+#ifdef USE_RPI_GPU_FFT
+  RPI_GPU_FFT       FFT;
+#else
+  DFT1d<FloatType>  FFT;
+#endif
+  FloatType         Window[FFTsize];
+  FFT.PresetForward(FFTsize); FFT.SetSineWindow(Window, FFTsize, (FloatType)(1.0/sqrt(FFTsize)) );
+
+  printf("Frequency = %5.3fMHz..%5.3fMHz %5.3fMHz step, %d scans\n",
+                       1e-6*LowerFreq, 1e-6*UpperFreq, 1e-6*FreqStep, Scans);
+  printf("Sampling rate    = %10dHz = %8.3fMHz\n", SampleRate, 1e-6*SampleRate);
+  printf("%5.3fsec per scan\n", (double)SamplesPerScan/SampleRate);
+  printf("FFT: %d bins, %3.1fHz/bin, %5.3fms/slide\n",
+          FFTsize, (double)SampleRate/FFTsize, 0.5e3*FFTsize/SampleRate);
+
+  if(SDR.Open(RxDevice, CenterFreq, SampleRate)<0)        // open the RTLSDR device
+  { printf("Can't open RTLSDR device #%d\n", RxDevice);  return 0; }
+  printf("Open(%d, %d, %d) OK\n", RxDevice, CenterFreq, SampleRate);
+
+  SDR.setFreqCorrection(RxCrystalCorr);          // [PPM] correct the crystal frequencies
+  printf("Tuner crystal correction set to %d ppm\n", RxCrystalCorr);
+  if(RxGain>=0)
+  { SDR.setTunerGainManual(); SDR.setTunerGain(RxGain); printf("Tuner gain set to %3.1f dB (device reports %3.1f dB)\n", 0.1*RxGain, 0.1*SDR.getTunerGain() ); }
+  else
+  { SDR.setTunerGainAuto(); printf("Tuner gain set to automatic\n"); }  // automatic gain control
+
+  SDR.setOffsetTuning(RxOffsetTuning); if(RxOffsetTuning) printf("Offset tuning activated\n");
+
+  printf("\n");
+
+  SampleBuffer<uint8_t>                   Input;
+  SampleBuffer< std::complex<FloatType> > Spectra;
+  SampleBuffer<FloatType>                 Power;
+  std::vector<FloatType> PPM_Values;
+
+  FloatType BinWidth     = SampleRate/FFTsize;
+
+  int Freq=LowerFreq+GuardBand+FreqStep/2;
+  for(int Scan=0; Scan<Scans; Scan++, Freq+=FreqStep)
+  { SDR.setCenterFreq(Freq);
+    SDR.ResetBuffer();
+    int Samples=SDR.Read(Input, SamplesPerScan);                                    // acquire RF I/Q data
+    // printf("SDR.Read(, %5.3fMHz) => %d samples\n", 1e-6*Freq, Samples);
+    if(Samples<=0) { printf("SDR.Read(%5.1fMHz) failed\n", 1e-6*Freq); continue; }
+    SlidingFFT(Spectra, Input, FFT, Window);                                        // process with sliding FFT
+    SpectraPower(Power, Spectra);                                                   // we only want the amplitudes (power)
+#ifdef WRITE_SPECTROGRAM
+    char FileName[64]; sprintf(FileName, "gsm_scan_%7.3fMHz-%7.3fMHz.jpg", 1e-6*(Power.Freq-FreqStep/2), 1e-6*(Power.Freq+FreqStep/2));
+    MonoImage<FloatType> Spectrogram; Spectrogram.setExternal(Power.Data, FFTsize, Power.Samples() );
+    Spectrogram.WriteJPG_8bpp(FileName, 80, 0.33, 32.0, 32.0);                      // write spectrogram file
+#endif
+    // double EstPPM=0;
+    // EstimatePPM(EstPPM, Power);
+
+    FloatType FirstBinFreq = Freq-BinWidth*FFTsize2;          // [Hz] center frequency of the first FFT bin
+    FloatType LastBinFreq  = Freq+BinWidth*FFTsize2;          // [Hz] center frequency of the one-after-the-last FFT bin
+    int Chan = (int)ceil(FirstBinFreq/GSM_ChannelWidth);      // integer channel number corr. to the first FFT bin (GSM channels are on multiples of 200kHz)
+    for( ; ; Chan++)                                          // loop over (possible) channels in this scan
+    { FloatType CenterFreq=Chan*GSM_ChannelWidth; if(CenterFreq>=LastBinFreq) break; // center frequency of the channel
+      FloatType LowFreq = CenterFreq-0.45*GSM_ChannelWidth;    // [Hz] lower frequency to measure the channel
+      FloatType UppFreq = CenterFreq+0.45*GSM_ChannelWidth;    // [Hz] upper frequency to measure the channel
+      int LowBin=(int)floor((LowFreq-FirstBinFreq)/BinWidth+0.5); // FFT bins corresponding to the channel frequency range
+      int UppBin=(int)floor((UppFreq-FirstBinFreq)/BinWidth+0.5);
+      if( (LowBin<0) || (LowBin>=FFTsize) ) continue;          // skip this channel if range to measure
+      if( (UppBin<0) || (UppBin>=FFTsize) ) continue;          // not contained completely in this scan
+      FloatType AverPower; int Marks;
+      Marks=ProcessChan(PPM_Values, AverPower,                 // measure the channel, add measured points to PPM_Values
+                        LowBin, UppBin, (CenterFreq-FirstBinFreq)/BinWidth, BinWidth, CenterFreq,
+                        Power);
+      if(Marks==1) PPM_Values.pop_back();
+      if(Marks>1)
+      {  printf("%7.3fMHz: %+6.1fdB:",
+                1e-6*CenterFreq, 10*log10(AverPower/0.33));
+         for(size_t Mark=PPM_Values.size()-Marks; Mark<PPM_Values.size(); Mark++)
+           printf(" %+6.2f", PPM_Values[Mark]);
+         printf(" [ppm]\n");
+        // printf("%7.3fMHz %2d:[%4d-%4d] %+6.1fdB %d marks\n",
+        //         1e-6*CenterFreq, Scan, LowBin, UppBin, 10*log10(AverPower), Marks);
+      }
+    }
+  }
+
+  SDR.Close();
+
+  std::sort(PPM_Values.begin(), PPM_Values.end());
+  if(PPM_Values.size()>=16)
+  { FloatType Aver, RMS; int Margin=PPM_Values.size()/8;
+    AverRMS(Aver, RMS, PPM_Values.data()+Margin, PPM_Values.size()-2*Margin);
+    if(RMS>0.3)
+    { Margin=PPM_Values.size()/4; AverRMS(Aver, RMS, PPM_Values.data()+Margin, PPM_Values.size()-2*Margin); }
+    printf("Receiver Xtal correction = %d%+6.3f = %+7.3f (%5.3f) ppm [%d]\n", RxCrystalCorr, Aver, RxCrystalCorr+Aver, RMS, (int)PPM_Values.size()-2*Margin);
+    if(RMS>0.3)
+      printf("Warning: measurements appear inconsistent:\nplease retry with better initial estimate or with lower gain to reduce distortions\n");
+    printf("Note: when the receiver warms up the Xtal may drift 5-10ppm\n");
+  } else
+  { printf("Not enough data was collected: please retry with higher gain to catch more GSM signals\n"); }
+
+  return 0; }
+
+// ==================================================================================================================
diff --git a/src/hex/shader_1024k.hex b/src/hex/shader_1024k.hex
new file mode 100644
index 0000000..bad96b5
--- /dev/null
+++ b/src/hex/shader_1024k.hex
@@ -0,0 +1,948 @@
+0x00000014, 0xe0021227, // mov rb_STAGES,  STAGES
+0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
+0x00000040, 0xe0021727, // mov rb_0x40,    0x40
+0x00000080, 0xe0021767, // mov rb_0x80,    0x80
+0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
+0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
+0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
+0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
+0x00ff00ff, 0xe0021027, // mov rx_0x00FF00FF, 0x00FF00FF
+0x0000ffff, 0xe00216a7, // mov rx_0x0000FFFF, 0x0000FFFF
+0x80904000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
+0x80905000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246e0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000002e8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x15727d80, 0x10020827, // mov r0, ra_vdw_32
+0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00040000, 0xe00208e7, // mov r3, PASS32_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x000005d8, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149c01c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149c01c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9db1c0, 0x10020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119db3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c91c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffd78, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149c01c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149c01c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9db1c0, 0x10020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119db3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c91c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc30, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb50, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00001258, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149c01c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149c01c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9db1c0, 0x10020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119db3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c91c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff998, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff970, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff9d0, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00007fff, 0xe0020827, // mov r0, 0x7FFF
+0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
+0xfffff9a0, 0xf01809e7, // brr.allnz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff710, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff4a0, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff480, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff460, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff440, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff1b0, 0xf00809e7, // brr.allz -, r:pass_3
+0x00000060, 0xe0020827, // mov r0, 3*4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000007, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000006, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xffffef40, 0xf0f80227, // brr ra_link_1, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xffffecb0, 0xf00809e7, // brr.allz -, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xffffed78, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_128k.hex b/src/hex/shader_128k.hex
new file mode 100644
index 0000000..6b82f92
--- /dev/null
+++ b/src/hex/shader_128k.hex
@@ -0,0 +1,735 @@
+0x00000011, 0xe0021227, // mov rb_STAGES,  STAGES
+0x00000010, 0xe00216a7, // mov rb_0x10,    0x10
+0x00000040, 0xe00216e7, // mov rb_0x40,    0x40
+0x00000080, 0xe0021727, // mov rb_0x80,    0x80
+0x000000f0, 0xe0021767, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217a7, // mov rb_0x100,   0x100
+0x00000fff, 0xe00217e7, // mov rb_0xFFF,   0xFFF
+0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
+0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
+0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
+0x00ff00ff, 0xe0021627, // mov rx_0x00FF00FF, 0x00FF00FF
+0x0000ffff, 0xe0021667, // mov rx_0x0000FFFF, 0x0000FFFF
+0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
+0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
+0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000b0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
+0xc000ffc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
+0x8c05bdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000000c8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc0007fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05bdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000560, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d81c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d81c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9da1c0, 0x10020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119da3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9cc1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffd78, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d81c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d81c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9da1c0, 0x10020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119da3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9cc1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc30, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x00000000, 0xf0f489e7, // bra -, ra_save_16
+0x009e7000, 0x100009e7, // nop
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000d00, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d81c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d81c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9da1c0, 0x10020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119da3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9cc1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa08, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff9e0, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffaf0, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x141dfdc0, 0x100229e7, // and.setf -, ra_points, rb_0xFFF
+0xfffffac8, 0xf01809e7, // brr.allnz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff938, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff778, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0xfffff758, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff5c8, 0xf00809e7, // brr.allz -, r:pass_3
+0x00000020, 0xe0020827, // mov r0, 4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff408, 0xf0f80227, // brr ra_link_1, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff278, 0xf00809e7, // brr.allz -, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff2d0, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_16k.hex b/src/hex/shader_16k.hex
new file mode 100644
index 0000000..160d783
--- /dev/null
+++ b/src/hex/shader_16k.hex
@@ -0,0 +1,688 @@
+0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
+0x00000040, 0xe0021727, // mov rb_0x40,    0x40
+0x00000080, 0xe0021767, // mov rb_0x80,    0x80
+0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
+0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
+0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
+0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
+0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
+0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000b0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
+0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
+0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000000c8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc0000fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x000005f0, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c11c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c11c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc80, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb10, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x00000000, 0xf0f489e7, // bra -, ra_save_16
+0x009e7000, 0x100009e7, // nop
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000b10, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c11c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff9a0, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1cedc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff978, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff988, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff968, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cedc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff6d8, 0xf00809e7, // brr.allz -, r:pass_2
+0x00000020, 0xe0020827, // mov r0, 4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff5f8, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cedc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff468, 0xf00809e7, // brr.allz -, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff4c0, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_1k.hex b/src/hex/shader_1k.hex
new file mode 100644
index 0000000..7de3279
--- /dev/null
+++ b/src/hex/shader_1k.hex
@@ -0,0 +1,523 @@
+0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
+0x00000040, 0xe0021727, // mov rb_0x40,    0x40
+0x000000f0, 0xe0021767, // mov rb_0xF0,    0xF0
+0x00005555, 0xe00207a7, // mov rx_0x5555,  0x5555
+0x00003333, 0xe00217a7, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00217e7, // mov rx_0x00FF,  0x00FF
+0x90104000, 0xe0020767, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202a7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212a7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x100246e0, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x10024720, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000c8, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15767d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x156e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000588, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c31c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c31c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc80, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x956c2ff6, 0x100246c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95707ff6, 0x10024707, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95741ff6, 0x10024741, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x956c2ff6, 0x100246c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95707ff6, 0x10024707, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95741ff6, 0x10024741, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x000007a0, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c31c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x0e1cadc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff9e8, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100202e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100212e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff9f8, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x95492dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024a7c80, 0x10020827, // fsub r0,  a, b
+0x024a7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024a7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014e7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025892, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024a7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204e7, // fadd a+1, r0, r1
+0x029d2ec0, 0x10020827, // fsub r0,  a, b
+0x029d21c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d2e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d33c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024892, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d2e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214e7, // fadd a+1, r0, r1
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x202e7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cb017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cb01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x212e709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02427c80, 0x10020827, // fsub r0,  a, b
+0x02427180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02427c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01467380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025890, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02427c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020467, // fadd a+1, r0, r1
+0x029d0ec0, 0x10020827, // fsub r0,  a, b
+0x029d01c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d0e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d13c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024890, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d0e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021467, // fadd a+1, r0, r1
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cadc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff768, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff830, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_2048k.hex b/src/hex/shader_2048k.hex
new file mode 100644
index 0000000..c49cd94
--- /dev/null
+++ b/src/hex/shader_2048k.hex
@@ -0,0 +1,1353 @@
+0x00000010, 0xe0021227, // mov rb_0x10,    0x10
+0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
+0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000002e8, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x153a7d80, 0x10020827, // mov r0, ra_vdw_32
+0x8c04ddf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00080000, 0xe00208e7, // mov r3, PASS32_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000050, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000520, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x80904000, 0xe0020827, // mov r0, vdw_setup_0(1, 16, dma_h32(0,0))
+0x00000040, 0xe0020867, // mov r1, 0x40
+0x8c067c76, 0x10024061, // add ra_save_ptr, ra_save_ptr, r1; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00040000, 0xe00208e7, // mov r3, PASS64_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000002b8, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000e0, 0xf0f809e7, // brr -, r:2f
+0x00000010, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000c0, 0xf0f809e7, // brr -, r:2f
+0x00000011, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000a0, 0xf0f809e7, // brr -, r:2f
+0x00000012, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000080, 0xf0f809e7, // brr -, r:2f
+0x00000013, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000060, 0xf0f809e7, // brr -, r:2f
+0x00000014, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000040, 0xf0f809e7, // brr -, r:2f
+0x00000015, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000020, 0xf0f809e7, // brr -, r:2f
+0x00000016, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f809e7, // brr -, r:2f
+0x00000017, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000008, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000009, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000a, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000b, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000c, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000d, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000e, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000f, 0xe80009e7, // mov -, srel(i+8)
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000998, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffd50, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffbe0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
+0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
+0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
+0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
+0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffa30, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffff8c0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
+0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
+0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
+0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
+0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
+0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
+0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
+0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
+0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
+0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
+0x00000000, 0xf0f549e7, // bra -, ra_save_64
+0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
+0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
+0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
+0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff7e0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff790, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00001378, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c61c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c81c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff4f8, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000015, 0xe0020867, // mov r1, STAGES
+0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
+0xfffff4c8, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
+0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
+0x80904000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
+0x80905000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
+0x00000015, 0xe00212e7, // mov rb_STAGES, STAGES
+0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
+0x00000040, 0xe0021367, // mov rb_0x40, 0x40
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff8b0, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00007fff, 0xe0020827, // mov r0, 0x7FFF
+0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
+0xfffff880, 0xf01809e7, // brr.allnz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff5f0, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000007, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000006, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff380, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0xfffff360, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0xfffff340, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0xfffff320, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0x00000100, 0xe0020827, // mov r0, 0x100
+0xfffff088, 0xf00809e7, // brr.allz -, r:pass_3
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000060, 0xe0020827, // mov r0, (4-1)*4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000009, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000008, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xffffee18, 0xf0f80227, // brr ra_link_1, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xffffeb88, 0xf00809e7, // brr.allz -, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xffffec58, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_256.hex b/src/hex/shader_256.hex
new file mode 100644
index 0000000..bfd5b45
--- /dev/null
+++ b/src/hex/shader_256.hex
@@ -0,0 +1,359 @@
+0x00000040, 0xe00217a7, // mov rb_0x40,    0x40
+0x00000080, 0xe00217e7, // mov rb_0x80,    0x80
+0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
+0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
+0x88104000, 0xe0020727, // mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
+0x88104800, 0xe0021727, // mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))
+0x15827d80, 0x10020227, // mov rx_tw_shared, unif
+0x15827d80, 0x10021227, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x100246e0, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100256e0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100049e0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100009e7, // add out_3, r0, r2
+0x000000b0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156e7d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x15727d80, 0x10021c67, // mov vw_setup, arg_vdw
+0xc0000040, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
+0x8c05edf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156e7d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x156e7d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000248, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x202a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ca039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208acb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x202a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x202e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cb039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208bcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x202e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20327030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cc039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ccb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20327031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f489e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0xfffffe98, 0xf0f809e7, // brr -, r:fft_16
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000600, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c227c00, 0x10020e27, // add t0s, ptr, r0
+0x0c227c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffd50, 0xf0f80027, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0xfffffd30, 0xf0f80027, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9c8e00, 0x10020e27, // add t0s, ptr, r0
+0x0c9c8e40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c227c00, 0x10020e27, // add t0s, ptr, r0
+0x0c227c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
+0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb50, 0xf0f80027, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02367c80, 0x10020827, // fsub r0,  a, b
+0x02367180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02367c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x013a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02367c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100203a7, // fadd a+1, r0, r1
+0x029cdec0, 0x10020827, // fsub r0,  a, b
+0x029cd1c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029cde40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029cde80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100213a7, // fadd a+1, r0, r1
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0xfffff9c8, 0xf0f80027, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x956dbff6, 0x100246db, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x9571cff6, 0x1002471c, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0xfffff9d0, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_256k.hex b/src/hex/shader_256k.hex
new file mode 100644
index 0000000..d51e651
--- /dev/null
+++ b/src/hex/shader_256k.hex
@@ -0,0 +1,861 @@
+0x00000012, 0xe0021227, // mov rb_STAGES,  STAGES
+0x00000010, 0xe00216a7, // mov rb_0x10,    0x10
+0x00000040, 0xe00216e7, // mov rb_0x40,    0x40
+0x00000080, 0xe0021727, // mov rb_0x80,    0x80
+0x000000f0, 0xe0021767, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217a7, // mov rb_0x100,   0x100
+0x00001fff, 0xe00217e7, // mov rb_0x1FFF,  0x1FFF
+0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
+0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
+0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
+0x00ff00ff, 0xe0021627, // mov rx_0x00FF00FF, 0x00FF00FF
+0x0000ffff, 0xe0021667, // mov rx_0x0000FFFF, 0x0000FFFF
+0x80904000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0( 1, 16, dma_h32( 0,0))
+0x80905000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0( 1, 16, dma_h32(32,0))
+0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000001d0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x156e7d80, 0x10020827, // mov r0, arg_vdw
+0x8c05bdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00020000, 0xe00208e7, // mov r3, PASS16_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000000c8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc000ffc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05bdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000640, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d81c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d81c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9da1c0, 0x10020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119da3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9cb1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffd78, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d81c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d81c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9da1c0, 0x10020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119da3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9cb1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc30, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x00000000, 0xf0f489e7, // bra -, ra_save_16
+0x009e7000, 0x100009e7, // nop
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb38, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffae8, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000ef0, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d81c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d81c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9da1c0, 0x10020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119da3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9cb1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff928, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff900, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x141dfdc0, 0x100229e7, // and.setf -, ra_points, rb_0x1FFF
+0xfffff9e8, 0xf01809e7, // brr.allnz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff858, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff698, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0xfffff678, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0xfffff658, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0xfffff638, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff4a8, 0xf00809e7, // brr.allz -, r:pass_3
+0x00000060, 0xe0020827, // mov r0, 3*4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dcdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15adf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff2a0, 0xf0f80227, // brr ra_link_1, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff010, 0xf00809e7, // brr.allz -, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff0e0, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_2k.hex b/src/hex/shader_2k.hex
new file mode 100644
index 0000000..bd30abb
--- /dev/null
+++ b/src/hex/shader_2k.hex
@@ -0,0 +1,765 @@
+0x00000010, 0xe0021727, // mov rb_0x10,    0x10
+0x00000040, 0xe0021767, // mov rb_0x40,    0x40
+0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
+0x000001d0, 0xe00217e7, // mov rb_0x1D0,   0x1D0
+0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
+0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
+0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000c8, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15367d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc00001c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000000f8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0xa0104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(64, 16, dma_h32(0,0))
+0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(PASS64_STRIDE-16*4)
+0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, step; mov vw_addr, ra_save_ptr
+0x000002b8, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000e0, 0xf0f809e7, // brr -, r:2f
+0x00000010, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000c0, 0xf0f809e7, // brr -, r:2f
+0x00000011, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000a0, 0xf0f809e7, // brr -, r:2f
+0x00000012, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000080, 0xf0f809e7, // brr -, r:2f
+0x00000013, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000060, 0xf0f809e7, // brr -, r:2f
+0x00000014, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000040, 0xf0f809e7, // brr -, r:2f
+0x00000015, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000020, 0xf0f809e7, // brr -, r:2f
+0x00000016, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f809e7, // brr -, r:2f
+0x00000017, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000008, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000009, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000a, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000b, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000c, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000d, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000e, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000f, 0xe80009e7, // mov -, srel(i+8)
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000858, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc80, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
+0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
+0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
+0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffb20, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffa00, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
+0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
+0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
+0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
+0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
+0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
+0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
+0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
+0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
+0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
+0x00000000, 0xf0f549e7, // bra -, ra_save_64
+0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
+0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
+0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff920, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff8d0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x9534dff6, 0x1002434d, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000870, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c61c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c21c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff688, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x0e1cbdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff660, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
+0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
+0x90104000, 0xe0020367, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021367, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff920, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cbdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff690, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff760, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_32k.hex b/src/hex/shader_32k.hex
new file mode 100644
index 0000000..3b6fd77
--- /dev/null
+++ b/src/hex/shader_32k.hex
@@ -0,0 +1,697 @@
+0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
+0x00000040, 0xe0021727, // mov rb_0x40,    0x40
+0x00000080, 0xe0021767, // mov rb_0x80,    0x80
+0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
+0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
+0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
+0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202a7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212a7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246e0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000c8, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000588, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c21c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c21c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc80, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x204a7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d200f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204a700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22092c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x95682ff6, 0x10024682, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c7ff6, 0x100246c7, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000d00, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c21c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1cfdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff9e8, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100202e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100212e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff9f8, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff9d8, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff9b8, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff998, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x95492dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024a7c80, 0x10020827, // fsub r0,  a, b
+0x024a7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024a7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014e7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025892, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024a7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204e7, // fadd a+1, r0, r1
+0x029d2ec0, 0x10020827, // fsub r0,  a, b
+0x029d21c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d2e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d33c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024892, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d2e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214e7, // fadd a+1, r0, r1
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x202e7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cb017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cb01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x212e709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02427c80, 0x10020827, // fsub r0,  a, b
+0x02427180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02427c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01467380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025890, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02427c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020467, // fadd a+1, r0, r1
+0x029d0ec0, 0x10020827, // fsub r0,  a, b
+0x029d01c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d0e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d13c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024890, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d0e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021467, // fadd a+1, r0, r1
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cfdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff708, 0xf00809e7, // brr.allz -, r:pass_2
+0x00000060, 0xe0020827, // mov r0, 3*4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cae00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cae40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214a7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100202e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100212e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2a7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2a7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024451, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe00244d3, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff498, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x95492dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024a7c80, 0x10020827, // fsub r0,  a, b
+0x024a7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024a7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014e7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025892, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024a7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204e7, // fadd a+1, r0, r1
+0x029d2ec0, 0x10020827, // fsub r0,  a, b
+0x029d21c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d2e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d33c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024892, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d2e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214e7, // fadd a+1, r0, r1
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x202e7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cb017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cb01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x212e709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02427c80, 0x10020827, // fsub r0,  a, b
+0x02427180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02427c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01467380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025890, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02427c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020467, // fadd a+1, r0, r1
+0x029d0ec0, 0x10020827, // fsub r0,  a, b
+0x029d01c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d0e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d13c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024890, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d0e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021467, // fadd a+1, r0, r1
+0x95410dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cfdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff208, 0xf00809e7, // brr.allz -, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff2d0, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_4096k.hex b/src/hex/shader_4096k.hex
new file mode 100644
index 0000000..f49df21
--- /dev/null
+++ b/src/hex/shader_4096k.hex
@@ -0,0 +1,1523 @@
+0x00000010, 0xe0021227, // mov rb_0x10,    0x10
+0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
+0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000002e8, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x153a7d80, 0x10020827, // mov r0, ra_vdw_32
+0x8c04ddf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00100000, 0xe00208e7, // mov r3, PASS32_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000050, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000520, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x80904000, 0xe0020827, // mov r0, vdw_setup_0(1, 16, dma_h32(0,0))
+0x00000040, 0xe0020867, // mov r1, 0x40
+0x8c067c76, 0x10024061, // add ra_save_ptr, ra_save_ptr, r1; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00080000, 0xe00208e7, // mov r3, PASS64_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000002b8, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000e0, 0xf0f809e7, // brr -, r:2f
+0x00000010, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000c0, 0xf0f809e7, // brr -, r:2f
+0x00000011, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000a0, 0xf0f809e7, // brr -, r:2f
+0x00000012, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000080, 0xf0f809e7, // brr -, r:2f
+0x00000013, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000060, 0xf0f809e7, // brr -, r:2f
+0x00000014, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000040, 0xf0f809e7, // brr -, r:2f
+0x00000015, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000020, 0xf0f809e7, // brr -, r:2f
+0x00000016, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f809e7, // brr -, r:2f
+0x00000017, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000008, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000009, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000a, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000b, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000c, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000d, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000e, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000f, 0xe80009e7, // mov -, srel(i+8)
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000ba8, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffd50, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffbe0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
+0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
+0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
+0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
+0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffa30, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffff8c0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
+0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
+0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
+0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
+0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
+0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
+0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
+0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
+0x2225b19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
+0x206e701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
+0x00000000, 0xf0f549e7, // bra -, ra_save_64
+0x209db017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
+0x216c97d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
+0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff7e0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff790, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
+0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
+0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
+0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
+0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff700, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff6b0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
+0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
+0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
+0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
+0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
+0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
+0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
+0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
+0x2225b19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
+0x206e701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
+0x00000000, 0xf0f549e7, // bra -, ra_save_64
+0x209db017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
+0x216c97d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
+0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
+0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff5d0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff580, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x000016b8, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100206e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100216e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c61c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x55555555, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x33333333, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0f0f0f0f, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x00ff00ff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0000ffff, 0xe00208a7, // mov r2, mask
+0x149e7080, 0x10020867, // and r1, r0, r2
+0x0e9c81c0, 0x10020827, // shr r0, r0, shift
+0x149e7080, 0x10020827, // and r0, r0, r2
+0x119c83c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c71c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff2e8, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000016, 0xe0020867, // mov r1, STAGES
+0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
+0xfffff2b8, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100206e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100216e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe002469a, // mov ra_tw_re+TW48+1, 0; mov rb_tw_im+TW48+1, 0
+0x00000000, 0xe002471c, // mov ra_tw_re+TW64+1, 0; mov rb_tw_im+TW64+1, 0
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000007, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000006, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020767, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021767, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100207a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100217a7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c61c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff568, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x0000ffff, 0xe0020827, // mov r0, 0xFFFF
+0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
+0xfffff538, 0xf01809e7, // brr.allnz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
+0x956dbdbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x207a7016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209de017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209de01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x217a709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x026e7c80, 0x10020827, // fsub r0,  a, b
+0x026e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x026e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01727380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002589b, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x026e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020727, // fadd a+1, r0, r1
+0x029dbec0, 0x10020827, // fsub r0,  a, b
+0x029db1c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029dbe40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019dc3c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002489b, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029dbe80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021727, // fadd a+1, r0, r1
+0x95659dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20767016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209dd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209dd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2176709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02667c80, 0x10020827, // fsub r0,  a, b
+0x02667180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02667c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x016a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025899, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02667c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100206a7, // fadd a+1, r0, r1
+0x029d9ec0, 0x10020827, // fsub r0,  a, b
+0x029d91c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d9e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019da3c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024899, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d9e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100216a7, // fadd a+1, r0, r1
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x00000016, 0xe0020867, // mov r1, STAGES
+0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
+0xfffff0a0, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
+0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
+0x80904000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
+0x80905000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
+0x00000016, 0xe00212e7, // mov rb_STAGES, STAGES
+0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
+0x00000040, 0xe0021367, // mov rb_0x40, 0x40
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000009, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000008, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff008, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x000003ff, 0xe0020827, // mov r0, 0x3FF
+0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
+0xffffefd8, 0xf01809e7, // brr.allnz -, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100601e7, // add.ifnz ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xffffed48, 0xf00809e7, // brr.allz -, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x0000000b, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x0000000a, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xffffead8, 0xf0f80227, // brr ra_link_1, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cbdc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xffffe848, 0xf00809e7, // brr.allz -, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xffffe918, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_4k.hex b/src/hex/shader_4k.hex
new file mode 100644
index 0000000..c37e50d
--- /dev/null
+++ b/src/hex/shader_4k.hex
@@ -0,0 +1,514 @@
+0x00000020, 0xe0021767, // mov rb_0x20,    0x20
+0x00000040, 0xe00217a7, // mov rb_0x40,    0x40
+0x00000080, 0xe00217e7, // mov rb_0x80,    0x80
+0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
+0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
+0x88104000, 0xe00206e7, // mov ra_vdw, vdw_setup_0(16, 16, dma_h32( 0,0))
+0x88104800, 0xe00216e7, // mov rb_vdw, vdw_setup_0(16, 16, dma_h32(16,0))
+0x15827d80, 0x10020227, // mov rx_tw_shared, unif
+0x15827d80, 0x10021227, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x100246a0, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100256a0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100049e0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100009e7, // add out_3, r0, r2
+0x000000b0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
+0xc00007c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
+0x8c05edf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x156a7d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x000003e8, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f409e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x202a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ca039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208acb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x202a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x202e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cb039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208bcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x202e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20327030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cc039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ccb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20327031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20367030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cd039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208dcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20367031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f489e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c11c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
+0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
+0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
+0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
+0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
+0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
+0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
+0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
+0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
+0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
+0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
+0xfffffd40, 0xf0f809e7, // brr -, r:fft_16
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffcf8, 0xf0f809e7, // brr -, r:fft_16
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000928, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c227c00, 0x10020e27, // add t0s, ptr, r0
+0x0c227c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c11c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x000000cc, 0xe20229e7, // mov.setf  -, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
+0x959fa000, 0xd002c8a0, // mov r2, r0; mov.ifnz r0, r0 << 6
+0x959fa249, 0xd002c8e1, // mov r3, r1; mov.ifnz r1, r1 << 6
+0x00003300, 0xe20229e7, // mov.setf  -, [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
+0x809f6012, 0xd000c9e0, // nop; mov.ifnz r0, r2 >> 6
+0x809f601b, 0xd000c9e1, // nop; mov.ifnz r1, r3 >> 6
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffbe0, 0xf0f80027, // brr ra_link_1, r:pass_1
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffffbb8, 0xf00809e7, // brr.allz -, r:pass_1
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c227c00, 0x10020e27, // add t0s, ptr, r0
+0x0c227c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c227c00, 0x10020e27, // add t0s, ptr, r0
+0x0c227c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
+0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb78, 0xf0f80027, // brr ra_link_1, r:pass_2
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0xfffffb58, 0xf0f80027, // brr ra_link_1, r:pass_2
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x0d01ddc0, 0x10020027, // sub ra_link_1, ra_link_1, rb_0x20
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02367c80, 0x10020827, // fsub r0,  a, b
+0x02367180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02367c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x013a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02367c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100203a7, // fadd a+1, r0, r1
+0x029cdec0, 0x10020827, // fsub r0,  a, b
+0x029cd1c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029cde40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029cde80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100213a7, // fadd a+1, r0, r1
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff9c0, 0xf00809e7, // brr.allz -, r:pass_2
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9c8e00, 0x10020e27, // add t0s, ptr, r0
+0x0c9c8e40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c227c00, 0x10020e27, // add t0s, ptr, r0
+0x0c227c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020267, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021267, // mov rb_tw_im+dst, r4
+0x00000000, 0xe002438e, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff808, 0xf0f80027, // brr ra_link_1, r:pass_3
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20267016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209c9017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209c901f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2126709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02367c80, 0x10020827, // fsub r0,  a, b
+0x02367180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02367c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x013a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002588d, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02367c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100203a7, // fadd a+1, r0, r1
+0x029cdec0, 0x10020827, // fsub r0,  a, b
+0x029cd1c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029cde40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019ce3c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x1002488d, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029cde80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100213a7, // fadd a+1, r0, r1
+0x9534ddbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c362, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d363, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c322, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d323, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c2e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d2e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c2a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d2a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1ccdc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff678, 0xf00809e7, // brr.allz -, r:pass_3
+0x9569aff6, 0x1002469a, // mov ra_vpm, rb_vpm; mov rb_vpm, ra_vpm
+0x956dbff6, 0x100246db, // mov ra_vdw, rb_vdw; mov rb_vdw, ra_vdw
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c027, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff6a8, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_512.hex b/src/hex/shader_512.hex
new file mode 100644
index 0000000..505ab41
--- /dev/null
+++ b/src/hex/shader_512.hex
@@ -0,0 +1,494 @@
+0x00000010, 0xe0021727, // mov rb_0x10,    0x10
+0x00000040, 0xe0021767, // mov rb_0x40,    0x40
+0x00000080, 0xe00217a7, // mov rb_0x80,    0x80
+0x000000f0, 0xe00217e7, // mov rb_0xF0,    0xF0
+0x00005555, 0xe0020727, // mov rx_0x5555,  0x5555
+0x00003333, 0xe0020767, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207a7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00207e7, // mov rx_0x00FF,  0x00FF
+0x88104000, 0xe00206a7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
+0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
+0x90104000, 0xe00206e7, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10024620, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x10024660, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000b0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15627d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x156a7d80, 0x10021c67, // mov vw_setup, arg_vdw
+0xc00000c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
+0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15627d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15627d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000000c8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15627d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x156e7d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc0000040, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15627d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15627d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000510, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15fdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc80, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95602ff6, 0x10024602, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95647ff6, 0x10024647, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x956c1ff6, 0x100246c1, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffbf0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x00000000, 0xf0f489e7, // bra -, ra_save_16
+0x009e7000, 0x100009e7, // nop
+0x95602ff6, 0x10024602, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95680ff6, 0x10024680, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x000005e8, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14727180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14727180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9c41c0, 0xd0020827, // shr r0, r0, 13-STAGES
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa80, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0xfffffa60, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb20, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c9dc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff990, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dedc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff9e8, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_512k.hex b/src/hex/shader_512k.hex
new file mode 100644
index 0000000..ebc84d8
--- /dev/null
+++ b/src/hex/shader_512k.hex
@@ -0,0 +1,983 @@
+0x00000013, 0xe0021227, // mov rb_STAGES,  STAGES
+0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
+0x00000040, 0xe0021727, // mov rb_0x40,    0x40
+0x00000080, 0xe0021767, // mov rb_0x80,    0x80
+0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
+0x55555555, 0xe0020767, // mov rx_0x55555555, 0x55555555
+0x33333333, 0xe00207a7, // mov rx_0x33333333, 0x33333333
+0x0f0f0f0f, 0xe00207e7, // mov rx_0x0F0F0F0F, 0x0F0F0F0F
+0x00ff00ff, 0xe0021667, // mov rx_0x00FF00FF, 0x00FF00FF
+0x0000ffff, 0xe00216a7, // mov rx_0x0000FFFF, 0x0000FFFF
+0x80904000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(1, 16, dma_h32( 0,0))
+0x80905000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(1, 16, dma_h32(32,0))
+0x80904000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(1, 16, dma_h32( 0,0))
+0x80905000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(1, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000001d0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x156e7d80, 0x10020827, // mov r0, arg_vdw
+0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00040000, 0xe00208e7, // mov r3, PASS16_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000002e8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x15727d80, 0x10020827, // mov r0, ra_vdw_32
+0x8c05cdf6, 0x10024061, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov r1, ra_save_ptr
+0x00000080, 0xe00208a7, // mov r2, vdw_setup_0(1, 16, dma_h32(1,0)) - vdw_setup_0(1, 16, dma_h32(0,0))
+0x00020000, 0xe00208e7, // mov r3, PASS32_STRIDE
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x8c9e7080, 0x10024831, // add r0, r0, r2; mov vw_setup, r0
+0x8c9e72c9, 0x10024872, // add r1, r1, r3; mov vw_addr,  r1
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000640, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9db1c0, 0x10020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119db3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffd78, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9db1c0, 0x10020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119db3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc30, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffba0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x00000000, 0xf0f489e7, // bra -, ra_save_16
+0x009e7000, 0x100009e7, // nop
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb38, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffae8, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x000010a8, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149d91c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149d91c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9db1c0, 0x10020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119db3c0, 0x10020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0e9ca1c0, 0xd0020827, // shr r0, r0, 32-STAGES-3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff928, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff900, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa10, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00003fff, 0xe0020827, // mov r0, 0x3FFF
+0x141e7c00, 0x100229e7, // and.setf -, ra_points, r0
+0xfffff9e0, 0xf01809e7, // brr.allnz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100601e7, // add.ifnz ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff850, 0xf00809e7, // brr.allz -, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff648, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff628, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff608, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0xfffff5e8, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff358, 0xf00809e7, // brr.allz -, r:pass_3
+0x00000060, 0xe0020827, // mov r0, 3*4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000006, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020367, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021367, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff0e8, 0xf0f80227, // brr ra_link_1, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x954d3dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20367016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cd017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cd01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2136709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x024e7c80, 0x10020827, // fsub r0,  a, b
+0x024e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x024e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01527380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x024e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020527, // fadd a+1, r0, r1
+0x029d3ec0, 0x10020827, // fsub r0,  a, b
+0x029d31c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d3e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d43c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024893, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d3e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021527, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xffffee58, 0xf00809e7, // brr.allz -, r:pass_4
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xffffef28, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_64k.hex b/src/hex/shader_64k.hex
new file mode 100644
index 0000000..5daa0a5
--- /dev/null
+++ b/src/hex/shader_64k.hex
@@ -0,0 +1,940 @@
+0x00000010, 0xe0021227, // mov rb_0x10,    0x10
+0x000001d0, 0xe0021967, // mov r5rep,      0x1D0
+0x00005555, 0xe00207a7, // mov rx_0x5555,  0x5555
+0x00003333, 0xe00217a7, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00217e7, // mov rx_0x00FF,  0x00FF
+0x15827d80, 0x100203e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100213e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10025020, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x10025060, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000c8, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x153a7d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc0003fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c04ddf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x15327d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x152e7d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000100, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000040, 0xe0020827, // mov r0, 0x40
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0xa0104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(64, 16, dma_h32(0,0))
+0xc0001fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(PASS64_STRIDE-16*4)
+0x8c067c36, 0x10024072, // add ra_save_ptr, ra_save_ptr, step; mov vw_addr, ra_save_ptr
+0x000002b8, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd00200a7, // shl ra_temp, r0, 5
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000e0, 0xf0f809e7, // brr -, r:2f
+0x00000010, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000c0, 0xf0f809e7, // brr -, r:2f
+0x00000011, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x000000a0, 0xf0f809e7, // brr -, r:2f
+0x00000012, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000080, 0xf0f809e7, // brr -, r:2f
+0x00000013, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000060, 0xf0f809e7, // brr -, r:2f
+0x00000014, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000040, 0xf0f809e7, // brr -, r:2f
+0x00000015, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000020, 0xf0f809e7, // brr -, r:2f
+0x00000016, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f809e7, // brr -, r:2f
+0x00000017, 0xe80009e7, // mov -, sacq(i)
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c0fc0, 0x10021c67, // mov vw_setup, rb_vpm
+0x012cbdc0, 0x10020c27, // fadd vpm, ra_64+0, rb_64+0
+0x0130cdc0, 0x10020c27, // fadd vpm, ra_64+1, rb_64+1
+0x159c1fc0, 0x10021c67, // mov vw_setup, rb_vpm_16
+0x0134ddc0, 0x10020c27, // fadd vpm, ra_64+2, rb_64+2
+0x0138edc0, 0x10020c27, // fadd vpm, ra_64+3, rb_64+3
+0x159c2fc0, 0x10021c67, // mov vw_setup, rb_vpm_32
+0x022cbdc0, 0x10020c27, // fsub vpm, ra_64+0, rb_64+0
+0x0230cdc0, 0x10020c27, // fsub vpm, ra_64+1, rb_64+1
+0x159c7fc0, 0x10021c67, // mov vw_setup, rb_vpm_48
+0x0234ddc0, 0x10020c27, // fsub vpm, ra_64+2, rb_64+2
+0x0238edc0, 0x10020c27, // fsub vpm, ra_64+3, rb_64+3
+0x00000000, 0xf0fc49e7, // brr -, ra_temp
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000008, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000009, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000a, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000b, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000c, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000d, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000e, 0xe80009e7, // mov -, srel(i+8)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x159c0fc0, 0x10020c67, // mov vr_setup, rb_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x0000000f, 0xe80009e7, // mov -, srel(i+8)
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000858, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d2039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22092cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x204e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d3039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22093cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x204e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20527030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d4039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22094cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20527031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20567030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d5039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22095cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20567031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda0, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc80, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x01267c00, 0x100202e7, // fadd ra_64+0, ra_32_re, r0
+0x019c9e40, 0x10020327, // fadd ra_64+1, rb_32_im, r1
+0x02267c00, 0x10020367, // fsub ra_64+2, ra_32_re, r0
+0x029c9e40, 0x100203a7, // fsub ra_64+3, rb_32_im, r1
+0x8c167d76, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffb20, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffa00, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x029c9e40, 0x100208e7, // fsub r3, rb_32_im, r1
+0x02267c00, 0x100208a7, // fsub r2, ra_32_re, r0
+0x019c9e40, 0x10020867, // fadd r1, rb_32_im, r1
+0x01267c00, 0x10020827, // fadd r0, ra_32_re, r0
+0x2066700e, 0x100049c9, // nop;                        fmul rb_32_im, r1, ra_tw_re+TW48
+0x209d900f, 0x100059c9, // nop;                        fmul ra_32_re, r1, rb_tw_im+TW48
+0x209d9007, 0x100049e1, // nop;                        fmul r1,       r0, rb_tw_im+TW48
+0x216493c6, 0x10025320, // fadd rb_64+1, r1, rb_32_im; fmul r0,       r0, ra_tw_re+TW48
+0x2225a19f, 0x100252c9, // fsub rb_64+0, r0, ra_32_re; fmul ra_32_re, r3, rb_tw_im+TW64
+0x206a701e, 0x100049c9, // nop;                        fmul rb_32_im, r3, ra_tw_re+TW64
+0x00000000, 0xf0f549e7, // bra -, ra_save_64
+0x209da017, 0x100049e3, // nop;                        fmul r3,       r2, rb_tw_im+TW64
+0x216897d6, 0x100253a2, // fadd rb_64+3, r3, rb_32_im; fmul r2,       r2, ra_tw_re+TW64
+0x02267580, 0x10021367, // fsub rb_64+2, r2, ra_32_re
+0x8c14cdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff920, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff8d0, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x205e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d700f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x205e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22097c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f489e7, // bra -, ra_save_32
+0x952c2ff6, 0x100242c2, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95307ff6, 0x10024307, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x9538eff6, 0x1002438e, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_32, rx_save_slave_32
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_64, rx_save_slave_64
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000df0, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020667, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021667, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100206a7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100216a7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c61c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149de1c0, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x149de1c0, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149df1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149df1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x119c31c0, 0xd0020827, // shl r0, r0, STAGES-13
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff688, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000010, 0xe0020867, // mov r1, STAGES
+0x0e1e7c40, 0x100229e7, // shr.setf -, ra_points, r1
+0xfffff658, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x00000200, 0xe0020827, // mov r0, 0x200
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159c0fc0, 0x100202e7, // mov ra_vpm_lo, rb_vpm
+0x159c1fc0, 0x10020327, // mov ra_vpm_hi, rb_vpm_16
+0x90104000, 0xe00203a7, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe00213a7, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x00000060, 0xe00212e7, // mov rb_3x4x8, 3*4*8
+0x000000f0, 0xe0021327, // mov rb_0xF0, 0xF0
+0x00000040, 0xe0021367, // mov rb_0x40, 0x40
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000005, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000004, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff900, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0xfffff8e0, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0xfffff8c0, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0xfffff8a0, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff610, 0xf00809e7, // brr.allz -, r:pass_2
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x0d20bdc0, 0x10020227, // sub ra_link_1, ra_link_1, rb_3x4x8
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020567, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021567, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cfe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cfe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100205e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100215e7, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000007, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020427, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021427, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000006, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c3e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c3e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024596, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024618, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c148df6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff3a0, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x955d7dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20467016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d1017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d101f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2146709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x025e7c80, 0x10020827, // fsub r0,  a, b
+0x025e7180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x025e7c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x01627380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x025e7c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10020627, // fadd a+1, r0, r1
+0x029d7ec0, 0x10020827, // fsub r0,  a, b
+0x029d71c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d7e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d83c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024897, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d7e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x10021627, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20427016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209d0017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209d001f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2142709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02567c80, 0x10020827, // fsub r0,  a, b
+0x02567180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02567c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x015a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02567c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100205a7, // fadd a+1, r0, r1
+0x029d5ec0, 0x10020827, // fsub r0,  a, b
+0x029d51c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d5e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d63c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024895, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d5e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100215a7, // fadd a+1, r0, r1
+0x95555dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c562, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d563, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c522, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d523, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c4e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d4e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c4a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d4a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1c8dc0, 0x100229e7, // shr.setf -, ra_points, rb_STAGES
+0xfffff110, 0xf00809e7, // brr.allz -, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x00000100, 0xe0020827, // mov r0, 0x100
+0x0c1e7c00, 0x100201e7, // add ra_points, ra_points, r0
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff1e0, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_8k.hex b/src/hex/shader_8k.hex
new file mode 100644
index 0000000..7e1f112
--- /dev/null
+++ b/src/hex/shader_8k.hex
@@ -0,0 +1,603 @@
+0x00000010, 0xe00216e7, // mov rb_0x10,    0x10
+0x00000040, 0xe0021727, // mov rb_0x40,    0x40
+0x00000080, 0xe0021767, // mov rb_0x80,    0x80
+0x000000f0, 0xe00217a7, // mov rb_0xF0,    0xF0
+0x00000100, 0xe00217e7, // mov rb_0x100,   0x100
+0x00005555, 0xe0020767, // mov rx_0x5555,  0x5555
+0x00003333, 0xe00207a7, // mov rx_0x3333,  0x3333
+0x00000f0f, 0xe00207e7, // mov rx_0x0F0F,  0x0F0F
+0x000000ff, 0xe00216a7, // mov rx_0x00FF,  0x00FF
+0x88104000, 0xe00206e7, // mov ra_vdw_16, vdw_setup_0(16, 16, dma_h32( 0,0))
+0x88105000, 0xe0021027, // mov rb_vdw_16, vdw_setup_0(16, 16, dma_h32(32,0))
+0x90104000, 0xe0020727, // mov ra_vdw_32, vdw_setup_0(32, 16, dma_h32( 0,0))
+0x90105000, 0xe0021067, // mov rb_vdw_32, vdw_setup_0(32, 16, dma_h32(32,0))
+0x15827d80, 0x100202e7, // mov rx_tw_shared, unif
+0x15827d80, 0x100212e7, // mov rx_tw_unique, unif
+0x15827d80, 0x10021167, // mov rb_inst, unif
+0x00101200, 0xe0020827, // mov r0, vpm_setup(1, 1, v32( 0,0))
+0x00000010, 0xe0020867, // mov r1, vpm_setup(1, 1, v32(16,0)) - vpm_setup(1, 1, v32(0,0))
+0x00000002, 0xe00208a7, // mov r2, vpm_setup(1, 1, v32( 0,2)) - vpm_setup(1, 1, v32(0,0))
+0x409c5017, 0x100049e2, // nop; mul24 r2, r2, in_inst
+0xcc9e7081, 0x10024660, // add out_0, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100246a0, // add out_1, r0, r2; v8adds r0, r0, r1
+0xcc9e7081, 0x100250a0, // add out_2, r0, r2; v8adds r0, r0, r1
+0x0c9e7080, 0x100211e7, // add out_3, r0, r2
+0x000000b0, 0xf0f80127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x156e7d80, 0x10021c67, // mov vw_setup, arg_vdw
+0xc0000fc0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS16_STRIDE-16*4
+0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000038, 0xf0f81127, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, arg
+0x159e7000, 0x10020c27, // mov vpm, r0
+0x159e7240, 0x10020c27, // mov vpm, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, arg_vpm
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x000000c8, 0xf0f802a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x15727d80, 0x10021c67, // mov vw_setup, ra_vdw_32
+0xc00007c0, 0xe0021c67, // mov vw_setup, vdw_setup_1(0) + PASS32_STRIDE-16*4
+0x8c05cdf6, 0x10024072, // add ra_save_ptr, ra_save_ptr, rb_0x40; mov vw_addr, ra_save_ptr
+0x00000050, 0xf0f812a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10021c67, // mov vw_setup, ra_vpm_lo
+0x01267c00, 0x10020c27, // fadd vpm, ra_32_re, r0
+0x019c9e40, 0x10020c27, // fadd vpm, rb_32_im, r1
+0x156a7d80, 0x10021c67, // mov vw_setup, ra_vpm_hi
+0x02267c00, 0x10020c27, // fsub vpm, ra_32_re, r0
+0x029c9e40, 0x10020c27, // fsub vpm, rb_32_im, r1
+0x00000000, 0xf0f4c9e7, // bra -, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x15667d80, 0x10020c67, // mov vr_setup, ra_vpm_lo
+0x15c27d80, 0x100009e7, // mov -, vpm
+0x00000080, 0xf0f801a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x00000019, 0xe80009e7, // mov -, sacq(i+9)
+0x00000001, 0xe80009e7, // mov -, srel(i+1)
+0x0000001a, 0xe80009e7, // mov -, sacq(i+9)
+0x00000002, 0xe80009e7, // mov -, srel(i+1)
+0x0000001b, 0xe80009e7, // mov -, sacq(i+9)
+0x00000003, 0xe80009e7, // mov -, srel(i+1)
+0x0000001c, 0xe80009e7, // mov -, sacq(i+9)
+0x00000004, 0xe80009e7, // mov -, srel(i+1)
+0x0000001d, 0xe80009e7, // mov -, sacq(i+9)
+0x00000005, 0xe80009e7, // mov -, srel(i+1)
+0x0000001e, 0xe80009e7, // mov -, sacq(i+9)
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000006, 0xe80009e7, // mov -, srel(i+1)
+0x0000001f, 0xe80009e7, // mov -, sacq(i+9)
+0x00000007, 0xe80009e7, // mov -, srel(i+1)
+0x00000500, 0xf0f811a7, // brr rx_ptr, label
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x00000009, 0xe80009e7, // mov -, srel(i+9)
+0x00000011, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000a, 0xe80009e7, // mov -, srel(i+9)
+0x00000012, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000b, 0xe80009e7, // mov -, srel(i+9)
+0x00000013, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000c, 0xe80009e7, // mov -, srel(i+9)
+0x00000014, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000d, 0xe80009e7, // mov -, srel(i+9)
+0x00000015, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000e, 0xe80009e7, // mov -, srel(i+9)
+0x00000016, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x00000000, 0xf0f509e7, // bra -, ra_link_1
+0x0000000f, 0xe80009e7, // mov -, srel(i+9)
+0x00000017, 0xe80009e7, // mov -, sacq(i+1)
+0x009e7000, 0x100009e7, // nop
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203a7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209ce039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208ecb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203a7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819ff2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f1400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829ff609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f1449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x203e7030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209cf039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x2208fcb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x203e7031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fe2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f2400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fe609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f2449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20427030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d0039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22090cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20427031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819fc2c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f4400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x829fc609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f4449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (1<<i)
+0x20467030, 0x1000d9c2, // nop;                       fmul.ifnz ra_temp, ra_tw_re+TW16+i, r0
+0x209d1039, 0x1000c9e2, // nop;                       fmul.ifnz r2,      rb_tw_im+TW16+i, r1
+0x22091cb8, 0x1006c823, // fsub.ifnz r0, ra_temp, r2; fmul.ifnz r3,      rb_tw_im+TW16+i, r0
+0x20467031, 0x1000c9e1, // nop;                       fmul.ifnz r1,      ra_tw_re+TW16+i, r1
+0x819f82c0, 0xd0064862, // fadd.ifnz r1, r1, r3; mov r2, r0 << (1<<i)
+0x819f8400, 0xd0044823, // fadd.ifz  r0, r2, r0; mov r3, r0 >> (1<<i)
+0x00000000, 0xf0f409e7, // bra -, ra_link_0
+0x829f8609, 0xd0064822, // fsub.ifnz r0, r3, r0; mov r2, r1 << (1<<i)
+0x819f8449, 0xd0044863, // fadd.ifz  r1, r2, r1; mov r3, r1 >> (1<<i)
+0x029e7640, 0x10060867, // fsub.ifnz r1, r3, r1
+0x8c15edf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffda8, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x959e7009, 0x10024249, // mov ra_32_re, r0; mov rb_32_im, r1
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0xfffffc90, 0xf0f80027, // brr ra_link_0, call
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x204e7006, 0x100059c2, // nop;                  fmul ra_temp, r0, ra_tw_re+TW32
+0x209d300f, 0x100049e2, // nop;                  fmul r2,      r1, rb_tw_im+TW32
+0x204e700e, 0x100049e3, // nop;                  fmul r3,      r1, ra_tw_re+TW32
+0x22093c87, 0x10024821, // fsub r0, ra_temp, r2; fmul r1,      r0, rb_tw_im+TW32
+0x019e72c0, 0x10020867, // fadd r1, r1,      r3
+0x00000000, 0xf0f549e7, // bra -, ra_save_32
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x95687ff6, 0x10024687, // mov ra_vpm_hi, rb_vpm_hi; mov rb_vpm_hi, ra_vpm_hi
+0x95701ff6, 0x10024701, // mov ra_vdw_32, rb_vdw_32; mov rb_vdw_32, ra_vdw_32
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffc00, 0xf0f80027, // brr ra_link_0, call
+0x009e7000, 0xa00009e7, // nop;        ldtmu0
+0x159e7900, 0xa0020827, // mov r0, r4; ldtmu0
+0x159e7900, 0x10020867, // mov r1, r4
+0x00000000, 0xf0f489e7, // bra -, ra_save_16
+0x009e7000, 0x100009e7, // nop
+0x95642ff6, 0x10024642, // mov ra_vpm_lo, rb_vpm_lo; mov rb_vpm_lo, ra_vpm_lo
+0x956c0ff6, 0x100246c0, // mov ra_vdw_16, rb_vdw_16; mov rb_vdw_16, ra_vdw_16
+0x159c5fc0, 0x10022827, // mov.setf r0, rb_inst
+0x0d9c11c0, 0xd0020827, // sub r0, r0, 1
+0x119c51c0, 0xd0020827, // shl r0, r0, 5
+0x0c9c6e00, 0x100601a7, // add.ifnz ra_sync, rx_sync_slave, r0
+0x159c4fc0, 0x10060127, // mov.ifnz ra_save_16, rx_save_slave_16
+0x159cafc0, 0x100602a7, // mov.ifnz ra_save_32, rx_save_slave_32
+0x15827d80, 0x100220e7, // mov.setf ra_addr_x, unif
+0x15827d80, 0x100210e7, // mov      rb_addr_y, unif
+0x00000958, 0xf00809e7, // brr.allz -, r:end
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100204e7, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x100214e7, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c51c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15bdf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x14767180, 0x10020867, // and r1, r0, mask
+0x0e9c11c0, 0xd0020827, // shr r0, r0, shift
+0x14767180, 0x10020827, // and r0, r0, mask
+0x119c13c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147a7180, 0x10020867, // and r1, r0, mask
+0x0e9c21c0, 0xd0020827, // shr r0, r0, shift
+0x147a7180, 0x10020827, // and r0, r0, mask
+0x119c23c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x147e7180, 0x10020867, // and r1, r0, mask
+0x0e9c41c0, 0xd0020827, // shr r0, r0, shift
+0x147e7180, 0x10020827, // and r0, r0, mask
+0x119c43c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x149da1c0, 0x10020867, // and r1, r0, mask
+0x0e9c81c0, 0xd0020827, // shr r0, r0, shift
+0x149da1c0, 0x10020827, // and r0, r0, mask
+0x119c83c0, 0xd0020867, // shl r1, r1, shift
+0x159e7040, 0x10020827, // or  r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x94981dc0, 0xd00269e2, // and.setf -, elem_num, 1; mov r2, r0
+0x959f1489, 0xd004c820, // mov.ifz  r0, r2; mov.ifnz r0, r1 >> 1
+0x959ff252, 0xd0068861, // mov.ifnz r1, r1; mov.ifz  r1, r2 << 1
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffa98, 0xf0f80227, // brr ra_link_1, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffffa70, 0xf00809e7, // brr.allz -, r:pass_1
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dfdc0, 0x100201e7, // add ra_points, ra_points, rb_0x100
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000001, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000002, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffffb20, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0xfffffb00, 0xf0f80227, // brr ra_link_1, r:pass_2
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff970, 0xf00809e7, // brr.allz -, r:pass_2
+0x00000020, 0xe0020827, // mov r0, 4*8
+0x0d227c00, 0x10020227, // sub ra_link_1, ra_link_1, r0
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0x950c3dbf, 0x100250c3, // mov rb_addr_y, ra_addr_x; mov ra_addr_x, rb_addr_y
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000000, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c9cbe00, 0x10020e27, // add t0s, ptr, r0
+0x0c9cbe40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020467, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021467, // mov rb_tw_im+dst, r4
+0x11983dc0, 0xd0020827, // shl r0, elem_num, 3
+0x00000003, 0xe0020867, // mov r1, src
+0x119c73c0, 0xd0020867, // shl r1, r1, 7
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c2e7c00, 0x10020e27, // add t0s, ptr, r0
+0x0c2e7c40, 0x10020e27, // add t0s, ptr, r1
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020327, // mov ra_tw_re+dst, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10021327, // mov rb_tw_im+dst, r4
+0x00000000, 0xe0024492, // mov ra_tw_re+TW16+4, 0; mov rb_tw_im+TW16+4, 0
+0x00000000, 0xe0024514, // mov ra_tw_re+TW32+1, 0; mov rb_tw_im+TW32+1, 0
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x159c5fc0, 0x10020827, // mov r0, rb_inst
+0x119c41c0, 0xd0020827, // shl r0, r0, m
+0x0c9a7180, 0x10020167, // add ra_load_idx, r0, elem_num
+0x00000000, 0xe00201e7, // mov ra_points, 0
+0x159c3fc0, 0x10020067, // mov ra_save_ptr, rb_addr_y
+0x8c15ddf6, 0x10024160, // add ra_load_idx, ra_load_idx, stride; mov r0, ra_load_idx
+0x119c31c0, 0xd0020827, // shl r0, r0, 3
+0x0c9c41c0, 0xd0020867, // add r1, r0, 4
+0x0c0e7c00, 0x10020e27, // add t0s, ra_addr_x, r0
+0x0c0e7c40, 0x10020e27, // add t0s, ra_addr_x, r1
+0xfffff7b0, 0xf0f80227, // brr ra_link_1, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+base; mov r3, rb_tw_im+base
+0x20327016, 0x100049e0, // nop;             fmul r0, r2, ra_tw_re+step
+0x209cc017, 0x100049e1, // nop;             fmul r1, r2, rb_tw_im+step
+0x209cc01f, 0x100049e2, // nop;             fmul r2, r3, rb_tw_im+step
+0x2132709e, 0x100248a3, // fadd r2, r0, r2; fmul r3, r3, ra_tw_re+step
+0x029e7640, 0x100208e7, // fsub r3, r3, r1
+0x02467c80, 0x10020827, // fsub r0,  a, b
+0x02467180, 0x10020867, // fsub r1, r0, a
+0x019e7280, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x02467c40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x014a7380, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10025891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x02467c80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100204a7, // fadd a+1, r0, r1
+0x029d1ec0, 0x10020827, // fsub r0,  a, b
+0x029d11c0, 0x10020867, // fsub r1, r0, a
+0x019e72c0, 0x100208a7, // fadd r2, r1, b
+0x029e7040, 0x10020867, // fsub r1, r0, r1
+0x029d1e40, 0x10020867, // fsub r1,  a, r1
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x019d23c0, 0x10020867, // fadd r1, r1, a+1
+0x019e7040, 0x100208a7, // fadd r2, r0, r1
+0x829e7412, 0x10024891, // fsub r2, r2, r0; mov a, r2
+0x029e7280, 0x10020867, // fsub r1, r1, r2
+0x029d1e80, 0x100208a7, // fsub r2,  a, r2
+0x029e7080, 0x10020827, // fsub r0, r0, r2
+0x019e7040, 0x100214a7, // fadd a+1, r0, r1
+0x95451dbf, 0x100248a3, // mov r2, ra_tw_re+TW16+3; mov r3, rb_tw_im+TW16+3
+0x14988dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f8492, 0xd002c462, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f86db, 0xd002d463, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14984dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f4492, 0xd002c422, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f46db, 0xd002d423, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14982dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f2492, 0xd002c3e2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f26db, 0xd002d3e3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x14981dc0, 0xd00229e7, // and.setf -, elem_num, (8>>i)
+0x959f1492, 0xd002c3a2, // mov ra_tw_re+TW16+3-i, r2; mov.ifnz r2, r2 >> (8>>i)
+0x959f16db, 0xd002d3a3, // mov rb_tw_im+TW16+3-i, r3; mov.ifnz r3, r3 >> (8>>i)
+0x0e1cddc0, 0xd00229e7, // shr.setf -, ra_points, STAGES
+0xfffff620, 0xf00809e7, // brr.allz -, r:pass_3
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c1dddc0, 0x100201e7, // add ra_points, ra_points, rb_0x80
+0x00000000, 0xf0f4c227, // bra ra_link_1, ra_sync
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0xa00009e7, // ldtmu0
+0x009e7000, 0xa00009e7, // ldtmu0
+0xfffff678, 0xf0f809e7, // brr -, r:loop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x159c3fc0, 0x100209a7, // mov interrupt, flag
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/hex/shader_trans.hex b/src/hex/shader_trans.hex
new file mode 100644
index 0000000..93af75e
--- /dev/null
+++ b/src/hex/shader_trans.hex
@@ -0,0 +1,126 @@
+0x15827d80, 0x10020e27, // mov t0s, unif
+0x009e7000, 0xa00009e7, // ldtmu0
+0x0c9cc9c0, 0xd0020e27, // add t0s, r4, 3*4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x0c827980, 0x100200a7, // add ra_src_base, r4, unif
+0x15827d80, 0x10020e27, // mov t0s, unif
+0x009e7000, 0xa00009e7, // ldtmu0
+0x0c9cc9c0, 0xd0020e27, // add t0s, r4, 3*4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x0c827980, 0x100200e7, // add ra_dst_base, r4, unif
+0x15827d80, 0x100214a7, // mov rb_Y_STRIDE_SRC, unif
+0x15827d80, 0x100214e7, // mov rb_Y_STRIDE_DST, unif
+0x15827d80, 0x10021527, // mov rb_NX,           unif
+0x15827d80, 0x10021567, // mov rb_NY,           unif
+0x00000008, 0xe0021467, // mov rb_X_STRIDE, 2*4
+0x00000010, 0xe0021427, // mov rb_0x10, 0x10
+0xc0000000, 0xe0020827, // mov r0, vdw_setup_1(0)
+0x0c9d31c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_DST
+0x00000040, 0xe0020867, // mov r1, 16*4
+0x0d9e7040, 0x100201a7, // sub ra_vdw_stride, r0, r1
+0x40991037, 0x100049e0, // nop; mul24 r0, elem_num, rb_X_STRIDE
+0x159e7000, 0x10021027, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd0021227, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x10021067, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd0021267, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x100210a7, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd00212a7, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x100210e7, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd00212e7, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x10021127, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd0021327, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x10021167, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd0021367, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x100211a7, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd00213a7, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x159e7000, 0x100211e7, // mov rb_offsets_re+i, r0
+0x0c9c41c0, 0xd00213e7, // add rb_offsets_im+i, r0, 4
+0x0c9d21c0, 0x10020827, // add r0, r0, rb_Y_STRIDE_SRC
+0x00000000, 0xe0020067, // mov ra_y, 0
+0x00000000, 0xe0020027, // mov ra_x, 0
+0x40052037, 0x100049e1, // nop; mul24 r1, ra_y, rb_Y_STRIDE_SRC
+0x40011037, 0x100049e0, // nop; mul24 r0, ra_x, rb_X_STRIDE
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c0a7c00, 0x10020127, // add ra_src_cell, ra_src_base, r0
+0x40013037, 0x100049e1, // nop; mul24 r1, ra_x, rb_Y_STRIDE_DST
+0x40051037, 0x100049e0, // nop; mul24 r0, ra_y, rb_X_STRIDE
+0x0c9e7040, 0x10020827, // add r0, r0, r1
+0x0c0e7c00, 0x10020167, // add ra_dst_cell, ra_dst_base, r0
+0x00001200, 0xe0021c67, // mov vw_setup, vpm_setup(16, 1, v32(0,0))
+0x0c100dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re
+0x0c108dc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im
+0x0c101dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c109dc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x0c102dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c10adc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x0c103dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c10bdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x0c104dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c10cdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x0c105dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c10ddc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x0c106dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c10edc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x0c107dc0, 0x10020e27, // add t0s, ra_src_cell, rb_offsets_re+1+i
+0x0c10fdc0, 0x10020f27, // add t1s, ra_src_cell, rb_offsets_im+1+i
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xa00009e7, // ldtmu0
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x009e7000, 0xb00009e7, // ldtmu1
+0x159e7900, 0x10020c27, // mov vpm, r4
+0x88104000, 0xe0021c67, // mov vw_setup, vdw_setup_0(16, 16, dma_h32(0,0))
+0x151a7d80, 0x10021c67, // mov vw_setup, ra_vdw_stride
+0x15167d80, 0x10021ca7, // mov vw_addr, ra_dst_cell
+0x159f2fc0, 0x100009e7, // mov -, vw_wait
+0x0c010dc0, 0x10020027, // add ra_x, ra_x, rb_0x10
+0x009e7000, 0x100009e7, // nop
+0x0d014dc0, 0x100229e7, // sub.setf -, ra_x, rb_NX
+0xfffffde0, 0xf01809e7, // brr.allnz -, r:inner
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x0c048dc0, 0xd0020067, // add ra_y, ra_y, 8
+0x009e7000, 0x100009e7, // nop
+0x0d055dc0, 0x100229e7, // sub.setf -, ra_y, rb_NY
+0xfffffda0, 0xf01809e7, // brr.allnz -, r:outer
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
+0x00000001, 0xe00209a7, // mov interrupt, 1
+0x009e7000, 0x300009e7, // nop; nop; thrend
+0x009e7000, 0x100009e7, // nop
+0x009e7000, 0x100009e7, // nop
diff --git a/src/image.h b/src/image.h
new file mode 100644
index 0000000..b44b71f
--- /dev/null
+++ b/src/image.h
@@ -0,0 +1,268 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __IMAGE_H__
+#define __IMAGE_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <math.h>
+
+// #include <png.h>
+#include <jpeglib.h>
+#include <setjmp.h>
+
+// =============================================================================
+
+template <class Type=float>
+ class MonoImage
+{ public:
+   Type   *Data;        // pointer to image storage
+   int     Size;        // actuall (needed) storage size
+   int     Allocated;   // allocated storage (when 0 => storage is empty or outside of this object)
+
+   int     Width;       // number of columns
+   int     Height;      // number of rows
+
+   MonoImage()
+     { Data=0; Width=0; Height=0; Size=0; Allocated=0; }
+
+   MonoImage(int NewWidth, int NewHeight) { New(NewWidth, NewHeight); }
+
+  ~MonoImage()
+     { if(Allocated) free(Data); }
+
+   void Free(void)
+     { if(Allocated) free(Data);
+       Data=0; Size=0; Allocated=0; }
+
+   int Reallocate(int NewSize)
+     { // printf("PixelImage::Reallocate(%d) ...\n", NewSize);
+       if(Allocated&&(NewSize==Size)) return Size;
+       Data=(Type *)realloc(Data, NewSize*sizeof(Type)); if(Data==0) { Allocated=0; Size=0; return 0; }
+       Allocated=NewSize; return NewSize; }
+
+   int New(int NewWidth, int NewHeight)
+     { // printf("MonoImage::New(%dx%d) ...\n", NewWidth, NewHeight);
+       int NewSize=NewWidth*NewHeight;
+       if(Allocated<NewSize) Reallocate(NewSize);
+       if(Allocated<NewSize) { Width=0; Height=0; Size=0; return 0; }
+       Width=NewWidth; Height=NewHeight; Size=NewSize;
+       // printf(" Size=%d, Allocated=%d\n", Size, Allocated);
+       return Size; }
+
+   template <class NewType>
+    int New(MonoImage<NewType> &Ref)
+     { return New(Ref.Width, Ref.Height); }
+
+   int NewBlank(int NewWidth, int NewHeight)
+      { if(New(NewWidth, NewHeight)<=0) return 0;
+        Blank(0); return Size; }
+
+   int setExternal(Type *ExtImage, int ExtWidth, int ExtHeight)
+     { if(Allocated) { free(Data); Allocated=0; }
+       Data=ExtImage; Width=ExtWidth; Height=ExtHeight;
+       return Size=Width*Height; }
+
+// -----------------------------------------------------------------------------
+
+   bool  isPixel(int X, int Y) const         { return (X>=0) && (X<Width) && (Y>=0) && (Y<=Height); }
+   void setPixel(int X, int Y, Type Value)   { Data[Y*Width+X]=Value; }
+   Type getPixel(int X, int Y) const         { return Data[Y*Width+X]; }
+   Type incPixel(int X, int Y, Type Value=1) { return Data[Y*Width+X]+=Value; }
+
+// -----------------------------------------------------------------------------
+
+   template <class ExtType>
+    int Copy(ExtType *ExtData, int ExtWidth, int ExtHeight, ExtType Scale=1)
+   { if(New(ExtWidth, ExtHeight)<=0) return 0;
+     Type *ImgData = Data;
+     for(int Row=0; Row<Height; Row++)
+     { for(int Col=0; Col<Width; Col++)
+       { (*ImgData++) = Scale*(*ExtData++); }
+     }
+     return Size; }
+
+   template <class ExtType>
+    int Copy(MonoImage<ExtType> &ExtImage, ExtType Scale=1)
+   { return Copy(ExtImage.Data, ExtImage.Width, ExtImage.Height, Scale); }
+
+   template <class ExtType>
+    int Add(ExtType *ExtData, int ExtWidth, int ExtHeight, ExtType Weight=1)
+   { if(Size==0) { if(NewBlank(ExtWidth, ExtHeight)<=0) return 0; }
+     if( (Width!=ExtWidth) || (Height!=ExtHeight) ) return 0;
+     Type *ImgData = Data;
+     for(int Row=0; Row<Height; Row++)
+     { for(int Col=0; Col<Width; Col++)
+       { (*ImgData++) += Weight*(*ExtData++); }
+     }
+     return Size; }
+
+   template <class ExtType>
+    int Add(MonoImage<ExtType> &ExtImage, ExtType Weight=1)
+   { return Add(ExtImage.Data, ExtImage.Width, ExtImage.Height, Weight); }
+
+   template <class ExtType>
+    int CopyBox(ExtType *ExtData, int ExtWidth, int ExtHeight, int FirstCol, int FirstRow, int Cols, int Rows, ExtType Scale=1)
+   { if(New(Cols, Rows)<=0) return 0;
+     Type *ImgData = Data;
+     for(int Row=0; Row<Height; Row++)
+     { int ExtRow = FirstRow+Row;
+       if( (ExtRow<0) || (ExtRow>=ExtHeight) )
+       { for(int Col=0; Col<Width; Col++) (*ImgData++)=0; continue; }
+       ExtType *ExtRowData = ExtData + (ExtRow*ExtWidth);
+       int ExtCol = FirstCol;
+       for( int Col=0; Col<Width; Col++, ExtCol++)
+         { ExtType Data=0;
+           if((ExtCol>=0) && (ExtCol<ExtWidth))
+             Data=ExtRowData[ExtCol];
+           (*ImgData++)=Scale*Data; }
+     }
+     return Size; }
+
+   template <class ExtType>
+    int CopyBox(MonoImage<ExtType> &ExtImage, int FirstCol, int FirstRow, int Cols, int Rows, ExtType Scale=1)
+   { return CopyBox(ExtImage.Data, ExtImage.Width, ExtImage.Height, FirstCol, FirstRow, Cols, Rows, Scale); }
+
+   void Blank(Type Level=0)
+      { if(Data==0) return;
+        Type *Image=Data; int Count=Size; for( ; Count; Count--) (*Image++)=Level; }
+
+// -----------------------------------------------------------------------------
+
+   int WritePGM_8bpp(const char *FileName, Type LogRef=0, Type Scale=1, Type Bias=0) const
+     { FILE *File=fopen(FileName,"wb"); if(File==0) return -1;
+       fprintf(File,"P5\n%d %d 255\n", Width, Height);
+       uint8_t Line[Width];
+       Type *Img = Data;
+       for(int Row=0; Row<Height; Row++)
+       { for(int Col=0; Col<Width; Col++)
+         { Type Pixel=(*Img++);
+           if(LogRef)
+           { if(Pixel) { Pixel=logf((float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
+             else Pixel=0; }
+           else
+           { Pixel = Pixel*Scale + Bias; }
+           if(Pixel<0x00) Pixel=0x00;
+           else if(Pixel>0xFF) Pixel=0xFF;
+           Line[Col]=(uint8_t)Pixel; }
+         if(fwrite(Line, Width, 1, File)!=1) { fclose(File); return -1; }
+       }
+       fclose(File);
+       return Width*Height; }
+/*
+   int WritePNG_8bpp(const char *FileName, Type LogRef=0, Type Scale=1, Type Bias=0) const
+     { FILE *File=fopen(FileName, "wb"); if(File==0) return -1;
+
+       png_structp Struct;
+       png_infop   Info;
+       Struct = png_create_write_struct(PNG_LIBPNG_VER_STRING, 0, 0, 0);
+       if(Struct==0) { fclose(File); return -1; }
+       Info = png_create_info_struct(Struct);
+       if(Info==0) { png_destroy_write_struct(&Struct, (png_infopp)0); fclose(File); return -1; }
+       if(setjmp(png_jmpbuf(Struct))) { png_destroy_write_struct(&Struct, (png_infopp)0); fclose(File); return -1; }
+       png_set_IHDR(Struct, Info, Width, Height,
+                    8, PNG_COLOR_TYPE_GRAY, PNG_INTERLACE_NONE,
+                    PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
+       png_init_io(Struct, File);
+       png_write_info(Struct, Info);
+
+       uint8_t Line[Width];
+       for(int Row=0; Row<Height; Row++)
+       { Type *Img = Data+(Row*Width);
+         for(int Col=0; Col<Width; Col++)
+         { Type Pixel=(*Img++);
+           if(LogRef)
+           { if(Pixel) { Pixel=logf((float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
+             else Pixel=0; }
+           else
+           { Pixel = Pixel*Scale + Bias; }
+           if(Pixel<0x00) Pixel=0x00;
+           else if(Pixel>0xFF) Pixel=0xFF;
+           Line[Col]=(uint8_t)Pixel; }
+         png_write_row(Struct, Line);
+       }
+
+       png_write_end(Struct, Info);
+       png_destroy_write_struct(&Struct, (png_infopp)0);
+       fclose(File);
+       return Width*Height; }
+*/
+
+   int WriteJPG_8bpp(int Fd, int Quality=80, Type LogRef=0, Type Scale=1, Type Bias=0) const
+     { FILE *File=fdopen(Fd, "wb"); if(File==0) return -1;
+       int Size=WriteJPG_8bpp(File, Quality, LogRef, Scale, Bias);
+       fclose(File); return Size; }
+
+   int WriteJPG_8bpp(const char *FileName, int Quality=80, Type LogRef=0, Type Scale=1, Type Bias=0) const
+     { FILE *File=fopen(FileName, "wb"); if(File==0) return -1;
+       int Size=WriteJPG_8bpp(File, Quality, LogRef, Scale, Bias);
+       fclose(File); return Size; }
+
+   int WriteJPG_8bpp(FILE *File, int Quality=80, Type LogRef=0, Type Scale=1, Type Bias=0) const
+     {
+       struct jpeg_compress_struct JpegCompress;
+       struct jpeg_error_mgr       JpegErrorManager;
+              jmp_buf              JpegErrorJmp;
+
+       JpegCompress.err = jpeg_std_error(&JpegErrorManager);
+       jpeg_create_compress(&JpegCompress);
+       JpegCompress.image_width  = Width;
+       JpegCompress.image_height = Height;
+       JpegCompress.input_components = 1;
+       JpegCompress.in_color_space = JCS_GRAYSCALE;
+       jpeg_set_defaults(&JpegCompress);
+       jpeg_set_quality(&JpegCompress, Quality, TRUE);
+       jpeg_stdio_dest(&JpegCompress, File);
+       jpeg_start_compress(&JpegCompress, TRUE);
+
+       if(setjmp(JpegErrorJmp))
+       { jpeg_abort_compress(&JpegCompress);
+         jpeg_destroy_compress(&JpegCompress);
+         return -1; }
+
+       uint8_t Line[Width];
+       for(int Row=0; Row<Height; Row++)     // loop over image lines
+       { Type *Img = Data+(Row*Width);
+         for(int Col=0; Col<Width; Col++)    // loop over pixels in a line
+         { Type Pixel=(*Img++);
+           if(LogRef)                        // logarythimc pixel rescale
+           { if(Pixel) { Pixel=logf((float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
+             else Pixel=0; }                 //
+           else                              // linear pixel rescale
+           { Pixel = Pixel*Scale + Bias; }
+           if(Pixel<0x00) Pixel=0x00;        // limit to 8 bits
+           else if(Pixel>0xFF) Pixel=0xFF;
+           Line[Col]=(uint8_t)Pixel; }
+         uint8_t *RowPtr=Line;
+         jpeg_write_scanlines(&JpegCompress, &RowPtr, 1);
+       }
+
+       jpeg_finish_compress(&JpegCompress);
+       jpeg_destroy_compress(&JpegCompress);
+       return Width*Height; }
+
+} ;
+
+// =============================================================================
+
+#endif // of __IMAGE_H__
+
diff --git a/src/jpeg.h b/src/jpeg.h
new file mode 100644
index 0000000..8891fc6
--- /dev/null
+++ b/src/jpeg.h
@@ -0,0 +1,128 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <setjmp.h>
+#include <jpeglib.h>
+
+class JPEG
+{ private:
+   struct jpeg_compress_struct Compress;           // structures for jpeglib
+   struct jpeg_error_mgr       ErrorManager;
+   struct jpeg_destination_mgr DestinationManager;
+          jmp_buf              ErrorJmp;
+
+  public:
+   uint8_t *Data;                                 // compressed JPEG storage
+   size_t   Size;                                 // actuall JPEG size
+   uint32_t Valid;
+
+  private:
+   size_t Allocated;                             // allocated staorage
+   static const size_t AllocUnit = 8192;         // storage will be allocated in blocks
+
+  public:
+   int Quality;                                  // JPEG quality: 0..100
+
+  private:
+   size_t Reallocate(size_t NewSize)            // reallocate JPEG storage to a new (bigger) size
+     { // printf("Reallocate(%d)\n", NewSize);
+       Data=(uint8_t *)realloc(Data, NewSize);
+       if(Data==0) { Allocated=0; Size=0; return 0; } // return zero if not possible to reallocate
+       return Allocated=NewSize; }
+
+   static void BufferInit_(jpeg_compress_struct *Compress)
+     { JPEG *Client = (JPEG *)Compress->client_data; Client->BufferInit(); }
+
+          void BufferInit(void)
+     { if(Allocated<=0) Reallocate(AllocUnit);
+       DestinationManager.next_output_byte    = Data;
+       DestinationManager.free_in_buffer      = Allocated;
+       Size=0; }
+
+   static boolean BufferFull_(jpeg_compress_struct *Compress)
+     { JPEG *Client = (JPEG *)Compress->client_data; return Client->BufferFull(); }
+
+          boolean BufferFull(void)
+     { Size=Allocated;
+       if(Reallocate(Allocated+AllocUnit)<=0)
+       { longjmp(ErrorJmp, -1); return FALSE; }
+       DestinationManager.next_output_byte    = Data+Size;
+       DestinationManager.free_in_buffer      = Allocated-Size;
+       return TRUE; }
+
+   static void BufferTerminate_(jpeg_compress_struct *Compress)
+     { JPEG *Client = (JPEG *)Compress->client_data; Client->BufferTerminate(); }
+
+          void BufferTerminate(void)
+     { Size=Allocated-DestinationManager.free_in_buffer; }
+
+   int Compress_(uint8_t *Image, int Width, int Height,                      // compress Image
+                 J_COLOR_SPACE ColorSpace, int BytesPerPixel)
+     { Compress.image_width      = Width;
+       Compress.image_height     = Height;
+       Compress.input_components = BytesPerPixel;
+       Compress.in_color_space   = ColorSpace;
+       jpeg_set_defaults(&Compress);
+       jpeg_set_quality(&Compress, Quality, TRUE);
+
+       jpeg_start_compress(&Compress, TRUE);
+
+       int Row=0;
+       if(setjmp(ErrorJmp)) { jpeg_abort_compress(&Compress); Size=0; return -1; }
+
+       for(Row=0; Row<Height; Row++, Image+=(Width*BytesPerPixel))
+       { jpeg_write_scanlines(&Compress, &Image, 1); }
+
+       jpeg_finish_compress(&Compress);
+       return Size; }
+
+  public:
+   JPEG()
+     { Data=0; Allocated=0; Size=0;
+       Quality=80;
+       Compress.err = jpeg_std_error(&ErrorManager);
+       jpeg_create_compress(&Compress);
+       Compress.client_data = this;
+       Compress.dest = &DestinationManager;
+       DestinationManager.init_destination    = BufferInit_;        // call-backs
+       DestinationManager.empty_output_buffer = BufferFull_;
+       DestinationManager.term_destination    = BufferTerminate_;
+     }
+
+  ~JPEG()
+     { jpeg_destroy_compress(&Compress);
+       if(Data) free(Data); }
+
+   int Compress_MONO8(uint8_t *Image, int Width, int Height)        // compress a grey-scale image
+     { return Compress_(Image, Width, Height, JCS_GRAYSCALE, 1); }
+
+   int Compress_RGB24(uint8_t *Image, int Width, int Height)        // compress an RGB image
+     { return Compress_(Image, Width, Height, JCS_RGB, 3); }
+
+   int Write(char *FileName)                                        // write compressed JPEG image to a file
+     { if(Data==0) return 0;
+       FILE *File = fopen(FileName, "wb"); if(File==0) return 0;
+       size_t Written=fwrite(Data, 1, Size, File);
+       fclose(File); return Written; }
+
+} ;
diff --git a/src/mailbox.c b/src/mailbox.c
new file mode 100644
index 0000000..2958d33
--- /dev/null
+++ b/src/mailbox.c
@@ -0,0 +1,258 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <assert.h>
+#include <stdint.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include "mailbox.h"
+
+#define PAGE_SIZE (4*1024)
+
+void *mapmem(unsigned base, unsigned size)
+{
+   int mem_fd;
+   unsigned offset = base % PAGE_SIZE;
+   base = base - offset;
+   /* open /dev/mem */
+   if ((mem_fd = open("/dev/mem", O_RDWR|O_SYNC) ) < 0) {
+      printf("can't open /dev/mem\nThis program should be run as root. Try prefixing command with: sudo\n");
+      exit (-1);
+   }
+   void *mem = mmap(
+      0,
+      size,
+      PROT_READ|PROT_WRITE,
+      MAP_SHARED/*|MAP_FIXED*/,
+      mem_fd,
+      base);
+#ifdef DEBUG
+   printf("base=0x%x, mem=%p\n", base, mem);
+#endif
+   if (mem == MAP_FAILED) {
+      printf("mmap error %d\n", (int)mem);
+      exit (-1);
+   }
+   close(mem_fd);
+   return (char *)mem + offset;
+}
+
+void unmapmem(void *addr, unsigned size)
+{
+   int s = munmap(addr, size);
+   if (s != 0) {
+      printf("munmap error %d\n", s);
+      exit (-1);
+   }
+}
+
+/*
+ * use ioctl to send mbox property message
+ */
+
+static int mbox_property(int file_desc, void *buf)
+{
+   int ret_val = ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
+
+   if (ret_val < 0) {
+      printf("ioctl_set_msg failed:%d\n", ret_val);
+   }
+
+#ifdef DEBUG
+   unsigned *p = buf; int i; unsigned size = *(unsigned *)buf;
+   for (i=0; i<size/4; i++)
+      printf("%04x: 0x%08x\n", i*sizeof *p, p[i]);
+#endif
+   return ret_val;
+}
+
+unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000c; // (the tag id)
+   p[i++] = 12; // (size of the buffer)
+   p[i++] = 12; // (size of the data)
+   p[i++] = size; // (num bytes? or pages?)
+   p[i++] = align; // (alignment)
+   p[i++] = flags; // (MEM_FLAG_L1_NONALLOCATING)
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_free(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000f; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_lock(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000d; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_unlock(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000e; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x30010; // (the tag id)
+   p[i++] = 28; // (size of the buffer)
+   p[i++] = 28; // (size of the data)
+   p[i++] = code;
+   p[i++] = r0;
+   p[i++] = r1;
+   p[i++] = r2;
+   p[i++] = r3;
+   p[i++] = r4;
+   p[i++] = r5;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned qpu_enable(int file_desc, unsigned enable)
+{
+   int i=0;
+   unsigned p[32];
+
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x30012; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = enable;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout) {
+   int i=0;
+   unsigned p[32];
+
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x30011; // (the tag id)
+   p[i++] = 16; // (size of the buffer)
+   p[i++] = 16; // (size of the data)
+   p[i++] = num_qpus;
+   p[i++] = control;
+   p[i++] = noflush;
+   p[i++] = timeout; // ms
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+int mbox_open() {
+   int file_desc;
+
+   // open a char device file used for communicating with kernel mbox driver
+   file_desc = open(DEVICE_FILE_NAME, 0);
+   if (file_desc < 0) {
+      printf("Can't open device file: %s\n", DEVICE_FILE_NAME);
+      printf("Try creating a device file with: sudo mknod %s c %d 0\n", DEVICE_FILE_NAME, MAJOR_NUM);
+      exit(-1);
+   }
+   return file_desc;
+}
+
+void mbox_close(int file_desc) {
+  close(file_desc);
+}
diff --git a/src/mailbox.h b/src/mailbox.h
new file mode 100644
index 0000000..370d115
--- /dev/null
+++ b/src/mailbox.h
@@ -0,0 +1,47 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <linux/ioctl.h>
+
+#define MAJOR_NUM 100
+#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
+#define DEVICE_FILE_NAME "/dev/vcio"
+
+int mbox_open();
+void mbox_close(int file_desc);
+
+unsigned get_version(int file_desc);
+unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags);
+unsigned mem_free(int file_desc, unsigned handle);
+unsigned mem_lock(int file_desc, unsigned handle);
+unsigned mem_unlock(int file_desc, unsigned handle);
+void *mapmem(unsigned base, unsigned size);
+void unmapmem(void *addr, unsigned size);
+
+unsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);
+unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);
+unsigned qpu_enable(int file_desc, unsigned enable);
diff --git a/src/ogn-rf.cc b/src/ogn-rf.cc
new file mode 100644
index 0000000..c9baead
--- /dev/null
+++ b/src/ogn-rf.cc
@@ -0,0 +1,1068 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <math.h>
+
+#include <libconfig.h>
+
+#include <algorithm>
+
+#include "thread.h"     // multi-thread stuff
+#include "fft.h"        // Fast Fourier Transform
+#include "rtlsdr.h"     // SDR radio
+
+#define QUOTE(name) #name
+#define STR(macro) QUOTE(macro)
+#ifndef VERSION
+#define VERSION 0.0.0
+#endif
+
+#include "jpeg.h"
+#include "socket.h"
+#include "sysmon.h"
+
+#include "pulsefilter.h"
+#include "tonefilter.h"
+
+// ==================================================================================================
+
+template <class Float> // scale floating-point data to 8-bit gray scale image
+ void LogImage(SampleBuffer<uint8_t> &Image, SampleBuffer<Float> &Data, Float LogRef=0, Float Scale=1, Float Bias=0)
+{ Image.Allocate(Data);
+  int Pixels=Data.Full;
+  for(int Idx=0; Idx<Pixels; Idx++)
+  { Float Pixel=Data.Data[Idx];
+    if(LogRef)
+    { if(Pixel) { Pixel=logf((Float)Pixel/LogRef); Pixel = Pixel*Scale + Bias; }
+           else { Pixel=0; } }
+    else
+    { Pixel = Pixel*Scale + Bias; }
+    if(Pixel<0x00) Pixel=0x00;
+    else if(Pixel>0xFF) Pixel=0xFF;
+    Image.Data[Idx]=(uint8_t)Pixel;
+  }
+  Image.Full=Pixels;
+}
+
+// ==================================================================================================
+
+class RF_Acq                                    // acquire wideband (1MHz) RF data thus both OGN frequencies at same time
+{ public:
+   int    SampleRate;                           // [Hz] sampling rate
+
+   int    OGN_GainMode;                         // 0=Auto, 1=Manual, 2=Linearity, 3=Sensitivity
+   int    OGN_Gain;                             // [0.1dB] Rx gain for OGN reception
+   int    OGN_CenterFreq;                       // [Hz] center acquisition frequency: can be 868.3+/-0.2 MHz
+   double OGN_StartTime;                        // [sec] when to start acquisition on the center frequency
+   int    OGN_SamplesPerRead;                   // [samples] should correspond to about 800 ms of data and be a multiple of 256
+                                                // the goal is to listen on center frequency from 0.4 to 1.2 sec
+   int    OGN_SaveRawData;
+   const static uint32_t OGN_RawDataSync = 0x254F7D01;
+
+                                                // for frequency hopping
+   // int              FreqBase;                   // [Hz] for Australia: 917.0MHz, for USA: 902.2MHz
+   static const int FreqHopChannelWidth = 400000;  // [Hz] 0.4MHz per channel
+   int              OGN_FreqHopChannels;           // [number] Australia: 24, USA: 65
+
+   int  DeviceIndex;                            // rtl-sdr device index
+   char DeviceSerial[64];                       // serial number of the rtl-sdr device to be selected
+   int  OffsetTuning;                           // [bool] this option might be good for E4000 tuner
+   int  BiasTee;                                // [bool] T-bias for external LNA power
+   int  FreqCorr;                               // [ppm] frequency correction applied to the Rx chip
+   RTLSDR SDR;                                  // SDR receiver (DVB-T stick)
+   ReuseObjectQueue< SampleBuffer<uint8_t> > OutQueue; // OGN sample batches are sent there
+
+   Thread Thr;                                  // acquisition thread
+   volatile int StopReq;                        // request to stop the acquisition thread
+
+   PulseFilter PulseFilt;
+
+   static const int GSM_GainMode = 1;           // Manual gain mode for GSM
+   int GSM_Gain;                                // [0.1dB] Rx gain for GSM frequency calibration
+   int GSM_CenterFreq;                          // [Hz] should be selected to cover at lease one broadcast channel in the area
+   int GSM_Scan;                                // [bool] scan around the whole GSM band
+   int GSM_SamplesPerRead;                      // [samples] should cover one or more frequency correction bursts (100 ms should be enough ?)
+   volatile float GSM_FreqCorr;                 // [ppm] frequency correction measured by the GSM frequency calibration
+   static const int GSM_LowEdge = 925100000;    // [Hz] E-GSM-900 band, excluding the guards of 100kHz
+   static const int GSM_UppEdge = 959900000;    // [Hz]
+   static const int GSM_ScanStep =   800000;    // [Hz]
+   ReuseObjectQueue< SampleBuffer<uint8_t> > GSM_OutQueue; // GSM sample batches are sent there
+
+   MessageQueue<Socket *>  RawDataQueue;        // sockets send to this queue should be written with a most recent raw data
+
+  public:
+   RF_Acq() { Config_Defaults();
+              GSM_FreqCorr=0;
+              // PulseBox.Preset(PulseBoxSize);
+              StopReq=0; Thr.setExec(ThreadExec); }
+
+  ~RF_Acq() { }
+
+  void Config_Defaults(void)
+  { SampleRate=1000000;
+    OGN_CenterFreq=868300000;
+    OGN_StartTime=0.375; OGN_SamplesPerRead=(850*SampleRate)/1000;
+    OGN_GainMode=1; OGN_Gain=600;
+    OGN_FreqHopChannels=0;
+    OGN_SaveRawData=0;
+    PulseFilt.Threshold=0;
+    DeviceIndex=0; DeviceSerial[0]=0;
+    OffsetTuning=0; FreqCorr=0; BiasTee=0;
+    GSM_CenterFreq=GSM_LowEdge+GSM_ScanStep/2; GSM_Scan=1; GSM_SamplesPerRead=(250*SampleRate)/1000; GSM_Gain=200; }
+
+  int config_lookup_float_or_int(config_t *Config, const char *Path, double *Value)
+  { int Ret = config_lookup_float(Config, Path, Value); if(Ret==CONFIG_TRUE) return Ret;
+    int IntValue; Ret = config_lookup_int(Config, Path, &IntValue); if(Ret==CONFIG_TRUE) { (*Value) = IntValue; return Ret; }
+    return Ret; }
+
+  int Config(config_t *Config)
+  { double Corr=0.0;
+    config_lookup_float_or_int(Config,   "RF.FreqCorr", &Corr); FreqCorr = (int)floor(Corr+0.5);
+    config_lookup_int(Config,   "RF.Device",         &DeviceIndex);
+    const char *Serial = 0;
+    config_lookup_string(Config,"RF.DeviceSerial",   &Serial);
+    if(Serial) { strncpy(DeviceSerial, Serial, 64); DeviceSerial[63]=0; }
+    config_lookup_int(Config,   "RF.OfsTune",        &OffsetTuning);
+    config_lookup_int(Config,   "RF.BiasTee",        &BiasTee);
+    config_lookup_int(Config,   "RF.OGN.GainMode",   &OGN_GainMode);
+
+    config_lookup_int(Config,   "RF.OGN.SaveRawData",   &OGN_SaveRawData);
+
+    SampleRate=1000000;
+    if(config_lookup_int(Config, "RF.OGN.SampleRate", &SampleRate)!=CONFIG_TRUE)
+    { double Rate;
+      if(config_lookup_float(Config, "RF.OGN.SampleRate", &Rate)==CONFIG_TRUE) SampleRate=(int)floor(1e6*Rate+0.5);
+      else if(config_lookup_int(Config, "RF.SampleRate", &SampleRate)!=CONFIG_TRUE)
+      { if(config_lookup_float(Config, "RF.SampleRate", &Rate)==CONFIG_TRUE) SampleRate=(int)floor(1e6*Rate+0.5); }
+    }
+
+    double InpGain= 60.0; config_lookup_float_or_int(Config, "RF.OGN.Gain",         &InpGain); OGN_Gain=(int)floor(InpGain*10+0.5);
+    double Freq=868.3;    config_lookup_float_or_int(Config, "RF.OGN.CenterFreq",   &Freq);    OGN_CenterFreq=(int)floor(Freq*1e6+0.5);
+           InpGain= 20.0; config_lookup_float_or_int(Config, "RF.GSM.Gain",         &InpGain); GSM_Gain=(int)floor(InpGain*10+0.5);
+           Freq=958.4;    config_lookup_float_or_int(Config, "RF.GSM.CenterFreq",   &Freq);    GSM_CenterFreq=(int)floor(Freq*1e6+0.5); GSM_Scan=0;
+
+    OGN_FreqHopChannels=0;
+    config_lookup_int(Config, "RF.OGN.FreqHopChannels",  &OGN_FreqHopChannels);
+
+    PulseFilt.Threshold=0;
+    config_lookup_int(Config, "RF.PulseFilter.Threshold",  &PulseFilt.Threshold);
+
+    config_lookup_float(Config, "RF.OGN.StartTime", &OGN_StartTime);
+    double SensTime=0.850;
+    config_lookup_float(Config, "RF.OGN.SensTime",  &SensTime);
+    OGN_SamplesPerRead=(int)floor(SensTime*SampleRate+0.5);
+           SensTime=0.250;
+    config_lookup_float(Config, "RF.GSM.SensTime",  &SensTime);
+    GSM_SamplesPerRead=(int)floor(SensTime*SampleRate+0.5);
+
+    return 0; }
+
+   int QueueSize(void) { return OutQueue.Size(); }
+
+   int Start(void) { StopReq=0; return Thr.Create(this); }
+   int Stop(void)  { StopReq=1; return Thr.Join(); }
+
+   static void *ThreadExec(void *Context)
+   { RF_Acq *This = (RF_Acq *)Context; return This->Exec(); }
+
+   void *Exec(void)
+   { // printf("RF_Acq.Exec() ... Start\n");
+     char Header[256];
+     int Priority = Thr.getMaxPriority(); Thr.setPriority(Priority);
+     int CurrCenterFreq = OGN_CenterFreq;
+     while(!StopReq)
+     { if(SDR.isOpen())                                                    // if device is already open
+       { double Now  = SDR.getTime();
+         int    IntTimeNow = (int)floor(Now); int ReadGSM = (IntTimeNow%20) == 0; // do the GSM calibration every 20 seconds
+
+         int NextCenterFreq = OGN_CenterFreq;
+         if(OGN_FreqHopChannels)
+         { int Channel = FreqHopChannel1(IntTimeNow+1);
+           NextCenterFreq += FreqHopChannelWidth*Channel; }
+
+         double FracTimeNow = Now-IntTimeNow;
+         double WaitTime = OGN_StartTime-FracTimeNow; if(WaitTime<0) WaitTime+=1.0;
+         int SamplesToRead=OGN_SamplesPerRead;
+         if( ReadGSM || (QueueSize()>1) ) SamplesToRead/=2; // when GSM calibration or data is not being processed fast enough we only read half-time
+         if(WaitTime<0.200)
+         { usleep((int)floor(1e6*WaitTime+0.5));                              // wait right before the time slot starts
+           SampleBuffer<uint8_t> *Buffer = OutQueue.New();                    // get the next buffer to fill with raw I/Q data
+           SDR.ResetBuffer();                                                 // needed before every Read()
+           int Read=SDR.Read(*Buffer, SamplesToRead);                         // read the time slot raw RF data
+           Buffer->Freq += CurrCenterFreq * (1e-6*GSM_FreqCorr);              // correct the frequency (sign ?)
+           if(OGN_SaveRawData>0)
+           { time_t Time=(time_t)floor(Buffer->Time);
+             struct tm *TM = gmtime(&Time);
+             char FileName[32]; sprintf(FileName, "OGNraw_%04d.%02d.%02d.u8", 1900+TM->tm_year, TM->tm_mon+1, TM->tm_mday);
+             FILE *File=fopen(FileName, "ab");
+             if(File)
+             { SerializeWriteSync(File, OGN_RawDataSync);
+               Buffer->Serialize(File);
+               fclose(File);
+               OGN_SaveRawData--; }
+           }
+           PulseFilt.Process(*Buffer);
+           if(QueueSize()>1) printf("RF_Acq.Exec() ... Half time slot\n");
+           // printf("RF_Acq.Exec() ... SDR.Read() => %d, Time=%16.3f, Freq=%6.1fMHz\n", Read, Buffer->Time, 1e-6*Buffer->Freq);
+           if(Read>0) // RF data Read() successful
+           { while(RawDataQueue.Size())                                       // when a raw data for this slot was requested
+             { Socket *Client; RawDataQueue.Pop(Client);
+               sprintf(Header, "HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nContent-Type: audio/basic\r\nContent-Disposition: attachment; filename=\"time-slot-rf_%14.3f.u8\"\r\n\r\n", Buffer->Time);
+               Client->Send(Header);
+               Client->Send(Buffer->Data, Buffer->Full);
+               Client->SendShutdown(); Client->Close(); delete Client; }
+             if(OutQueue.Size()<4) { OutQueue.Push(Buffer); }
+                              else { OutQueue.Recycle(Buffer); printf("RF_Acq.Exec() ... Dropped a slot\n"); }
+           } else     // RF data Read() failed
+           { SDR.Close(); printf("RF_Acq.Exec() ... SDR.Read() failed => SDR.Close()\n"); continue; }
+           if(ReadGSM) // if we are to read GSM in the second half-slot
+           { SDR.setCenterFreq(GSM_CenterFreq);      // setup for the GSM reception
+             SDR.setTunerGainMode(GSM_GainMode);
+             SDR.setTunerGain(GSM_Gain);
+             GSM_FreqCorr-=(FreqCorr-SDR.getFreqCorrection());
+             SDR.setFreqCorrection(FreqCorr);
+             SampleBuffer<uint8_t> *Buffer = GSM_OutQueue.New();
+             SDR.ResetBuffer();
+             int Read=SDR.Read(*Buffer, GSM_SamplesPerRead);
+             // printf("RF_Acq.Exec() ...(GSM) SDR.Read() => %d, Time=%16.3f, Freq=%6.1fMHz\n", Read, Buffer->Time, 1e-6*Buffer->Freq);
+             if(Read>0)
+             { if(GSM_OutQueue.Size()<3) GSM_OutQueue.Push(Buffer);
+                                  else { GSM_OutQueue.Recycle(Buffer); printf("RF_Acq.Exec() ... Dropped a GSM batch\n"); }
+             }
+             SDR.setTunerGainMode(OGN_GainMode);
+             SDR.setTunerGain(OGN_Gain);                // back to OGN reception setup
+             if(GSM_Scan)
+             { GSM_CenterFreq+=GSM_ScanStep;
+               if(GSM_CenterFreq>=GSM_UppEdge) GSM_CenterFreq=GSM_LowEdge+GSM_ScanStep/2;
+             }
+           }
+           if(ReadGSM | OGN_FreqHopChannels)
+           { SDR.setCenterFreq(NextCenterFreq); CurrCenterFreq=NextCenterFreq; }
+         }
+         else usleep(100000);
+       }
+       else                                                                // if not open yet or was closed due to an error
+       { int Index=(-1);
+         if(DeviceSerial[0]) Index=SDR.getDeviceIndexBySerial(DeviceSerial);
+         if(Index<0) Index=DeviceIndex;
+         if(SDR.Open(Index, OGN_CenterFreq, SampleRate)<0)                    // try to open it
+         { printf("RF_Acq.Exec() ... SDR.Open(%d, , ) fails, retry after 1 sec\n", Index); usleep(1000000); }
+         else
+         { SDR.setOffsetTuning(OffsetTuning);
+           SDR.setBiasTee(BiasTee);
+           SDR.setTunerGainMode(OGN_GainMode);
+           SDR.setTunerGain(OGN_Gain); }
+           SDR.setFreqCorrection(FreqCorr);
+       }
+     }
+
+     SDR.Close();
+     // printf("RF_Acq.Exec() ... Stop\n");
+     return  0; }
+
+   uint32_t FreqHopHash(uint32_t Time)
+   { Time  = (Time<<15) + (~Time);
+     Time ^= Time>>12;
+     Time += Time<<2;
+     Time ^= Time>>4;
+     Time *= 2057;
+     return Time ^ (Time>>16); }
+
+   uint16_t FreqHopChannel1(uint32_t Time)
+   { return FreqHopHash((Time<<1)  )%OGN_FreqHopChannels; }
+
+   uint16_t FreqHopChannel2(uint32_t Time)
+   { return FreqHopHash((Time<<1)+1)%OGN_FreqHopChannels; }
+
+} ;
+
+// ==================================================================================================
+
+template <class Float>
+ class Inp_Filter
+{ public:
+
+   Thread Thr;                                      // processing thread
+   volatile int StopReq;
+   RF_Acq *RF;
+
+   int              Enable;
+   ToneFilter<Float> ToneFilt;
+
+   ReuseObjectQueue< SampleBuffer< std::complex<Float> > > OutQueue;
+
+  public:
+
+   Inp_Filter(RF_Acq *RF)
+   { this->RF=RF; Config_Defaults(); Preset(); }
+
+   void Config_Defaults(void)
+   { Enable  = 0; ToneFilt.FFTsize = 32768; ToneFilt.Threshold=32; }
+
+   int Config(config_t *Config)
+   { config_lookup_int(Config,   "RF.ToneFilter.Enable",    &Enable);
+     config_lookup_int(Config,   "RF.ToneFilter.FFTsize",   &ToneFilt.FFTsize);
+     config_lookup_float(Config, "RF.ToneFilter.Threshold", &ToneFilt.Threshold);
+     return 0; }
+
+   int Preset(void) { return ToneFilt.Preset(); }
+
+   int QueueSize(void) { return OutQueue.Size(); }
+   void Start(void)
+   { StopReq=0; Thr.setExec(ThreadExec); Thr.Create(this); }
+
+  ~Inp_Filter()
+   { Thr.Cancel(); }
+
+   double getCPU(void) // get CPU time for this thread
+   {
+#if !defined(__MACH__)
+       struct timespec now; clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now); return now.tv_sec + 1e-9*now.tv_nsec;
+#else
+       return 0;
+#endif
+   }
+
+   static void *ThreadExec(void *Context)
+   { Inp_Filter<Float> *This = (Inp_Filter<Float> *)Context; return This->Exec(); }
+
+   void *Exec(void)
+   { // printf("Inp_Filter.Exec() ... Start\n");
+     while(!StopReq)
+     { if(!Enable) { sleep(1); continue; }
+       double ExecTime=getCPU();
+       SampleBuffer<uint8_t> *InpBuffer = RF->OutQueue.Pop();   // here we wait for a new data batch
+       // printf("Inp_Filter.Exec() ... Input(%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
+       SampleBuffer< std::complex<Float> > *OutBuffer = OutQueue.New();
+       ToneFilt.Process(OutBuffer, InpBuffer);
+       RF->OutQueue.Recycle(InpBuffer);                         // let the input buffer go free
+       // printf("Inp_Filter.Exec() ... Output(%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*OutBuffer->Freq, OutBuffer->Time, OutBuffer->Full/2);
+       if(OutQueue.Size()<4) { OutQueue.Push(OutBuffer); }
+                        else { OutQueue.Recycle(OutBuffer); printf("Inp_Filter.Exec() ... Dropped a slot\n"); }
+       ExecTime=getCPU()-ExecTime; // printf("Inp_FFT.Exec() ... %5.3fsec\n", ExecTime);
+     }
+     // printf("Inp_FFT.Exec() ... Stop\n");
+     return 0; }
+
+   // classical sliding box filter - calc. the sum within box of 2*Radius+1
+   static void BoxSum(Float *Output, Float *Input, int Size, int Radius)
+   { int BoxSize=2*Radius+1;
+     Float Sum=0; int InpIdx=0; int OutIdx=0;
+     for( ; InpIdx<Radius; InpIdx++)
+     { Sum+=Input[InpIdx]; }
+     for( ; InpIdx<BoxSize; InpIdx++)
+     { Sum+=Input[InpIdx]; Output[OutIdx++]=Sum; }
+     for( ; InpIdx<Size; InpIdx++)
+     { Sum+=Input[InpIdx]-Input[InpIdx-BoxSize]; Output[OutIdx++]=Sum; }
+     for( ; OutIdx<Size; )
+     { Sum-=Input[InpIdx-BoxSize]; Output[OutIdx++]=Sum; }
+   }
+
+
+} ;
+
+// ==================================================================================================
+
+template <class Float>
+ class Inp_FFT                                      // FFT of the RF data
+{ public:
+
+   Thread Thr;                                      // processing thread
+   volatile int StopReq;
+   RF_Acq *RF;
+   Inp_Filter<Float> *Filter;
+
+   int              FFTsize;
+#ifdef USE_RPI_GPU_FFT
+   RPI_GPU_FFT      FFT;
+#else
+   DFT1d<Float>     FFT;
+#endif
+   Float           *Window;
+
+   SampleBuffer< std::complex<Float> > OutBuffer;
+   int  OutPipe;
+   char OutPipeName[32];
+   const static uint32_t OutPipeSync = 0x254F7D00 + sizeof(Float);
+
+  public:
+   Inp_FFT(RF_Acq *RF, Inp_Filter<Float> *Filter=0)
+   { Window=0; this->RF=RF; this->Filter=Filter; Preset(); OutPipe=(-1); Config_Defaults(); }
+
+   void Config_Defaults(void)
+   { strcpy(OutPipeName, "ogn-rf.fifo"); }
+
+   int Config(config_t *Config)
+   { const char *PipeName = "ogn-rf.fifo";
+     config_lookup_string(Config, "RF.PipeName",   &PipeName);
+     strcpy(OutPipeName, PipeName);
+     return 0; }
+
+  int Preset(void) { return Preset(RF->SampleRate); }
+   int Preset(int SampleRate)
+   { FFTsize=(8*SampleRate)/15625;
+     FFT.PresetForward(FFTsize);
+     Window=(Float *)realloc(Window, FFTsize*sizeof(Float));
+     FFT.SetSineWindow(Window, FFTsize, (Float)(1.0/sqrt(FFTsize)) );
+     return 1; }
+
+  int WriteToPipe(void) // write OutBuffer to the output pipe
+  { if(OutPipe<0)
+    { OutPipe=open(OutPipeName, O_WRONLY);
+      if(OutPipe<0)
+      { printf("Inp_FFT.Exec() ... Cannot open %s\n", OutPipeName);
+        // here we could try to create the missing pipe
+        return -1; } }
+    int Len=SerializeWriteSync(OutPipe, OutPipeSync);
+    if(Len>=0) { Len=SerializeWriteName(OutPipe, "FreqCorr"); }
+    if(Len>=0) { Len=SerializeWriteData(OutPipe, (void *)&(RF->FreqCorr),     sizeof(int)   ); }
+    if(Len>=0) { Len=SerializeWriteData(OutPipe, (void *)&(RF->GSM_FreqCorr), sizeof(float) ); }
+    if(Len>=0) { Len=SerializeWriteSync(OutPipe, OutPipeSync); }
+    if(Len>=0) { Len=SerializeWriteName(OutPipe, "Spectra"); }
+    if(Len>=0) { Len=OutBuffer.Serialize(OutPipe); }
+    if(Len<0) { printf("Inp_FFT.Exec() ... Error while writing to %s\n", OutPipeName); close(OutPipe); OutPipe=(-1); return -1; }
+    return 0; }
+
+   void Start(void)
+   { StopReq=0; Thr.setExec(ThreadExec); Thr.Create(this); }
+
+  ~Inp_FFT()
+   { Thr.Cancel();
+     if(Window) free(Window); }
+
+   double getCPU(void) // get CPU time for this thread
+   {
+#if !defined(__MACH__)
+       struct timespec now; clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now); return now.tv_sec + 1e-9*now.tv_nsec;
+#else
+       return 0;
+#endif
+   }
+
+   static void *ThreadExec(void *Context)
+   { Inp_FFT *This = (Inp_FFT *)Context; return This->Exec(); }
+
+   void *Exec(void)
+   { // printf("Inp_FFT.Exec() ... Start\n");
+     while(!StopReq)
+     { double ExecTime=getCPU();
+#ifndef USE_RPI_GPU_FFT
+       if(Filter && Filter->Enable)
+       { SampleBuffer< std::complex<Float> > *InpBuffer = Filter->OutQueue.Pop();
+         // printf("Inp_FFT.Exec() ... (%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
+         SlidingFFT(OutBuffer, *InpBuffer, FFT, Window);  // Process input samples, produce FFT spectra
+         Filter->OutQueue.Recycle(InpBuffer);
+       }
+       else
+#endif
+       { SampleBuffer<uint8_t> *InpBuffer = RF->OutQueue.Pop(); // here we wait for a new data batch
+         // printf("Inp_FFT.Exec() ... (%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
+         SlidingFFT(OutBuffer, *InpBuffer, FFT, Window);  // Process input samples, produce FFT spectra
+         RF->OutQueue.Recycle(InpBuffer);
+       }
+       WriteToPipe(); // here we send the FFT spectra in OutBuffer to the demodulator
+       ExecTime=getCPU()-ExecTime; // printf("Inp_FFT.Exec() ... %5.3fsec\n", ExecTime);
+     }
+     // printf("Inp_FFT.Exec() ... Stop\n");
+     if(OutPipe>=0) { close(OutPipe); OutPipe=(-1); }
+     return 0; }
+
+} ;
+
+// ==================================================================================================
+
+template <class Float>
+ class GSM_FFT                                      // FFT of the GSM RF data
+{ public:
+
+   Thread Thr;                                      // processing thread
+   volatile int StopReq;
+   RF_Acq *RF;                                      // pointer to the RF acquisition
+
+   int              FFTsize;
+   DFT1d<Float>     FFT;
+   Float           *Window;
+
+   SampleBuffer< std::complex<Float> > Spectra;     // (complex) spectra
+   SampleBuffer< Float >               Power;       // spectra power (energy)
+
+   MessageQueue<Socket *>  SpectrogramQueue;        // sockets send to this queue should be written with a most recent spectrogram
+   SampleBuffer<uint8_t>   Image;
+   JPEG                    JpegImage;
+
+   std::vector<Float>  PPM_Values;                  // [ppm] measured frequency correction values (a vector of)
+   Float               PPM_Aver;                    // [ppm] average frequency correction
+   Float               PPM_RMS;                     // [ppm] RMS of the frequency correction
+   int                 PPM_Points;                  // number of measurements taken into the average
+   time_t              PPM_Time;                    // time when correction measured
+   Float            getPPM(void)  const { Float Value=PPM_Aver; return Value; }
+
+  public:
+   GSM_FFT(RF_Acq *RF)
+   { Window=0; this->RF=RF; Preset(); }
+
+   int Preset(void) { return Preset(RF->SampleRate); }
+   int Preset(int SampleRate)
+   { FFTsize=(8*SampleRate)/15625;
+     FFT.PresetForward(FFTsize);
+     Window=(Float *)realloc(Window, FFTsize*sizeof(Float));
+     FFT.SetSineWindow(Window, FFTsize, (Float)(1.0/sqrt(FFTsize)) );
+     PPM_Values.clear(); PPM_Aver=0; PPM_RMS=0; PPM_Points=0; PPM_Time=0;
+     return 1; }
+
+   void Start(void)
+   { StopReq=0; Thr.setExec(ThreadExec); Thr.Create(this); }
+
+  ~GSM_FFT()
+   { Thr.Cancel();
+     if(Window) free(Window); }
+
+   double getCPU(void) // get CPU time for this thread
+   {
+#if !defined(__MACH__)
+       struct timespec now; clock_gettime(CLOCK_THREAD_CPUTIME_ID, &now); return now.tv_sec + 1e-9*now.tv_nsec;
+#else
+       return 0.0;
+#endif
+   }
+
+   static void *ThreadExec(void *Context)
+   { GSM_FFT *This = (GSM_FFT *)Context; return This->Exec(); }
+
+   void *Exec(void)
+   { // printf("GSM_FFT.Exec() ... Start\n");
+     while(!StopReq)
+     { double ExecTime=getCPU();
+       SampleBuffer<uint8_t> *InpBuffer = RF->GSM_OutQueue.Pop();
+       // printf("GSM_FFT.Exec() ... (%5.3fMHz, %5.3fsec, %dsamples)\n", 1e-6*InpBuffer->Freq, InpBuffer->Time, InpBuffer->Full/2);
+       SlidingFFT(Spectra, *InpBuffer, FFT, Window);
+       SpectraPower(Power, Spectra);
+       RF->GSM_OutQueue.Recycle(InpBuffer);
+       if(SpectrogramQueue.Size())
+       { LogImage(Image, Power, (Float)0.33, (Float)32.0, (Float)32.0);
+         JpegImage.Compress_MONO8(Image.Data, Image.Len, Image.Samples() ); }
+       while(SpectrogramQueue.Size())
+       { Socket *Client; SpectrogramQueue.Pop(Client);
+         Client->Send("HTTP/1.1 200 OK\r\nCache-Control: no-cache\r\nContent-Type: image/jpeg\r\nRefresh: 10\r\n\r\n");
+         // printf("GSM_FFT.Exec() ... Request for (GSM)spectrogram\n");
+         Client->Send(JpegImage.Data, JpegImage.Size);
+         Client->SendShutdown(); Client->Close(); delete Client; }
+       Process();
+       ExecTime=getCPU()-ExecTime; // printf("GSM_FFT.Exec() ... %5.3fsec\n", ExecTime);
+     }
+     // printf("GSM_FFT.Exec() ... Stop\n");
+     return 0; }
+
+   static const int ChanWidth = 200000; // [Hz] GSM channel width
+   static const int DataRate  = 270833; // [Hz] GSM data rate
+   SampleBuffer<Float> Aver, Peak, PeakPos, Bkg;
+
+   void Process(void)
+   { Float BinWidth=Power.Rate/2;                              // [Hz] FFT bin spectral width
+     int Bins = Power.Len;                                     // [int] number of FFT bins
+     Float FirstBinFreq = Power.Freq-BinWidth*Bins/2;          // [Hz] center frequency of the first FFT bin
+     Float LastBinFreq  = Power.Freq+BinWidth*Bins/2;          // [Hz] center frequency of the one-after-the-last FFT bin
+
+     int Chan = (int)ceil(FirstBinFreq/ChanWidth);             // integer channel number corr. to the first FFT bin (GSM channels are on multiples of 200kHz)
+     for( ; ; Chan++)                                          // loop over (possible) channels in this scan
+     { Float CenterFreq=Chan*ChanWidth; if(CenterFreq>=LastBinFreq) break; // center frequency of the channel
+       Float LowFreq = CenterFreq-0.45*ChanWidth;              // [Hz] lower frequency to measure the channel
+       Float UppFreq = CenterFreq+0.45*ChanWidth;              // [Hz] upper frequency to measure the channel
+       int LowBin=(int)floor((LowFreq-FirstBinFreq)/BinWidth+0.5); // FFT bins corresponding to the channel frequency range
+       int UppBin=(int)floor((UppFreq-FirstBinFreq)/BinWidth+0.5);
+       if( (LowBin<0) || (LowBin>=Bins) ) continue;            // skip this channel if range to measure
+       if( (UppBin<0) || (UppBin>=Bins) ) continue;            // not contained completely in this scan
+       Float AverPower;
+       int Marks=ProcessChan(AverPower, LowBin, UppBin, (CenterFreq-FirstBinFreq)/BinWidth, BinWidth, CenterFreq);
+       if(Marks==1) PPM_Values.pop_back(); // if only one mark found, drop it - likely a false signal
+       // printf("Process: Chan=%d, Freq=%8.3fMHz [%3d-%3d] %+6.1fdB %d\n", Chan, 1e-6*CenterFreq, LowBin, UppBin, 10*log10(AverPower), Marks);
+       // { char FileName[32]; sprintf(FileName, "GSM_%5.1fMHz.dat", 1e-6*CenterFreq);
+       //   FILE *File=fopen(FileName, "wt");
+       //   for(int Idx=0; Idx<Aver.Full; Idx++)
+       //  { fprintf(File, "%5d %12.6f %12.6f %+10.6f %10.6f\n",
+       //                   Idx, Aver[Idx], Peak[Idx], PeakPos[Idx], Bkg[Idx]); }
+       //   fclose(File); }
+     }
+
+     std::sort(PPM_Values.begin(), PPM_Values.end());
+
+     if(PPM_Values.size()>=16)                                         // if at least 16 measured points
+     { Float Aver, RMS; int Margin=PPM_Values.size()/4;
+       AverRMS(Aver, RMS, PPM_Values.data()+Margin, PPM_Values.size()-2*Margin);
+       // printf("PPM = %+7.3f (%5.3f) [%d]\n", Aver, RMS, PPM_Values.size()-2*Margin);
+       if(RMS<0.5)
+       { PPM_Aver=Aver; PPM_RMS=RMS; PPM_Points=PPM_Values.size()-2*Margin; PPM_Time=(time_t)floor(Power.Time+0.5); PPM_Values.clear();
+         printf("GSM freq. calib. = %+7.3f +/- %5.3f ppm, %d points\n", PPM_Aver, PPM_RMS, PPM_Points);
+         Float Corr=RF->GSM_FreqCorr; Corr+=0.25*(PPM_Aver-Corr); RF->GSM_FreqCorr=Corr; }
+       PPM_Values.clear();
+     }
+
+     if(PPM_Values.size()>=8)                                          // if at least 8 measured points
+     { Float Aver, RMS;
+       AverRMS(Aver, RMS, PPM_Values.data()+1, PPM_Values.size()-2);   // calc. the average excluding two extreme points
+       // printf("PPM = %+7.3f (%5.3f) [%d]\n", Aver, RMS, PPM_Values.size()-2);
+       if(RMS<0.5)
+       { PPM_Aver=Aver; PPM_RMS=RMS; PPM_Points=PPM_Values.size()-2; PPM_Time=(time_t)floor(Power.Time+0.5); PPM_Values.clear();
+         printf("GSM freq. calib. = %+7.3f +/- %5.3f ppm, %d points\n", PPM_Aver, PPM_RMS, PPM_Points);
+         Float Corr=RF->GSM_FreqCorr; Corr+=0.25*(PPM_Aver-Corr); RF->GSM_FreqCorr=Corr; }
+     }
+
+   }
+
+   // Average, Peak (with Position) and Background = Average - values around the Peak
+   static void AverPeakBkg(Float &Aver, Float &Peak, Float &PeakPos, Float &Bkg, Float *Data, int Size)
+   { Aver=0; Peak=0; PeakPos=0; int PeakIdx=0;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Float Dat=Data[Idx];
+       if(Dat>Peak) { Peak=Dat; PeakIdx=Idx; }
+       Aver+=Dat; }
+     if(PeakIdx==0)             { Peak+=Data[     1];                    PeakPos=PeakIdx+Data[     1]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
+     else if(PeakPos==(Size-1)) { Peak+=Data[Size-2];                    PeakPos=PeakIdx-Data[Size-2]/Peak;                      Bkg=(Aver-Peak)/(Size-2); }
+     else                       { Peak+=Data[PeakIdx+1]+Data[PeakIdx-1]; PeakPos=PeakIdx+(Data[PeakIdx+1]-Data[PeakIdx-1])/Peak; Bkg=(Aver-Peak)/(Size-3); }
+     Aver/=Size; }
+
+   // average and RMS of a data series
+   static void AverRMS(Float &Aver, Float &RMS, Float *Data, int Size)
+   { Aver=0; RMS=0;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Aver+=Data[Idx]; }
+     Aver/=Size;
+     for(int Idx=0; Idx<Size; Idx++)
+     { Float Diff=Data[Idx]-Aver; RMS+=Diff*Diff; }
+     RMS=sqrt(RMS/Size); }
+
+   int ProcessChan(Float &AverPower, int LowBin, int UppBin, Float CenterBin, Float BinWidth, Float CenterFreq)
+   { int Slides = Power.Samples();
+     int Bins = Power.Len;
+     Aver.Allocate(1, Slides); Peak.Allocate(1, Slides); PeakPos.Allocate(1, Slides); Bkg.Allocate(1, Slides);
+     Float *Data = Power.Data;
+     for(int Idx=0; Idx<Slides; Idx++, Data+=Bins)
+     { AverPeakBkg(Aver[Idx], Peak[Idx], PeakPos[Idx], Bkg[Idx], Data+LowBin, UppBin-LowBin+1);
+       PeakPos[Idx]+=LowBin-CenterBin; }
+     Aver.Full=Slides; Peak.Full=Slides; PeakPos.Full=Slides; Bkg.Full=Slides;
+     Float PowerRMS; AverRMS(AverPower, PowerRMS, Aver.Data, Slides);
+     // printf("AverPower=%3.1f, PowerRMS=%3.1f\n", AverPower, PowerRMS);
+     if(PowerRMS>(0.5*AverPower)) return 0;          // skip pulsing channels
+
+     Float AverPeak, PeakRMS; AverRMS(AverPeak, PeakRMS, Peak.Data, Slides);
+     Float AverBkg, BkgRMS; AverRMS(AverBkg, BkgRMS, Bkg.Data, Slides);
+     // printf("AverPeak=%3.1f, PeakRMS=%3.1f, AverBkg=%5.3f, BkgRMS=%5.3f\n", AverPeak, PeakRMS, AverBkg, BkgRMS);
+
+     int Marks=0;
+     Float PeakThres = 4*PeakRMS;
+     Float BkgThres  = 4*BkgRMS;
+     for(int Idx=1; Idx<(Slides-1); Idx++)
+     { Float PeakL=Peak.Data[Idx-1]-AverPeak;
+       Float PeakM=Peak.Data[Idx  ]-AverPeak;
+       Float PeakR=Peak.Data[Idx+1]-AverPeak;
+       Float PeakSum = PeakL+PeakM+PeakR;
+       if(PeakSum<=PeakThres) continue;
+       if(PeakM<PeakL)  continue;
+       if(PeakM<=PeakR) continue;
+       if(PeakM<=((PeakL+PeakR)/2)) continue;
+       Float BkgSum = Bkg.Data[Idx-1]+Bkg.Data[Idx]+Bkg.Data[Idx+1];
+       if((3*AverBkg-BkgSum)<BkgThres) continue;
+       if(Peak.Data[Idx]<(40*Bkg.Data[Idx])) continue;
+       Float PPM = -1e6*(PeakPos.Data[Idx]*BinWidth-(Float)DataRate/4)/CenterFreq;
+       // printf("Mark: PeakSum[%5d]=%8.1f/%6.1f Bkg=%8.3f/%6.3f Peak/Bkg=%8.1f PeakPos=%+7.3f %+7.3fppm\n",
+       //         Idx, PeakSum, PeakThres, 3*AverBkg-BkgSum, BkgThres, Peak.Data[Idx]/Bkg.Data[Idx], PeakPos.Data[Idx], PPM);
+       PPM_Values.push_back(PPM);
+       Marks++; }
+
+     return Marks; }
+
+} ;
+
+// ==================================================================================================
+
+
+template <class Float>
+ class HTTP_Server
+{ public:
+
+   int                 Port;      // listenning port
+   Thread              Thr;       // processing thread
+   RF_Acq             *RF;        // pointer to RF acquisition
+   GSM_FFT<Float>     *GSM;
+   char                Host[32];  // Host name
+
+  public:
+   HTTP_Server(RF_Acq *RF, GSM_FFT<Float> *GSM)
+   { this->RF=RF; this->GSM=GSM;
+     Host[0]=0; SocketAddress::getHostName(Host, 32);
+     Config_Defaults(); }
+
+   void Config_Defaults(void)
+   { Port=8080; }
+
+   int Config(config_t *Config)
+   { config_lookup_int(Config, "HTTP.Port", &Port); return 0; }
+
+   void Start(void)
+   { if(Port<=0) return;
+     Thr.setExec(ThreadExec); Thr.Create(this); }
+
+  ~HTTP_Server()
+   { if(Port) Thr.Cancel(); }
+
+   static void *ThreadExec(void *Context)
+   { HTTP_Server *This = (HTTP_Server *)Context; return This->Exec(); }
+
+   void *Exec(void)
+   { printf("HTTP_Server.Exec() ... Start\n");
+     while(1)
+     { Socket Listen;
+       if(Listen.Create_STREAM()<0) { printf("HTTP_Server.Exec() ... Cannot Create_STREAM()\n"); sleep(1); continue; }
+       if(Listen.setReuseAddress()<0) { printf("HTTP_Server.Exec() ... Cannot setReuseAddress()\n"); sleep(1); continue; }
+       if(Listen.Listen(Port)<0) { printf("HTTP_Server.Exec() ... Cannot listen() on port %d\n", Port); sleep(1); continue; }
+       printf("HTTP_Server.Exec() ... Listening on port %d\n", Port);
+       while(1)
+       { Socket *Client = new Socket; SocketAddress ClientAddress;
+         if(Listen.Accept(*Client, ClientAddress)<0) { printf("HTTP_Server.Exec() ... Cannot accept()\n"); sleep(1); break; }
+         printf("HTTP_Server.Exec() ... Client from %s\n", ClientAddress.getIPColonPort());
+         Client->setReceiveTimeout(2.0); Client->setSendTimeout(5.0); Client->setLinger(1, 5);
+         SocketBuffer Request; time_t ConnectTime; time(&ConnectTime);
+         while(1)
+         { if(Client->Receive(Request)<0) { printf("HTTP_Server.Exec() ... Cannot receive()\n"); Client->SendShutdown(); Client->Close(); delete Client; Client=0; break; }
+           if( Request.Len && strstr(Request.Data, "\r\n\r\n") ) break;
+           time_t Now; time(&Now);
+           if((Now-ConnectTime)>2) { printf("HTTP_Server.Exec() ... Request timeout\n"); Client->SendShutdown(); Client->Close(); delete Client; Client=0; break; }
+         }
+         if(Client)
+         { // printf("HTTP_Server.Exec() ... Request[%d]:\n", Request.Len); Request.WriteToFile(stdout); fflush(stdout);
+           ProcessRequest(Client, Request); }
+       }
+       Listen.Close();
+     }
+     printf("HTTP_Server.Exec() ... Stop\n");
+     return 0; }
+
+   int CopyWord(char *Dst, char *Src, int MaxLen)
+   { int Count=0; MaxLen-=1;
+     for( ; ; )
+     { char ch = (*Src++); if(ch<=' ') break;
+       if(Count>=MaxLen) return -1;
+       (*Dst++) = ch; Count++; }
+     (*Dst++)=0;
+     return Count; }
+
+   void ProcessRequest(Socket *Client, SocketBuffer &Request)
+   { if(memcmp(Request.Data, "GET ", 4)!=0) goto BadRequest;
+     char File[64]; if(CopyWord(File, Request.Data+4, 64)<0) goto BadRequest;
+     printf("HTTP_Server.Exec() ... Request for %s\n", File);
+
+          if(strcmp(File, "/")==0)
+     { Status(Client); return; }
+     else if( (strcmp(File, "/status.html")==0)         || (strcmp(File, "status.html")==0) )
+     { Status(Client); return; }
+     else if( (strcmp(File, "/gsm-spectrogram.jpg")==0) || (strcmp(File, "gsm-spectrogram.jpg")==0) )
+     { GSM->SpectrogramQueue.Push(Client); return; }
+     else if( (strcmp(File, "/time-slot-rf.u8")==0)  || (strcmp(File, "time-slot-rf.u8")==0) )
+     { RF->RawDataQueue.Push(Client); return; }
+     // NotFound:
+       Client->Send("HTTP/1.0 404 Not Found\r\n\r\n"); Client->SendShutdown(); Client->Close(); delete Client; return;
+
+     BadRequest:
+       Client->Send("HTTP/1.0 400 Bad Request\r\n\r\n"); Client->SendShutdown(); Client->Close(); delete Client; return;
+   }
+
+   void Status(Socket *Client)
+   { Client->Send("\
+HTTP/1.1 200 OK\r\n\
+Cache-Control: no-cache\r\n\
+Content-Type: text/html\r\n\
+Refresh: 5\r\n\
+\r\n\
+<!DOCTYPE html>\r\n\
+<html>\r\n\
+");
+     // time_t Now; time(&Now);
+     dprintf(Client->SocketFile, "\
+<title>RTLSDR-OGN RF processor " STR(VERSION) " status</title>\n\
+<b>RTLSDR OGN RF processor " STR(VERSION) "/"__DATE__"</b><br /><br />\n\n");
+
+     dprintf(Client->SocketFile, "<table>\n<tr><th>System</th><th></th></tr>\n");
+
+     dprintf(Client->SocketFile, "<tr><td>Host name</td><td align=right><b>%s</b></td></tr>\n", Host);
+     time_t Now; time(&Now);
+     struct tm TM; localtime_r(&Now, &TM);
+     dprintf(Client->SocketFile, "<tr><td>Local time</td><td align=right><b>%02d:%02d:%02d</b></td></tr>\n", TM.tm_hour, TM.tm_min, TM.tm_sec);
+     dprintf(Client->SocketFile, "<tr><td>Software</td><td align=right><b>" STR(VERSION) "</b></td></tr>\n");
+
+#ifndef __MACH__
+     struct sysinfo SysInfo;
+     if(sysinfo(&SysInfo)>=0)
+     { dprintf(Client->SocketFile, "<tr><td>CPU load</td><td align=right><b>%3.1f/%3.1f/%3.1f</b></td></tr>\n",
+                                   SysInfo.loads[0]/65536.0, SysInfo.loads[1]/65536.0, SysInfo.loads[2]/65536.0);
+       dprintf(Client->SocketFile, "<tr><td>RAM [free/total]</td><td align=right><b>%3.1f/%3.1f MB</b></td></tr>\n",
+                                   1e-6*SysInfo.freeram*SysInfo.mem_unit, 1e-6*SysInfo.totalram*SysInfo.mem_unit);
+     }
+#endif
+
+     float CPU_Temperature;
+     if(getCpuTemperature(CPU_Temperature)>=0)
+       dprintf(Client->SocketFile, "<tr><td>CPU temperature</td><td align=right><b>%+5.1f &#x2103;</b></td></tr>\n",    CPU_Temperature);
+     float SupplyVoltage;
+     if(getSupplyVoltage(SupplyVoltage)>=0)
+       dprintf(Client->SocketFile, "<tr><td>Supply voltage</td><td align=right><b>%5.3f V</b></td></tr>\n",    SupplyVoltage);
+     float SupplyCurrent;
+     if(getSupplyCurrent(SupplyCurrent)>=0)
+       dprintf(Client->SocketFile, "<tr><td>Supply current</td><td align=right><b>%5.3f A</b></td></tr>\n",    SupplyCurrent);
+
+     double NtpTime, EstError, RefFreqCorr;
+     if(getNTP(NtpTime, EstError, RefFreqCorr)>=0)
+     { time_t Time = floor(NtpTime);
+       struct tm TM; gmtime_r(&Time, &TM);
+       dprintf(Client->SocketFile, "<tr><td>NTP UTC time</td><td align=right><b>%02d:%02d:%02d</b></td></tr>\n", TM.tm_hour, TM.tm_min, TM.tm_sec);
+       dprintf(Client->SocketFile, "<tr><td>NTP est. error</td><td align=right><b>%3.1f ms</b></td></tr>\n", 1e3*EstError);
+       dprintf(Client->SocketFile, "<tr><td>NTP freq. corr.</td><td align=right><b>%+5.2f ppm</b></td></tr>\n", RefFreqCorr);
+     }
+
+     if(RF->SDR.isOpen())
+     { dprintf(Client->SocketFile, "<tr><th>RTL-SDR device #%d</th><th></th></tr>\n",                                  RF->SDR.DeviceIndex);
+       dprintf(Client->SocketFile, "<tr><td>Name</td><td align=right><b>%s</b></td></tr>\n",                           RF->SDR.getDeviceName());
+       dprintf(Client->SocketFile, "<tr><td>Tuner type</td><td align=right><b>%s</b></td></tr>\n",                     RF->SDR.getTunerTypeName());
+       char Manuf[256], Product[256], Serial[256];
+       RF->SDR.getUsbStrings(Manuf, Product, Serial);
+       dprintf(Client->SocketFile, "<tr><td>Manufacturer</td><td align=right><b>%s</b></td></tr>\n",                    Manuf);
+       dprintf(Client->SocketFile, "<tr><td>Product</td><td align=right><b>%s</b></td></tr>\n",                         Product);
+       dprintf(Client->SocketFile, "<tr><td>Serial</td><td align=right><b>%s</b></td></tr>\n",                          Serial);
+#ifdef NEW_RTLSDR_LIB
+       for(int Stage=0; Stage<8; Stage++)
+       { char Descr[256]; int Gains=RF->SDR.getTunerStageGains(Stage, 0, Descr); if(Gains<=0) break;
+         dprintf(Client->SocketFile, "<tr><td>Tuner stage #%d</td><td align=right><b>%s [%2d]</b></td></tr>\n",  Stage, Descr, Gains);
+       }
+       dprintf(Client->SocketFile, "<tr><td>Tuner bandwidths</td><td align=right><b>[%d]</b></td></tr>\n",             RF->SDR.getTunerBandwidths());
+       dprintf(Client->SocketFile, "<tr><td>Tuner gains</td><td align=right><b>[%d]</b></td></tr>\n",                  RF->SDR.getTunerGains());
+#endif
+       dprintf(Client->SocketFile, "<tr><td>Center frequency</td><td align=right><b>%7.3f MHz</b></td></tr>\n",        1e-6*RF->SDR.getCenterFreq());
+       dprintf(Client->SocketFile, "<tr><td>Sample rate</td><td align=right><b>%5.3f MHz</b></td></tr>\n",             1e-6*RF->SDR.getSampleRate());
+       dprintf(Client->SocketFile, "<tr><td>Frequency correction</td><td align=right><b>%+5.1f ppm</b></td></tr>\n",   RF->FreqCorr + RF->GSM_FreqCorr);
+       uint32_t RtlFreq, TunerFreq; RF->SDR.getXtalFreq(RtlFreq, TunerFreq);
+       dprintf(Client->SocketFile, "<tr><td>RTL Xtal</td><td align=right><b>%8.6f MHz</b></td></tr>\n",    1e-6*RtlFreq);
+       dprintf(Client->SocketFile, "<tr><td>Tuner Xtal</td><td align=right><b>%8.6f MHz</b></td></tr>\n",  1e-6*TunerFreq);
+/*
+       dprintf(Client->SocketFile, "<tr><td>Gain[%d]</td><td align=right><b>", RF->SDR.Gains);
+       for(int Idx=0; Idx<RF->SDR.Gains; Idx++)
+       { dprintf(Client->SocketFile, "%c%3.1f", Idx?',':' ', 0.1*RF->SDR.Gain[Idx]);
+       }
+       dprintf(Client->SocketFile, " [dB]</b></td></tr>\n");
+*/
+     }
+
+     dprintf(Client->SocketFile, "<tr><th>RF</th><th></th></tr>\n");
+     dprintf(Client->SocketFile, "<tr><td>RF.Device</td><td align=right><b>%d</b></td></tr>\n",                       RF->DeviceIndex);
+     if(RF->DeviceSerial[0])
+       dprintf(Client->SocketFile, "<tr><td>RF.DeviceSerial</td><td align=right><b>%s</b></td></tr>\n",               RF->DeviceSerial);
+     dprintf(Client->SocketFile, "<tr><td>RF.SampleRate</td><td align=right><b>%3.1f MHz</b></td></tr>\n",       1e-6*RF->SampleRate);
+     // dprintf(Client->SocketFile, "<tr><td>RF.PipeName</td><td align=right><b>%s</b></td></tr>\n",                  ??->OutPipeName );
+     dprintf(Client->SocketFile, "<tr><td>RF.FreqCorr</td><td align=right><b>%+3d ppm</b></td></tr>\n",               RF->FreqCorr);
+     dprintf(Client->SocketFile, "<tr><td>RF.BiasTee</td><td align=right><b>%d</b></td></tr>\n",                      RF->BiasTee);
+     dprintf(Client->SocketFile, "<tr><td>RF.OffsetTuning</td><td align=right><b>%d</b></td></tr>\n",                 RF->OffsetTuning);
+     dprintf(Client->SocketFile, "<tr><td>Fine calib. FreqCorr</td><td align=right><b>%+5.1f ppm</b></td></tr>\n",    RF->GSM_FreqCorr);
+     dprintf(Client->SocketFile, "<tr><td>RF.PulseFilter.Threshold</td><td align=right><b>%d</b></td></tr>\n",        RF->PulseFilt.Threshold);
+     dprintf(Client->SocketFile, "<tr><td>RF.PulseFilter duty</td><td align=right><b>%5.1f ppm</b></td></tr>\n",    1e6*RF->PulseFilt.Duty);
+     // dprintf(Client->SocketFile, "<tr><td>RF.ToneFilter.Enable</td><td align=right><b>%d</b></td></tr>\n",                  FFT->Filter->Enable);
+     // dprintf(Client->SocketFile, "<tr><td>RF.ToneFilter.FFTsize</td><td align=right><b>%d</b></td></tr>\n",                 FFT->Filter->FFTsize);
+     // dprintf(Client->SocketFile, "<tr><td>RF.ToneFilter.Threshold</td><td align=right><b>%3.1f</b></td></tr>\n",            FFT->Filter->Threshold);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.GainMode</td><td align=right><b>%d</b></td></tr>\n",                 RF->OGN_GainMode);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.Gain</td><td align=right><b>%4.1f dB</b></td></tr>\n",           0.1*RF->OGN_Gain);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.CenterFreq</td><td align=right><b>%5.1f MHz</b></td></tr>\n",   1e-6*RF->OGN_CenterFreq);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.FreqHopChannels</td><td align=right><b>%d</b></td></tr>\n",          RF->OGN_FreqHopChannels);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.StartTime</td><td align=right><b>%5.3f sec</b></td></tr>\n",         RF->OGN_StartTime);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.SensTime</td><td align=right><b>%5.3f sec</b></td></tr>\n", (double)(RF->OGN_SamplesPerRead)/RF->SampleRate);
+     dprintf(Client->SocketFile, "<tr><td>RF.OGN.SaveRawData</td><td align=right><b>%d sec</b></td></tr>\n", RF->OGN_SaveRawData);
+     dprintf(Client->SocketFile, "<tr><td>RF.GSM.CenterFreq</td><td align=right><b>%5.1f MHz</b></td></tr>\n",   1e-6*RF->GSM_CenterFreq);
+     dprintf(Client->SocketFile, "<tr><td>RF.GSM.Gain</td><td align=right><b>%4.1f dB</b></td></tr>\n",           0.1*RF->GSM_Gain);
+     dprintf(Client->SocketFile, "<tr><td>RF.GSM.SensTime</td><td align=right><b>%5.3f sec</b></td></tr>\n", (double)(RF->GSM_SamplesPerRead)/RF->SampleRate);
+
+
+     dprintf(Client->SocketFile, "</table>\n");
+
+     Client->Send("\
+<br />\r\n\
+RF spectrograms:\r\n\
+<a href='gsm-spectrogram.jpg'>GSM frequency calibration</a><br />\r\n\
+<br /><br />\r\n\
+<a href='time-slot-rf.u8'>RF raw data</a> of a time-slot (8-bit unsigned I/Q) - a 2 MB binary file !<br />\r\n\
+");
+
+     Client->Send("</html>\r\n");
+     Client->SendShutdown(); Client->Close(); delete Client; }
+
+} ;
+
+// ==================================================================================================
+
+  RF_Acq             RF;                         // RF input: acquires RF data for OGN and selected GSM frequency
+
+  Inp_Filter<float>  Filter(&RF);                // Coherent interference filter
+
+  Inp_FFT<float>     FFT(&RF, &Filter);          // FFT for OGN demodulator
+  GSM_FFT<float>     GSM(&RF);                   // GSM frequency calibration
+
+  HTTP_Server<float> HTTP(&RF, &GSM);            // HTTP server to show status and spectrograms
+
+void SigHandler(int signum) // Signal handler, when user pressed Ctrl-C or process stops for whatever reason
+{ RF.StopReq=1; }
+
+// ----------------------------------------------------------------------------------------------------
+
+int SetUserValue(const char *Name, float Value)
+{ // printf("%s = %f\n", Name, Value);
+  if(strcmp(Name, "RF.FreqCorr")==0)
+  { RF.FreqCorr=(int)floor(Value+0.5);
+    printf("RF.FreqCorr=%+d ppm\n", RF.FreqCorr);
+    return 1; }
+  if(strcmp(Name, "RF.OGN.Gain")==0)
+  { RF.OGN_Gain=(int)floor(10*Value+0.5);
+    printf("RF.OGN.Gain=%3.1f dB\n", 0.1*RF.OGN_Gain);
+    return 1; }
+  if(strcmp(Name, "RF.OGN.GainMode")==0)
+  { RF.OGN_GainMode=(int)floor(Value+0.5);
+    printf("RF.OGN.GainMode=%d\n", RF.OGN_GainMode);
+    return 1; }
+  if(strcmp(Name, "RF.OGN.SaveRawData")==0)
+  { RF.OGN_SaveRawData=(int)floor(Value+0.5);
+    printf("RF.OGN.SaveRawData=%d\n", RF.OGN_SaveRawData);
+    return 1; }
+  if(strcmp(Name, "RF.GSM.Gain")==0)
+  { RF.GSM_Gain=(int)floor(10*Value+0.5);
+    printf("RF.GSM.Gain=%3.1f dB\n", 0.1*RF.GSM_Gain);
+    return 1; }
+  if(strcmp(Name, "RF.OGN.CenterFreq")==0)
+  { RF.OGN_CenterFreq=(int)floor(1e6*Value+0.5);
+    printf("RF.OGN.CenterFreq=%7.3f MHz\n", 1e-6*RF.OGN_CenterFreq);
+    return 1; }
+  if(strcmp(Name, "RF.GSM.CenterFreq")==0)
+  { RF.GSM_CenterFreq=(int)floor(1e6*Value+0.5);
+    printf("RF.GSM.CenterFreq=%7.3f MHz\n", 1e-6*RF.GSM_CenterFreq);
+    return 1; }
+  if(strcmp(Name, "RF.OGN.FreqHopChannels")==0)
+  { RF.OGN_FreqHopChannels=(int)floor(Value+0.5);
+    printf("RF.OGN_FreqHopChannels=%d\n", RF.OGN_FreqHopChannels);
+    return 1; }
+  if(strcmp(Name, "RF.PulseFilter.Threshold")==0)
+  { RF.PulseFilt.Threshold=(int)floor(Value+0.5);
+    printf("RF.PulseFilter.Threshold=%d\n", RF.PulseFilt.Threshold);
+    return 1; }
+  return 0; }
+
+int PrintUserValues(void)
+{ printf("Settable parameters:\n");
+  printf("RF.FreqCorr=%+d(%+3.1f) ppm\n",      RF.FreqCorr, RF.GSM_FreqCorr);
+  printf("RF.PulseFilter.Threshold=%d",        RF.PulseFilt.Threshold);
+  if(RF.PulseFilt.Threshold) printf(" .Duty=%3.1fppm", 1e6*RF.PulseFilt.Duty);
+  printf("\n");
+  printf("RF.OGN.CenterFreq=%7.3f MHz\n", 1e-6*RF.OGN_CenterFreq);
+  printf("RF.OGN_FreqHopChannels=%d\n",        RF.OGN_FreqHopChannels);
+  printf("RF.OGN.Gain=%3.1f dB\n",         0.1*RF.OGN_Gain);
+  printf("RF.OGN.GainMode=%d\n",               RF.OGN_GainMode);
+  printf("RF.OGN.SaveRawData=%d\n",            RF.OGN_SaveRawData);
+  printf("RF.GSM.CenterFreq=%7.3f MHz\n", 1e-6*RF.GSM_CenterFreq);
+  printf("RF.GSM.Gain=%3.1f dB\n",         0.1*RF.GSM_Gain);
+  return 0; }
+
+int UserCommand(char *Cmd)
+{ if(strchr(Cmd, '\n')==0) return 0;
+  char *Equal = strchr(Cmd, '=');
+  // printf("User command: %s", Cmd);
+  if(Equal)
+  { Equal[0]=0; const char *ValuePtr=Equal+1;
+    char *Name=Cmd;
+    for( ; ; )
+    { char ch=Name[0]; if(ch==0) break;
+      if(ch>' ') break;
+      Name++; }
+    for( ; ; )
+    { Equal--;
+      char ch=Equal[0]; if(ch==0) break;
+      if(ch>' ') break;
+      Equal[0]=0; }
+    float Value;
+    if(sscanf(ValuePtr, "%f", &Value)==1) SetUserValue(Name, Value);
+  }
+  PrintUserValues();
+  return 0; }
+
+// ----------------------------------------------------------------------------------------------------
+
+int main(int argc, char *argv[])
+{
+  const char *ConfigFileName = "rtlsdr-ogn.conf";
+  if(argc>1) ConfigFileName = argv[1];
+
+  config_t Config;
+  config_init(&Config);
+  if(config_read_file(&Config, ConfigFileName)==CONFIG_FALSE)
+  { printf("Could not read %s as configuration file\n", ConfigFileName); config_destroy(&Config); return -1; }
+
+  struct sigaction SigAction;
+  SigAction.sa_handler = SigHandler;              // setup the signal handler (for Ctrl-C or when process is stopped)
+  sigemptyset(&SigAction.sa_mask);
+  SigAction.sa_flags = 0;
+
+  struct sigaction SigIgnore;
+  SigIgnore.sa_handler = SIG_IGN;
+  sigemptyset(&SigIgnore.sa_mask);
+  SigIgnore.sa_flags = 0;
+
+  sigaction(SIGINT,  &SigAction, 0);
+  sigaction(SIGTERM, &SigAction, 0);
+  sigaction(SIGQUIT, &SigAction, 0);
+  sigaction(SIGPIPE, &SigIgnore, 0);              // we want to ignore pipe/fifo read/write errors, we handle them by return codes
+
+  RF.Config_Defaults();
+  RF.Config(&Config);
+
+  Filter.Config_Defaults();
+  Filter.Config(&Config);
+  if(Filter.Enable) Filter.Preset();
+
+  FFT.Config_Defaults();
+  FFT.Config(&Config);
+  FFT.Preset();
+
+  GSM.Preset();
+
+  HTTP.Config_Defaults();
+  HTTP.Config(&Config);
+  HTTP.Start();
+
+  config_destroy(&Config);
+
+  if(Filter.Enable) Filter.Start();
+  FFT.Start();
+  GSM.Start();
+  RF.Start();
+
+  char Cmd[128];
+  while(!RF.StopReq)
+  { if(fgets(Cmd, 128, stdin)==0) break;
+    UserCommand(Cmd); }
+
+  sleep(4);
+  RF.Stop();
+
+  return 0; }
+
+
diff --git a/src/pulsefilter.h b/src/pulsefilter.h
new file mode 100644
index 0000000..964c9a7
--- /dev/null
+++ b/src/pulsefilter.h
@@ -0,0 +1,69 @@
+#include <stdint.h>
+
+#include "buffer.h"
+#include "boxfilter.h"
+
+class PulseFilter
+{ public:
+   int Threshold;                                        // apply pulse filter to the the RF samples to remove wideband pulses like radar
+   const static int PulseBoxRadius = 33;
+   const static int PulseBoxSize = 2*PulseBoxRadius+1;
+   BoxPeakSum<int32_t> PulseBox;
+   int Pulses;
+   float Duty;
+
+  public:
+   PulseFilter() { PulseBox.Preset(PulseBoxSize); Threshold=0; Pulses=0; Duty=0; }
+
+   int Process(SampleBuffer<uint8_t> &Buffer, uint8_t Bias=127)
+   { PulseBox.Clear(); Pulses=0;
+     if(Threshold<=0) return 0;
+     int Samples = Buffer.Samples();
+     if(Samples<PulseBoxSize) return 0;
+     // printf("PulseFilter::Process(Buffer[%d]) (%d)\n", Samples, Threshold);
+     uint8_t *Data = Buffer.Data;
+     int Idx;
+     for(Idx=0; Idx<(2*PulseBoxSize); Idx+=2)
+     { int32_t I = Data[Idx  ]-Bias;
+       int32_t Q = Data[Idx+1]-Bias;
+       int32_t Pwr = I*I + Q*Q;
+       PulseBox.Process(Pwr); }
+     for(    ; Idx<(2*Samples); Idx+=2)
+     { int32_t I = Data[Idx  ]-Bias;
+       int32_t Q = Data[Idx+1]-Bias;
+       int32_t Pwr = I*I + Q*Q;
+       PulseBox.Process(Pwr);
+       if(PulseBox.isAtPeak())
+       { int32_t PeakAmpl = PulseBox.PeakSum(1);
+         int32_t BkgNoise = (PulseBox.Sum-PeakAmpl)/(PulseBoxSize-3);
+         if(PeakAmpl>(Threshold*BkgNoise))
+         { // printf("PulseFilter::Process() %06d: %4d+%4d+%4d+%4d+%4d=%5d/%2d\n",
+           //         Idx/2, PulseBox.AtPeak(-2), PulseBox.AtPeak(-1), PulseBox.AtPeak(0), PulseBox.AtPeak(1), PulseBox.AtPeak(2), PeakAmpl, BkgNoise);
+           int32_t Thres = PeakAmpl/2;
+           int PeakIdx = Idx-2*PulseBoxRadius;
+           // printf("PulseFilter::Process() [%+3d,%+3d] [%+3d,%+3d] [%+3d,%+3d]\n", Data[PeakIdx-2]-Bias, Data[PeakIdx-1]-Bias, Data[PeakIdx]-Bias, Data[PeakIdx+1]-Bias, Data[PeakIdx+2]-Bias, Data[PeakIdx+3]-Bias);
+           SetZero(Data+PeakIdx, Bias);
+           if(PulseBox.AtPeak(-1)>Thres)
+           { SetZero(Data+(PeakIdx-2), Bias); SetHalf(Data+(PeakIdx-4), Bias); }
+           else SetHalf(Data+(PeakIdx-2), Bias);
+           if(PulseBox.AtPeak( 1)>Thres)
+           { SetZero(Data+(PeakIdx+2), Bias); SetHalf(Data+(PeakIdx+4), Bias); }
+           else SetHalf(Data+(PeakIdx+2), Bias);
+           // printf("PulseFilter::Process() [%+3d,%+3d] [%+3d,%+3d] [%+3d,%+3d]\n", Data[PeakIdx-2]-Bias, Data[PeakIdx-1]-Bias, Data[PeakIdx]-Bias, Data[PeakIdx+1]-Bias, Data[PeakIdx+2]-Bias, Data[PeakIdx+3]-Bias);
+           Pulses++; }
+       }
+     }
+     // printf("PulseFilter::Process(Buffer[%d]) (%d)  => %d pulses\n", Samples, Threshold, Pulses);
+     Duty = (float)Pulses/Samples;
+     return Pulses; }
+
+   static void SetZero(uint8_t *Data, uint8_t Bias=127)
+   { Data[0]=Bias; Data[1]=Bias; }
+
+   static void SetHalf(uint8_t *Data, uint8_t Bias=127)
+   { int8_t I = Data[0]-Bias; Data[0] = Bias + (I>>1);
+     int8_t Q = Data[1]-Bias; Data[1] = Bias + (Q>>1); }
+
+} ;
+
+
diff --git a/src/r2fft.h b/src/r2fft.h
new file mode 100644
index 0000000..0c6d43a
--- /dev/null
+++ b/src/r2fft.h
@@ -0,0 +1,191 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __R2FFT_H__
+#define __R2FFT_H__
+
+#include <stdint.h>
+#include <math.h>
+#include <complex>
+#include <new>
+
+template <class Float>
+ class r2FFT // radix-2 FFT
+{ public:    // size must a power of 2: 2,4,8,16,32,64,128,256,...
+
+   int                  Size;          // FFT size (needs to be power of 2)
+   int                 *BitRevIdx;     // Bit-reverse indexing table for data (un)scrambling
+   std::complex<Float> *Twiddle;       // Twiddle factors (sine/cos values)
+
+   r2FFT(int MaxSize)
+   { BitRevIdx=0; Twiddle=0; Preset(MaxSize); }
+
+   r2FFT()
+   { BitRevIdx=0; Twiddle=0; Size=0; }
+
+   ~r2FFT()
+   { Free(); }
+
+   void Free(void)
+   { delete [] BitRevIdx; BitRevIdx=0;
+     delete [] Twiddle; Twiddle=0; 
+     Size=0; }
+
+   // preset tables for given (maximum) processing size
+   int Preset(int MaxSize)
+   { Free();
+     if(MaxSize<4) { return 0; }
+     Size=MaxSize;
+     while((MaxSize&1)==0) MaxSize>>=1;
+     if(MaxSize!=1) { Size=0; return 0; }
+     BitRevIdx = new (std::nothrow) int                 [Size]; if(BitRevIdx==0) { Free(); return 0; }
+     Twiddle   = new (std::nothrow) std::complex<Float> [Size]; if(Twiddle==0)   { Free(); return 0; }
+     // int Size4=Size/4;
+     int Idx, rIdx, Mask, rMask;
+     for(Idx=0; Idx<Size; Idx++)
+     { double Phase=(2*M_PI*Idx)/Size;
+       Twiddle[Idx] = std::complex<Float> ( cos(Phase), -sin(Phase) ); }
+     // for(     ; Idx<Size; Idx++)
+     // { Twiddle[Idx].Re=(-Twiddle[Idx-Size4].Im);
+     //   Twiddle[Idx].Im=  Twiddle[Idx-Size4].Re ; }
+     for(rIdx=0, Idx=0; Idx<Size; Idx++)
+     { for(rIdx=0, Mask=Size/2,rMask=1; Mask; Mask>>=1,rMask<<=1)
+       { if(Idx&Mask) rIdx|=rMask; }
+       BitRevIdx[Idx]=rIdx; }
+     return Size; }
+
+   // scramble/unscramble (I)FFT input
+   template <class Type>
+    void Scramble(Type Data[])
+     { for(int Idx=0; Idx<Size; Idx++)
+       { int rIdx=BitRevIdx[Idx];
+         if(rIdx>Idx)
+         { Type Tmp=Data[Idx]; Data[Idx]=Data[rIdx]; Data[rIdx]=Tmp; }
+       }
+     }
+
+   template <class Type>
+    void Scramble(Type Data[], int ShrinkShift)
+     { int Len=Size>>ShrinkShift;
+       for(int Idx=0; Idx<Len; Idx++)
+       { int rIdx=BitRevIdx[Idx]>>=ShrinkShift;
+         if(rIdx>Idx)
+         { Type Tmp=Data[Idx]; Data[Idx]=Data[rIdx]; Data[rIdx]=Tmp; }
+       }
+     }
+
+   // core process: the classic tripple loop of butterflies
+   // radix-2 FFT: the first and the second pass are by hand
+   // looks like there is no gain by separating the second pass
+   // and even the first pass is in question ?
+   template <class Type>
+    void CoreProc(std::complex<Type> Data[])
+     { int Groups,GroupSize2,Group,Bf,TwidIdx;
+       int Size2=Size/2;
+       for(Bf=0; Bf<Size; Bf+=2) FFT2(Data[Bf],Data[Bf+1]); // first pass
+       // for(Bf=0; Bf<Size; Bf+=4) FFT4(Data[Bf], Data[Bf+1], Data[Bf+2], Data[Bf+3]); // second
+       // for(Groups=Size2/4,GroupSize2=4; Groups; Groups>>=1, GroupSize2<<=1)
+       for(Groups=Size2/2,GroupSize2=2; Groups; Groups>>=1, GroupSize2<<=1)
+         for(Group=0,Bf=0; Group<Groups; Group++,Bf+=GroupSize2)
+           for(TwidIdx=0; TwidIdx<Size2; TwidIdx+=Groups,Bf++)
+           { FFTbf(Data[Bf],Data[Bf+GroupSize2],Twiddle[TwidIdx]); }
+     }
+
+   // radix-2 FFT with a "shrink" factor
+   template <class Type>
+    void CoreProc(std::complex<Type> Data[], int ShrinkShift)
+     { int Groups,GroupSize2,Group,Bf,TwidIdx,TwidIncr;
+       int Len=Size>>ShrinkShift;
+       int Size2=Size/2;
+       int Len2=Len/2;
+       for(Bf=0; Bf<Len; Bf+=2) FFT2(Data[Bf],Data[Bf+1]); // first pass
+       // for(Bf=0; Bf<Len; Bf+=4) FFT4(Data[Bf],Data[Bf+1],Data[Bf+2],Data[Bf+3]); // second
+       for(Groups=Len2/2,TwidIncr=Size2/2,GroupSize2=2;
+           Groups;
+           Groups>>=1, TwidIncr>>=1, GroupSize2<<=1)
+         for(Group=0,Bf=0; Group<Groups; Group++,Bf+=GroupSize2)
+           for(TwidIdx=0; TwidIdx<Size2; TwidIdx+=TwidIncr,Bf++)
+           { FFTbf(Data[Bf],Data[Bf+GroupSize2],Twiddle[TwidIdx]); }
+     }
+
+   // complex FFT process in place, includes unscrambling
+   template <class Type>
+    int Process(std::complex<Type> Data[])
+     { Scramble(Data); CoreProc(Data); return 0; }
+
+   // find the "shrink" factor for processing batches smaller than declared by Preset()
+   int FindShrinkShift(int Len)
+     { int Shift;
+       for(Shift=0; Len<Size; Shift++)
+         Len<<=1;
+       if (Len!=Size) return -1;
+       return Shift; }
+
+   // process data with length smaller than requested by Preset() (but still a power of 2)
+   template <class Type>
+    int Process(std::complex<Type> Data[], int Len)
+     { if(Len<4) return -1;
+       if(Len==Size) { Scramble(Data); CoreProc(Data); return 0; }
+       int ShrinkShift=FindShrinkShift(Len); if(ShrinkShift<0) return -1;
+       Scramble(Data,ShrinkShift); CoreProc(Data,ShrinkShift); return 0; }
+
+   // classic radix-2 butterflies
+   template <class Type>
+    inline void FFTbf(std::complex<Type> &x0, std::complex<Type> &x1, std::complex<Float> &W)
+     { std::complex<Float> x1W;
+       x1W = x1 * W;
+       x1 = x0 - x1W;
+       x0 = x0 + x1W; }
+
+   // special 2-point FFT for the first pass
+   template <class Type>
+    inline void FFT2(std::complex<Type> &x0, std::complex<Type> &x1)
+     { std::complex<Type> x1W;
+       x1W = x1;
+       x1 = x0 - x1;
+       x0 += x1W; }
+/*
+   // special 4-point FFT for the second pass
+   template <class Type>
+    inline void FFT4(std::complex<Type> &x0, std::complex<Type> &x1, std::complex<Type> &x2, std::complex<Type> &x3)
+     { Type x1W;
+       x1W.Re=x2.Re;
+       x1W.Im=x2.Im;
+       x2.Re=x0.Re-x1W.Re;
+       x2.Im=x0.Im-x1W.Im;
+       x0.Re=x0.Re+x1W.Re;
+       x0.Im=x0.Im+x1W.Im;
+       x1W.Re=x3.Im;
+       x1W.Im=(-x3.Re);
+       x3.Re=x1.Re-x1W.Re;
+       x3.Im=x1.Im-x1W.Im;
+       x1.Re=x1.Re+x1W.Re;
+       x1.Im=x1.Im+x1W.Im; }
+*/
+  template <class Type>
+   static void SetSineWindow(Type *Window, int WindowSize, Type Scale=1.0)
+  { for(int Idx=0; Idx<WindowSize; Idx++)
+    { Window[Idx]=Scale*sin((M_PI*Idx)/WindowSize); }
+  }
+
+
+} ;
+
+#endif // __R2FFT_H__
diff --git a/src/r2fft_test.cc b/src/r2fft_test.cc
new file mode 100644
index 0000000..337e401
--- /dev/null
+++ b/src/r2fft_test.cc
@@ -0,0 +1,52 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "r2fft.h"
+#include "fft.h"
+
+#define Float double
+
+template <class Type>
+ double Power(std::complex<Type> X)
+{ return real(X)*real(X)+imag(X)*imag(X); }
+
+int main(int argc, char *argv[])
+{
+  r2FFT<Float> FFT;
+  DFT1d<Float> RefFFT;
+
+  int FFTsize = 1024;
+  std::complex<Float> Buffer[FFTsize];
+
+  FFT.Preset(FFTsize);
+  RefFFT.PresetForward(FFTsize);
+
+  srand(123456);
+  for(int Idx=0; Idx<FFTsize; Idx++)
+  { Buffer[Idx] = std::complex<Float>((rand()&3)-1.5, (rand()&3)-1.5 );
+    RefFFT.Buffer[Idx]=Buffer[Idx]; }
+
+  FFT.Process(Buffer);
+  RefFFT.Execute();
+
+  double AverPower=0;
+  for(int Idx=0; Idx<FFTsize; Idx++)
+  { AverPower += Power(Buffer[Idx]); }
+  AverPower/=FFTsize;
+  printf("FFT: <Power> = %8.3f\n", AverPower);
+
+  double RefAverPower=0;
+  for(int Idx=0; Idx<FFTsize; Idx++)
+  { RefAverPower += Power(RefFFT.Buffer[Idx]); }
+  RefAverPower/=FFTsize;
+  printf("RefFFT: <Power> = %8.3f\n", AverPower);
+
+  double DiffAverPower=0;
+  for(int Idx=0; Idx<FFTsize; Idx++)
+  { DiffAverPower += Power(Buffer[Idx]-RefFFT.Buffer[Idx]); }
+  DiffAverPower/=FFTsize;
+  printf("FFT-RefFFT: <Power> = %8.3f\n", DiffAverPower);
+
+  return 0; }
+
+
diff --git a/src/rtlsdr.h b/src/rtlsdr.h
new file mode 100644
index 0000000..f1e855d
--- /dev/null
+++ b/src/rtlsdr.h
@@ -0,0 +1,294 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <time.h>
+#include <sys/time.h>
+
+#include <math.h>
+
+// #include "alloc.h"
+#include "asciitime.h"
+#include "thread.h"
+
+#include "buffer.h"
+
+// =================================================================================
+
+#include <rtl-sdr.h>
+
+class RTLSDR
+{ public:
+   MutEx         Lock;           // for multi-threading
+
+   uint32_t      DeviceIndex;    // RTL dongle index
+   rtlsdr_dev_t *Device;         // RTL dongle handle
+   int           Gains;          // number of possible gain settings
+   int           Gain[64];       // [0.1 dB] list of possible gain settings
+
+   int           Bandwidths;
+   int           Bandwidth[16];
+
+   int           Stages;
+   int           StageGains[8];
+   char          StageName[8][32];
+   int           StageGain[8][32];
+
+   uint64_t      BytesRead;      // Counts number of bytes read (1 sample = 2 bytes: I/Q)
+   int         (*Callback)(uint8_t *Buffer, int Samples, double SampleTime, double SamplePeriod, void *Contex);
+   void         *CallbackContext;
+
+#ifndef __MACH__ // _POSIX_TIMERS
+   clockid_t     RefClock;           // CLOCK_REALTIME, CLOCK_MONOTONIC or CLOCK_MONOTONIC_RAW
+#endif
+
+   double        SampleTime;         // [sec] time when a batch of samples starts
+   double        StartTime;          // [sec] time when acquisition started
+   double        AverPeriod;         // [sec] averaging period for TimeRef, TimeRef_DMS and SamplePeriod
+   double        SamplePeriod;       // [sec] time per sample
+   double        PrevTime;           // [sec]
+   double        SampleTime_DMS;     // [sec^2] mean square variation of SampleTime
+
+  public:
+   RTLSDR()
+   { DeviceIndex=0; Device=0; Callback=0; CallbackContext=0; // Gain=0;
+     AverPeriod=100.0;
+#ifndef __MACH__ // _POSIX_TIMERS
+     RefClock=CLOCK_REALTIME;
+#endif
+   }
+
+  ~RTLSDR()
+   { Close(); }
+
+   bool isOpen(void) const { return Device!=0; }
+
+   void Close(void)
+   { if(Device)
+     { // printf("RTLSDR::Close() => %3.1f MB read, %3.1f samples/sec\n", BytesRead/(1024*1024.0), 1.0/SamplePeriod);
+       rtlsdr_cancel_async(Device); rtlsdr_close(Device); }
+     // free(Gain); Gain=0;
+     Gains=0; Stages=0; Bandwidths=0;
+     // free(SampleTimePipe); free(SampleIdxPipe); PipeSize=0; SampleTimePipe=0; SampleIdxPipe=0;
+     Device=0; Callback=0; }
+
+   static int  getNumberOfDevices(void)            { return rtlsdr_get_device_count(); }            // number of connected devices (USB RTL dongles)
+
+   static int  getDeviceUsbStrings(uint32_t DeviceIndex, char *Manufacturer, char *Product, char *Serial)
+             { return rtlsdr_get_device_usb_strings(DeviceIndex, Manufacturer, Product, Serial); }  // USB description strings
+   int         getUsbStrings(char *Manufacturer, char *Product, char *Serial)
+             { return rtlsdr_get_usb_strings(Device, Manufacturer, Product, Serial); }  // USB description strings
+             // { return rtlsdr_get_device_usb_strings(DeviceIndex, Manufacturer, Product, Serial); }  // USB description strings
+
+   static const char *getDeviceName(uint32_t DeviceIndex) { return rtlsdr_get_device_name(DeviceIndex); }  // name of given device
+          const char *getDeviceName(void)                 { return rtlsdr_get_device_name(DeviceIndex); }  // name of this device open by this object
+
+   int     getTunerType(void) { return rtlsdr_get_tuner_type(Device); }
+   const char *getTunerTypeName(void)
+   { const char *TunerType[7] = { "UNKNOWN", "E4000", "FC0012", "FC0013", "FC2580", "R820T", "R828D" } ;
+     int Type=getTunerType(); if((Type<0)&&(Type>=7)) Type=0; return TunerType[Type]; }
+
+   int     getXtalFreq(uint32_t &RtlFreq, uint32_t &TunerFreq) { return rtlsdr_get_xtal_freq(Device, &RtlFreq, &TunerFreq); }
+   int     setXtalFreq(uint32_t  RtlFreq, uint32_t  TunerFreq) { return rtlsdr_set_xtal_freq(Device,  RtlFreq,  TunerFreq); }
+
+   int     ReadEEPROM (uint8_t *Data, uint8_t Offset, uint16_t Size) { return rtlsdr_read_eeprom (Device, Data, Offset, Size); } // read  the EEPROM
+   int     WriteEEPROM(uint8_t *Data, uint8_t Offset, uint16_t Size) { return rtlsdr_write_eeprom(Device, Data, Offset, Size); } // write the EEPROM
+
+   int     setOffsetTuning(int ON=1) { return rtlsdr_set_offset_tuning(Device, ON); }
+   int     getOffsetTuning(void)     { return rtlsdr_get_offset_tuning(Device);     }
+
+   int     setCenterFreq(uint32_t Frequency)    { return rtlsdr_set_center_freq(Device, Frequency); } // [Hz]
+  uint32_t getCenterFreq(void)                  { return rtlsdr_get_center_freq(Device); } // (fast call)
+
+   int     setFreqCorrection(int PPM)           { return rtlsdr_set_freq_correction(Device, PPM); } // [PPM] (Part-Per-Million)
+   int     getFreqCorrection(void)              { return rtlsdr_get_freq_correction(Device); } // (fast call)
+
+#ifdef NEW_RTLSDR_LIB
+   int setTunerBandwidth(int Bandwidth) { return rtlsdr_set_tuner_bandwidth(Device, Bandwidth); }    // [Hz] a new (advanced) function
+   // int getTunerBandwidth(void)     { int Bandwidth; return rtlsdr_get_tuner_bandwidth(Device, &Bandwidth); return Bandwidth; }
+   int getTunerBandwidths(int *Bandwidth=0) { return rtlsdr_get_tuner_bandwidths(Device, Bandwidth); }
+#endif
+
+   int getTunerGains(int *Gain=0)           { return rtlsdr_get_tuner_gains(Device, Gain); }
+#ifdef NEW_RTLSDR_LIB
+   int getTunerStageGains(int Stage, int32_t *Gain, char *Description=0) { return rtlsdr_get_tuner_stage_gains(Device, Stage, Gain, Description); }
+   int setTunerStageGain(int Stage, int Gain) { return rtlsdr_set_tuner_stage_gain(Device, Stage, Gain); }
+#endif
+   int setTunerGain(int Gain) { return rtlsdr_set_tuner_gain(Device, Gain); }    // [0.1 dB]    set tuner gain when in manual mode
+   int getTunerGain(void)     { return rtlsdr_get_tuner_gain(Device); }
+
+   // note: new gain modes are possible with the more advanced drivers: 2=Linearity, 3=Sensitivity
+   int setTunerGainMode(int Manual=1) { return rtlsdr_set_tuner_gain_mode(Device, Manual); }  // set radio-tuner gain mode: manual or automatic
+   int setTunerGainManual(int Manual=1) { return setTunerGainMode(Manual); }                  // set manual mode
+   int setTunerGainAuto(void) { return setTunerGainManual(0); }                               // set automatic mode
+
+   int setTestMode(int Test=1) { return rtlsdr_set_testmode(Device, Test); }  // Enable/Disable test mode - a counter is send, not real data
+   int ResetBuffer(void) { return rtlsdr_reset_buffer(Device); }              // obligatory, the docs say, before you start reading
+
+   int setBiasTee(int On=1) { return rtlsdr_set_bias_tee(Device, On); }       // turn on or off the T-bias circuit to power extenal LNA: never use with DC-shorted antennas !
+
+   double getTime(void) const                                                 // read the system time at this very moment
+#ifndef __MACH__ // _POSIX_TIMERS
+   { struct timespec now; clock_gettime(RefClock, &now); return now.tv_sec + 1e-9*now.tv_nsec; }
+#else                                                                         // for OSX, there is no clock_gettime()
+   { struct timeval now; gettimeofday(&now, 0); return now.tv_sec + 1e-6*now.tv_usec; }
+#endif
+
+    int     setSampleRate(uint32_t SampleRate)  { SamplePeriod = 1.0/SampleRate; SampleTime_DMS=0.0001*0.0001;
+                                                  return rtlsdr_set_sample_rate(Device, SampleRate); } // [samples-per-second]
+   uint32_t getSampleRate(void)                 { return rtlsdr_get_sample_rate(Device); }
+
+   int getDeviceIndexBySerial(const char *Serial) { return rtlsdr_get_index_by_serial(Serial); }
+
+   int Open(uint32_t DeviceIndex=0, uint32_t Frequency=868000000, uint32_t SampleRate=2048000) // open given device (by the index)
+   { Close();
+
+     this->DeviceIndex=DeviceIndex;
+     if(rtlsdr_open(&Device, DeviceIndex)<0)                                                   // open the RTLSDR device
+     { printf("Cannot open device #%d\n", DeviceIndex); Device=0; return -1; }
+     if(setCenterFreq(Frequency)<0)                                                            // set the desired frequency
+     { printf("Cannot set the frequency %d for device #%d\n", Frequency, DeviceIndex); }
+     if(setSampleRate(SampleRate)<0)                                                           // set the desired sample rate
+     { printf("Cannot set the sample rate %d for device #%d\n", SampleRate, DeviceIndex); }
+     printf("RTLSDR::Open(%d,%d,%d) => %s, %8.3f MHz, %5.3f Msps\n",
+            DeviceIndex, Frequency, SampleRate, getDeviceName(), 1e-6*getCenterFreq(), 1e-6*getSampleRate());
+
+     Gains=getTunerGains(Gain);                                                  // get list of possible tuner gains
+#ifdef NEW_RTLSDR_LIB
+     for(Stages=0; Stages<8; Stages++)
+     { StageGains[Stages]=getTunerStageGains(Stages, StageGain[Stages], StageName[Stages]);
+       if(StageGains[Stages]<=0) break; }
+#endif
+     PrintGains();
+
+#ifdef NEW_RTLSDR_LIB
+     Bandwidths=getTunerBandwidths(Bandwidth);
+     PrintBandwidths();
+#endif
+
+     if(ResetBuffer()<0)                                                                        // reset the buffers (after the manual...)
+     { printf("Cannot reset buffer for device #%d\n", DeviceIndex); }
+     return 1; }
+
+   void PrintGains(void) const
+   {
+#ifdef NEW_RTLSDR_LIB
+     for(int Stage=0; Stage<Stages; Stage++)
+     { printf("RTLSDR::%s[%d] =", StageName[Stage], StageGains[Stage]);
+       for(int Idx=0; Idx<StageGains[Stage]; Idx++) printf(" %+5.1f", 0.1*StageGain[Stage][Idx]); printf(" [dB]\n"); }
+#endif
+     printf("RTLSDR::Gain[%d] =", Gains); for(int Idx=0; Idx<Gains; Idx++) printf(" %+5.1f", 0.1*Gain[Idx]); printf(" [dB]\n"); }
+
+   void PrintBandwidths(void) const
+   { printf("RTLSDR::Bandwidth[%d] =", Bandwidths); for(int Idx=0; Idx<Bandwidths; Idx++) printf(" %5.3f", 1e-6*Bandwidth[Idx]); printf(" [MHz]\n"); }
+
+   double SampleTimeJitter(void) { return sqrt(SampleTime_DMS); }
+
+   static void StaticCallback(unsigned char *Buffer, uint32_t Len, void *Contex)          // callback that receives the data
+   { RTLSDR *This = (RTLSDR *)Contex; return This->ClassCallback(Buffer, Len); }          // "This" points now to this class instance
+
+   void ClassCallback(unsigned char *Buffer, uint32_t Len)                                // callback but already in this class instance
+   { Lock.Lock();
+     int Samples = Len/2;                                                                 // number of samples is half the buffer size
+     BytesRead+=Len;                                                                      // count number of bytes read
+     double ReadTime=getTime();                                                           // read the time at this moment
+/*
+     uint32_t PrevSampleIdx=SampleIdxPipe[PipeWrite];                                     // previous SampleIdx
+     PipeWrite++; if(PipeWrite>=PipeSize) PipeWrite=0;                                    // advance pipe write pointer
+     double FirstSampleTime = SampleTimePipe[PipeRead];
+     uint32_t FirstSampleIdx  = SampleIdxPipe[PipeRead];
+     if(PipeWrite==PipeRead) { PipeRead++; if(PipeRead>=PipeSize) PipeRead=0; }
+     SampleTimePipe[PipeWrite]=ReadTime;                                                  // ReadTime -> Pipe
+     SampleIdxPipe[PipeWrite]=PrevSampleIdx+Samples;                                      // next SampleIdx -> Pipe
+     double   SampleTimeDiff = ReadTime-FirstSampleTime;
+     uint32_t SampleIdxDiff  = (PrevSampleIdx+Samples)-FirstSampleIdx;;
+*/
+     double AcqTime = Samples * SamplePeriod;                                             // time it took to acquire these samples
+     double AverWeight = AcqTime / AverPeriod; // ratio: acquisition period : averaging period
+
+     int Ret=0;
+     if(Callback)
+     { Ret=(*(Callback))(Buffer, Samples,                                 // buffer, number of samples
+                         SampleTime - Samples*SamplePeriod, SamplePeriod, // SampleTime = time of the first sample, SamplePeriod = time period of one sample
+                         CallbackContext);
+     }
+     if(Ret) CancelAsync();                                               // call the user callback, if it returns non-zero, then stop data acquisition
+
+     SampleTime += Samples * SamplePeriod;            // increment predicted time for this batch
+     double TimeDiff = ReadTime - SampleTime;         // difference: time read now versus predicted time
+     SampleTime += 0.125*TimeDiff;                    // follow the ReadTime with weight 1/8 (a bit arbitrary...)
+     SampleTime_DMS += AverWeight * (TimeDiff*TimeDiff - SampleTime_DMS); // integrate the difference RMS
+
+     double PeriodDiff = (ReadTime - PrevTime) - AcqTime; // difference: measured time period to acquire this batch versus predicted time period
+     SamplePeriod += AverWeight*(PeriodDiff/Samples);
+     PrevTime = ReadTime;
+
+     // printf("%14.3f (%+7.3f:%+7.3f ms): RTLSDR::Callback( , %d, ) => %10.1f (%10.1f) samples/sec, %6.3f ms\r",
+     //        ReadTime, 1e3*TimeDiff, 1e3*PeriodDiff, Len, 1.0/SamplePeriod, SampleIdxDiff/SampleTimeDiff, 1e3*SampleTimeJitter() );
+/*
+     char Time[24]; AsciiTime_DDDDDHHMMSSFFF(Time, ReadTime);
+     printf("%s (%+7.3f:%+7.3f ms): RTLSDR::Callback( , %d, ) => %10.1f samples/sec, %6.3f ms\r",
+            Time, 1e3*TimeDiff, 1e3*PeriodDiff, Len, 1.0/SamplePeriod, 1e3*SampleTimeJitter() );
+     fflush(stdout);
+*/
+     Lock.Unlock(); }
+
+   // read in async. mode, call Callback() for the data being received, block, wait and return when Callback() returns non-zero
+   int ReadAsync(int (*Callback)(uint8_t *Buffer, int Samples, double SampleTime, double SamplePeriod, void *Contex)=0, void *Contex=0,
+                 int Buffers=0, int BlockSize=0)
+   { this->Callback = Callback; StartTime=SampleTime=PrevTime=getTime();
+     this->CallbackContext = Contex;
+     // SampleTimePipe[0]=SampleTime; SampleIdxPipe[0]=0; PipeWrite=0; PipeRead=0;
+     return rtlsdr_read_async(Device, StaticCallback, this, Buffers, BlockSize); }
+
+   int CancelAsync(void) { return rtlsdr_cancel_async(Device); }
+
+   // read directly given number of samples (remember to ResetBuffer() !)
+   int Read(uint8_t *Buffer, int Samples)
+   { Samples&=0xFFFFFF00;                 // number of samples must be a multiply of 256
+     int BufferSize = 2*Samples;
+     int ReadSize=0;
+     if(rtlsdr_read_sync(Device, Buffer, BufferSize, &ReadSize)<0) return -1;
+     return ReadSize/2; }
+
+   int Read(SampleBuffer<uint8_t> &Buffer, int Samples)
+   { if(Buffer.Allocate(2,Samples)<=0) return 0;
+     int ReadSamples=Read(Buffer.Data, Samples);
+     double Time = getTime();
+     if(ReadSamples>0)
+     { Buffer.Full=ReadSamples*2;
+       Buffer.Rate=getSampleRate();
+       Buffer.Freq=getCenterFreq();
+       Buffer.Time=Time-(double)ReadSamples/Buffer.Rate; }
+     // printf("RTLSDR::Read( , %d) => %d, %7.3fMHz %14.3fsec\n", Samples, ReadSamples, 1e-6*getCenterFreq(), Buffer.Time );
+     return ReadSamples;
+   }
+
+} ;
+
+// =================================================================================
+
diff --git a/src/serialize.h b/src/serialize.h
new file mode 100644
index 0000000..f442ed9
--- /dev/null
+++ b/src/serialize.h
@@ -0,0 +1,25 @@
+#ifndef __SERIALIZE_H__
+#define __SERIALIZE_H__
+
+#include <stdint.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+
+inline int SerializeWriteSync(int Stream, uint32_t Sync)               { return write(Stream, &Sync, sizeof(uint32_t)); }
+inline int SerializeWriteName(int Stream, const char *Name)            { return write(Stream, Name, strlen(Name)+1); }
+inline int SerializeWriteData(int Stream, const void *Data, int Bytes) { return write(Stream, Data, Bytes); }
+inline int SerializeReadData (int Stream, void *Data, int Bytes)       { return read (Stream, Data, Bytes); }
+
+inline int SerializeWriteSync(FILE *Stream, uint32_t Sync)               { return fwrite(&Sync, 1, sizeof(uint32_t), Stream); }
+inline int SerializeWriteName(FILE *Stream, const char *Name)            { return fwrite(Name,  1, strlen(Name)+1,   Stream); }
+inline int SerializeWriteData(FILE *Stream, const void *Data, int Bytes) { return fwrite(Data,  1, Bytes,            Stream); }
+inline int SerializeReadData (FILE *Stream, void *Data, int Bytes)       { return fread (Data,  1, Bytes,            Stream); }
+
+int SerializeFindSync(int Stream, uint32_t Sync);
+int SerializeReadName(int Stream, char *Name, int MaxBytes);
+
+int SerializeFindSync(FILE *Stream, uint32_t Sync);
+int SerializeReadName(FILE *Stream, char *Name, int MaxBytes);
+
+#endif // __SERIALIZE_H__
diff --git a/src/socket.h b/src/socket.h
new file mode 100644
index 0000000..1c98480
--- /dev/null
+++ b/src/socket.h
@@ -0,0 +1,601 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdio.h>
+
+// =========================================================================================
+
+#ifndef __SOCKET_H__
+#define __SOCKET_H__
+
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+// #include <netinet/ip_icmp.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/sendfile.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <math.h>
+
+#ifdef __MACH__
+#define MSG_NOSIGNAL 0
+#endif
+
+
+class SocketAddress                    // IP address and port
+{ public:
+
+   struct sockaddr_in Address;
+
+  private:
+
+   static const int TmpStringLen = 64;
+   char TmpString[TmpStringLen];
+
+  public:
+
+   SocketAddress()
+     { Init(); }
+
+   void Init(void)
+     { Address.sin_family = AF_INET; setIP(); }
+
+   // set IP and port from an ASCII string: "IP:port", IP can be numeric or a host name
+   int set(const char *HostColonPort)
+     { const char *Colon=strchr(HostColonPort,':');
+       if(Colon==0) return setIP(HostColonPort);
+       int Port; if(sscanf(Colon+1,"%d",&Port)!=1) return -1;
+       if((Port<0)||(Port>0xFFFF)) return -1;
+       setPort((unsigned short)Port);
+       int Len=Colon-HostColonPort; if(Len>=TmpStringLen) return -1;
+       memcpy(TmpString, HostColonPort, Len); TmpString[Len]='\0';
+       int Error = setIP(TmpString);
+       return Error; }
+
+   // set only the IP (includes DNS name resolve)
+   int setIP(const char *AsciiHost)
+     { in_addr_t IP=inet_addr(AsciiHost);
+       if(IP != (in_addr_t)(-1)) { Address.sin_addr.s_addr=IP; return 0; }
+       struct hostent *Host = gethostbyname(AsciiHost); if(Host==0) return -1;
+       char *AddrPtr=Host->h_addr_list[0];              if(AddrPtr==0) return -1;
+       memcpy(&Address.sin_addr, Host->h_addr_list[0],  Host->h_length);
+       return 0; }
+
+   // set the IP from a 32-bit integer
+   int setIP(unsigned long IP=INADDR_ANY)
+     { Address.sin_addr.s_addr = htonl(IP); return 0; }
+
+   // get IP as a 32-bit integer
+   unsigned long getIP(void) const
+     { return ntohl(Address.sin_addr.s_addr); }
+
+   // is the address defined already ?
+   bool isSetup(void) const
+     { return getIP()!=INADDR_ANY; }
+
+   int setBroadcast(void)
+     { Address.sin_addr.s_addr = htonl(INADDR_BROADCAST); return 0; }
+
+   // set the port
+   int setPort(unsigned short Port)
+     { Address.sin_port = htons(Port); return 0; }
+
+   // get the port
+   unsigned short getPort(void) const
+     { return ntohs(Address.sin_port); }
+
+   // get IP as an ASCII string (to print)
+   char *getAsciiIP(void) const
+     { return inet_ntoa(Address.sin_addr); }
+
+   // get my own host name
+   char *getHostName(void) { return getHostName(TmpString, TmpStringLen); }
+
+   static char *getHostName(char *Name, int NameLen)
+     { if(gethostname(Name, NameLen)<0) return 0;
+       return Name; }
+
+   // get the "IP:port" ASCII string, IP will be numeric
+   char *getIPColonPort(void)
+     { char *IP = getAsciiIP(); if(IP==0) return IP;
+       if(strlen(IP)>(TmpStringLen-8)) return 0;
+       unsigned short Port=getPort();
+       sprintf(TmpString, "%s:%d", IP, Port);
+       return TmpString; }
+
+} ;
+
+class SocketBuffer             // data buffer for IP sockets
+{ public:
+
+   char *Data;                 //         data storage
+   size_t Allocated;           // [bytes] allocated
+   size_t Len;                 // [bytes] filled with data
+   size_t Done;                // [bytes] processed
+   static const size_t AllocUnit = 4096; // allocation step
+
+  public:
+
+   SocketBuffer()
+     { Data=0; Allocated=0; Len=0; Done=0; }
+
+   ~SocketBuffer()
+     { Free(); }
+
+   void Free(void)
+     { if(Data) { free(Data); Data=0; }
+       Allocated=0; Len=0; Done=0; }
+
+   size_t Relocate(size_t Size)
+     { if(Size<=Allocated) return Allocated;
+       // printf("Relocate(%d)",Size);
+       size_t Units=(Size+AllocUnit-1)/AllocUnit; Size=Units*AllocUnit;
+       // printf(" => Units=%d, Size=%d\n", Units, Size);
+       Data=(char *)realloc(Data, Size); if(Data==0) Free(); else Allocated=Size;
+       return Allocated; }
+
+   int NullTerm(void)        // put null byte at the end, thus it can be treated as a null-terminated string
+     { if(Relocate(Len+1)<=0) return 0;
+       Data[Len]=0;
+       return Len; }
+
+   void Clear(void)
+     { Len=0; Done=0; }
+
+   bool isDone(void) const   // is all data processed ?
+     { return Done==Len; }
+
+   int Delete(size_t Ofs, size_t DelLen) // delete some part of the data (involves memory move)
+     { if(Ofs>=Len) return 0;
+       if((Ofs+DelLen)>Len) DelLen=Len-Ofs;
+       memcpy(Data+Ofs, Data+Ofs+DelLen, Len-DelLen); Len-=DelLen;
+       Data[Len]=0; return DelLen; }
+
+   int SearchLineTerm(int StartIdx=0) // search for a line terminator: \r or \n
+     { size_t Idx; char Term=0;
+       for( Idx=StartIdx; Idx<Len; Idx++)
+       { Term=Data[Idx];
+         if((Term=='\r')||(Term=='\n')) break; }
+       if(Idx>=Len) return -1;        // return -1 if terminator not found
+       return Idx-StartIdx; }         // return the line length (not including the terminator)
+
+   int ReadFromFile(char *FileName)
+     { FILE *File = fopen(FileName,"r"); if(File==0) return -1;
+       int Total=0;
+       for( ; ; )
+       { if(Relocate(Len+AllocUnit)<0) { fclose(File); return -1; }
+         int ToRead = Allocated-Len;
+         int Read = fread(Data+Len, 1, ToRead, File);
+         if(Read<0) { fclose(File); return -1; }
+         Len+=Read; Total+=Read; if(Read!=ToRead) break;
+       }
+       fclose(File);
+       return Total; }
+
+   int WriteToFile(FILE *File=stdout) const
+     { int ToWrite = Len-Done; if(ToWrite<0) ToWrite=0;
+       int Written = fwrite(Data+Done, 1, ToWrite, File);
+       if(Written<0) return Written;
+       return Written==ToWrite ? Written:-1; }
+
+   int WriteToFile(const char *FileName) const
+     { FILE *File = fopen(FileName,"w"); if(File==0) return -1;
+       int ToWrite = Len-Done; if(ToWrite<0) ToWrite=0;
+       int Written = fwrite(Data+Done, 1, ToWrite, File);
+       fclose(File);
+       if(Written<0) return Written;
+       return Written==ToWrite ? Written:-1; }
+
+// -----------------------------------------------------------------------------
+
+   int LineLen(size_t Ofs=0, size_t MaxLen=256) const
+   { size_t Idx=Ofs;
+     for( ; Idx<Len; Idx++)
+     { char Byte=Data[Idx]; if( (Byte=='\r') || (Byte=='\n') ) break; }
+     return Idx-Ofs; }
+
+   int EOL(size_t Ofs) const
+   { if(Ofs>=Len) return 0;
+     char Byte1=Data[Ofs];
+     if( (Byte1!='\r') && (Byte1!='\n') ) return 0;
+     Ofs++;
+     if(Ofs>=Len) return 1;
+     char Byte2=Data[Ofs];
+     if( (Byte2!='\r') && (Byte2!='\n') ) return 1;
+     if(Byte2==Byte1) return 1;
+     return 2; }
+
+   int getStatus(void) const
+   { char Protocol[16]; int Status=0;
+     int FirstLineLen=LineLen(0, 128);
+     if(FirstLineLen<=8) return -1;
+     if(FirstLineLen>=128) return -1;
+     if(sscanf(Data, "%s %d", Protocol, &Status)!=2) return -1;
+     return Status; }
+
+   int getHeaderLen(void) const
+   { size_t Idx=0;
+     for( ; ; )
+     { int Len=LineLen(Idx);
+       int TermLen=EOL(Idx+Len);
+       Idx+=Len+TermLen;
+       if(Len==0) break; }
+     return Idx; }
+
+   int FindTag(const char *Tag, size_t Ofs=0)
+   { size_t TagLen=strlen(Tag);
+     for(size_t Idx=Ofs; Idx<Len; Idx++)
+     { char Byte=Data[Idx]; if(Byte!='<') continue;
+       if((Idx+1+TagLen)>=Len) return -1;
+       if(memcmp(Tag, Data+Idx+1, TagLen)==0) return Idx-Ofs; }
+     return -1; }
+
+   int TagLen(size_t Ofs=0) const
+   { for(size_t Idx=Ofs+1; Idx<Len; Idx++)
+     { char Byte=Data[Idx]; if(Byte=='>') return Idx-Ofs+1; }
+     return -1; }
+
+// -----------------------------------------------------------------------------
+
+} ;
+
+class Socket                   // IP socket
+{ public:
+
+   int SocketFile;
+   // unsigned long BytesSent, BytesReceived;
+
+  public:
+
+   Socket()
+     { SocketFile=(-1); }
+
+   ~Socket()
+     { Close(); }
+
+   // create a socket
+   int Create(int Type=SOCK_STREAM, int Protocol=IPPROTO_TCP)
+     { Close();
+       SocketFile=socket(PF_INET, Type, Protocol);
+       return SocketFile; }
+   int Create_STREAM(void) { return Create(SOCK_STREAM, IPPROTO_TCP); }
+   int Create_DGRAM(void) { return Create(SOCK_DGRAM, 0); }
+
+   int Copy(int NewSocketFile)
+     { Close();
+       return SocketFile=NewSocketFile; }
+
+   // set connect/read/write to be blocking or not
+   int setBlocking(int Block=1)
+     { int Flags = fcntl(SocketFile,F_GETFL,0);
+       if(Block) Flags &= ~O_NONBLOCK;
+            else Flags |=  O_NONBLOCK;
+       return fcntl(SocketFile,F_SETFL,Flags); }
+
+   int setNonBlocking(void)
+     { return setBlocking(0); }
+
+   // avoids waiting (in certain cases) till the socket closes completely after the previous server exits
+   int setReuseAddress(int Set=1)
+     { return setsockopt(SocketFile, SOL_SOCKET, SO_REUSEADDR, &Set, sizeof(Set)); }
+
+   int setKeepAlive(int KeepAlive=1) // keep checking if connection alive while no data is transmitted
+     { return setsockopt(SocketFile, SOL_SOCKET, SO_KEEPALIVE, &KeepAlive, sizeof(KeepAlive)); }
+
+   int setLinger(int ON, int Seconds) // gracefull behavior on socket close
+     { struct linger Linger; Linger.l_onoff=ON; Linger.l_linger=Seconds;
+       return setsockopt(SocketFile, SOL_SOCKET, SO_LINGER, &Linger, sizeof(Linger)); }
+
+   int setNoDelay(int ON=1)
+   { return setsockopt(SocketFile, IPPROTO_TCP, TCP_NODELAY, &ON, sizeof(ON)); }
+
+   int setSendBufferSize(int Bytes)
+     { return setsockopt(SocketFile, SOL_SOCKET, SO_SNDBUF, &Bytes, sizeof(Bytes)); }
+
+   int getSendBufferSize(void)
+     { int Bytes=0; socklen_t Size;
+       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_SNDBUF, &Bytes, &Size);
+       return Error<0 ? -1:Bytes; }
+
+   int setReceiveBufferSize(int Bytes)
+     { return setsockopt(SocketFile, SOL_SOCKET, SO_RCVBUF, &Bytes, sizeof(Bytes)); }
+
+   int getReceiveBufferSize(void)
+     { int Bytes=0; socklen_t Size;
+       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_RCVBUF, &Bytes, &Size);
+       return Error<0 ? -1:Bytes; }
+
+/* on Cygwin send and receive timeouts seem to have no effect ...
+#ifdef __WINDOWS__
+   int setReceiveTimeout(double Seconds) // a blocking receive() will not wait forever
+   { long Time = (long)floor(1000*Seconds+0.5);
+     return setsockopt(SocketFile, SOL_SOCKET, SO_RCVTIMEO, &Time, sizeof(Time)); }
+
+   int setSendTimeout(double Seconds)   // a blocking send() will not wait forever
+   { long Time = (long)floor(1000*Seconds+0.5);
+      return setsockopt(SocketFile, SOL_SOCKET, SO_SNDTIMEO, &Time, sizeof(Time)); }
+#endif
+*/
+
+#ifdef __CYGWIN__  // dummy routine for Cygwin, only to satify the compiler
+   int setReceiveTimeout(double Seconds) { return -1; }
+   int setSendTimeout(double Seconds) { return -1; }
+#else
+   int setReceiveTimeout(double Seconds) // a blocking receive() will not wait forever
+     { struct timeval Time;
+       Time.tv_sec  = (long)floor(Seconds);
+       Time.tv_usec = (long)floor(1000000*(Seconds-Time.tv_sec)+0.5);
+       return setsockopt(SocketFile, SOL_SOCKET, SO_RCVTIMEO, &Time, sizeof(Time)); }
+
+   int setSendTimeout(double Seconds)   // a blocking send() will not wait forever
+     { struct timeval Time;
+       Time.tv_sec  = (long)floor(Seconds);
+       Time.tv_usec = (long)floor(1000000*(Seconds-Time.tv_sec)+0.5);
+       return setsockopt(SocketFile, SOL_SOCKET, SO_SNDTIMEO, &Time, sizeof(Time)); }
+#endif
+
+#if defined(__MACH__) || defined(__CYGWIN__)
+#else
+   int getMTU(void)
+     { int Bytes;
+       if(ioctl(SocketFile, SIOCGIFMTU, &Bytes)<0) return -1;
+       return Bytes; }
+#endif
+
+   int getReceiveQueue(void)
+     { int Bytes;
+       if(ioctl(SocketFile, FIONREAD, &Bytes)<0) return -1;
+       return Bytes; }
+
+   int getError(void)
+     { int ErrorCode=0;
+       socklen_t Size=sizeof(ErrorCode);
+       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_ERROR, &ErrorCode, &Size);
+       return Error<0 ? -1:ErrorCode; }
+
+   int isListenning(void)
+     { int Yes=0;
+       socklen_t Size=sizeof(Yes);
+       int Error=getsockopt(SocketFile, SOL_SOCKET, SO_ACCEPTCONN, &Yes, &Size);
+       return Error<0 ? -1:Yes; }
+
+   // listen for incoming UDP connections (become a UDP server)
+   int Listen_DGRAM(unsigned short ListenPort)
+     { if(SocketFile<0) { if(Create_DGRAM()<0) return -1; }
+
+       setReuseAddress(1);
+
+       struct sockaddr_in ListenAddress;
+       ListenAddress.sin_family      = AF_INET;
+       ListenAddress.sin_addr.s_addr = htonl(INADDR_ANY);
+       ListenAddress.sin_port        = htons(ListenPort);
+
+       if(bind(SocketFile, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress))<0)
+       { Close(); return -1; }
+
+       return 0; }
+
+   // listen for incoming TCP connections (become a TCP server)
+   int Listen(unsigned short ListenPort, int MaxConnections=8)
+     { if(SocketFile<0) { if(Create()<0) return -1; }
+
+       setReuseAddress(1);
+
+       struct sockaddr_in ListenAddress;
+       ListenAddress.sin_family      = AF_INET;
+       ListenAddress.sin_addr.s_addr = htonl(INADDR_ANY);
+       ListenAddress.sin_port        = htons(ListenPort);
+
+       if(bind(SocketFile, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress))<0)
+       { Close(); return -1; }
+
+       if(listen(SocketFile, MaxConnections)<0)
+       { Close(); return -1; }
+
+       return 0; }
+
+   // accept a new client (when being a server)
+   int Accept(Socket &ClientSocket, SocketAddress &ClientAddress)
+     { ClientSocket.Close();
+       socklen_t ClientAddressLength=sizeof(ClientAddress.Address);
+       return ClientSocket.SocketFile=accept(SocketFile, (struct sockaddr *) &(ClientAddress.Address), &ClientAddressLength); }
+
+   // connect to a remote server
+   int Connect(SocketAddress &ServerAddress)
+     { if(SocketFile<0) { if(Create_STREAM()<0) return -1; } // if no socket yet, create a STREAM-type one.
+       socklen_t ServerAddressLength=sizeof(ServerAddress.Address);
+       return connect(SocketFile, (struct sockaddr *) &(ServerAddress.Address), ServerAddressLength); }
+
+   // send data (on a connected socket)
+   int Send(void *Message, int Bytes, int Flags=MSG_NOSIGNAL)
+     { return send(SocketFile, Message, Bytes, Flags); }
+
+   int Send(const char *Message)
+     { return Send((void *)Message, strlen(Message)); }
+
+   int Send(SocketBuffer &Buffer, int Flags=MSG_NOSIGNAL)
+     { size_t Bytes = Buffer.Len-Buffer.Done; // if(Bytes>4096) Bytes=4096;
+       int SentBytes=Send(Buffer.Data+Buffer.Done, Bytes, Flags);
+       if(SentBytes>0) Buffer.Done+=SentBytes;
+       return SentBytes; }
+
+   int SendFile(const char *FileName)
+   { int File=open(FileName, O_RDONLY); if(File<0) return File;
+     struct stat Stat; fstat(File, &Stat); int Size=Stat.st_size;
+     int Ret=sendfile(SocketFile, File, 0, Size);
+     close(File);
+     return Ret; }
+
+   // send data (on a non-connected socket)
+   int SendTo(const void *Message, int Bytes, SocketAddress Address, int Flags=MSG_NOSIGNAL)
+     { socklen_t AddressLength=sizeof(Address.Address);
+       return sendto(SocketFile, Message, Bytes, Flags, (struct sockaddr *) &(Address.Address), AddressLength); }
+
+   int SendTo(const void *Message, int Bytes, int Flags=MSG_NOSIGNAL)
+     { return sendto(SocketFile, Message, Bytes, Flags, 0, 0); }
+
+   // say: I won't send any more data on this connection
+   int SendShutdown(void)
+     { return shutdown(SocketFile, SHUT_WR); }
+
+#ifndef __CYGWIN__ // Cygwin C++ does not know abour TIOCOUTQ ?
+   int getSendQueue(void)
+     { int Bytes;
+       ioctl(SocketFile, TIOCOUTQ, &Bytes);
+       return Bytes; }
+#endif
+
+   // receive data (on a stream socket)
+   int Receive(void *Message, int MaxBytes, int Flags=MSG_NOSIGNAL)
+     { int Len=recv(SocketFile, Message, MaxBytes, Flags);
+       if(Len>=0) return Len;
+       return errno==EWOULDBLOCK ? 0:Len; }
+
+   // receive (stream) data into a buffer
+   int Receive(SocketBuffer &Buffer, int Flags=MSG_NOSIGNAL)
+     { size_t NewSize=Buffer.Len+Buffer.AllocUnit/2;
+       size_t Allocated=Buffer.Relocate(NewSize);
+       int MaxBytes=Allocated-Buffer.Len-1;
+       int ReceiveBytes=Receive(Buffer.Data+Buffer.Len, MaxBytes, Flags);
+       // printf("Allocated = %d, Receive(%d) => %d\n", Allocated, MaxBytes, ReceiveBytes);
+       if(ReceiveBytes>0) { Buffer.Len+=ReceiveBytes; Buffer.Data[Buffer.Len]=0; }
+       return ReceiveBytes; }
+
+   // receive data (on a non-connected socket)
+   int ReceiveFrom(void *Message, int MaxBytes, SocketAddress &Address, int Flags=MSG_NOSIGNAL)
+     { socklen_t AddressLength=sizeof(Address.Address);
+       return recvfrom(SocketFile, Message, MaxBytes, Flags, (struct sockaddr *) &(Address.Address), &AddressLength); }
+
+   // tell if socket is open
+   int isOpen(void)
+     { return SocketFile>=0; }
+
+   // close the socket
+   int Close(void)
+     { if(SocketFile>=0) close(SocketFile);
+       SocketFile=(-1); return 0; }
+
+   // get the local IP and port
+   int getLocalAddress(SocketAddress &Address)
+     { socklen_t AddressLength=sizeof(Address.Address);
+       return getsockname(SocketFile, (struct sockaddr *) &(Address.Address), &AddressLength); }
+
+   // get the remote IP and port
+   int getRemoteAddress(SocketAddress &Address)
+     { socklen_t AddressLength=sizeof(Address.Address);
+       return getpeername(SocketFile, (struct sockaddr *) &(Address.Address), &AddressLength); }
+
+   static void CopyNetToHost(uint32_t *Dst, uint32_t *Src, int Words)
+   { for( ; Words; Words--) (*Dst++) = ntohl(*Src++); }
+
+   static void CopyHostoNet(uint32_t *Dst, uint32_t *Src, int Words)
+   { for( ; Words; Words--) (*Dst++) = htonl(*Src++); }
+
+} ;
+
+class UDP_Sender
+{ public:
+   Socket Sock;
+   const static int MaxDest = 4;
+   SocketAddress Dest[MaxDest];
+
+  public:
+   void ClearDest(void)                                                     // clear the list of destination IP's
+   { for(int Idx=0; Idx<MaxDest; Idx++)
+     { Dest[Idx].setIP((long unsigned int)0); }
+   }
+
+   int Open(void)           { ClearDest(); return Sock.Create_DGRAM(); }
+   int Close(void)          { return Sock.Close(); }
+   int setNonBlocking(void) { return Sock.setNonBlocking(); }
+
+   int addDest(const char *Addr)
+   { for(int Idx=0; Idx<MaxDest; Idx++)
+     { if(Dest[Idx].getIP()==0)
+       { if(Dest[Idx].set(Addr)<0) return -1;
+         return Idx; }
+     }
+     return -1; }
+/*
+   int addBroadcast(void)
+   { int Idx;
+     for( Idx=0; Idx<MaxDest; Idx++)
+     { if(Dest[Idx].getIP()==0)
+       { if(Dest[Idx].SetIP(INADDR_BROADCAST)<0) return -1;
+         return Idx; }
+     }
+     return -1; }
+*/
+   void PrintDest(void)
+   { printf("Dest[] =");
+     for(int Idx=0; Idx<MaxDest; Idx++)
+     { if(Dest[Idx].getIP()==0) continue;
+       printf(" %s", Dest[Idx].getIPColonPort()); }
+     printf("\n");
+   }
+
+   int Send(uint32_t *Msg, int Words)
+   { return Send((void *)Msg, Words*sizeof(uint32_t)); }
+
+   int Send(void *Msg, int Bytes)
+   { int Count=0;
+     for( int Idx=0; Idx<MaxDest; Idx++)
+     { if(Dest[Idx].getIP()==0) continue;
+       if(Sock.SendTo(Msg, Bytes, Dest[Idx])<0) continue;
+       Count++; }
+     return Count; }
+
+   int Receive(void *Msg, int MaxBytes, SocketAddress &Source)
+   { return Sock.ReceiveFrom(Msg, MaxBytes, Source); }
+
+} ;
+
+class UDP_Receiver
+{ public:
+   Socket Sock;
+
+  public:
+   int Open(int Port)       { return Sock.Listen_DGRAM(Port); }
+   int Close(void)          { return Sock.Close(); }
+   int setNonBlocking(void) { return Sock.setNonBlocking(); }
+   // int getPort(void) const  { return Sock.}
+
+   int Receive(void *Msg, int MaxBytes, SocketAddress &Source)
+   { return Sock.ReceiveFrom(Msg, MaxBytes, Source); }
+
+   int Receive(uint32_t *Msg, int MaxWords, SocketAddress &Source)
+   { int Words=Sock.ReceiveFrom(Msg, MaxWords*sizeof(uint32_t), Source);
+     return Words<0 ? Words:Words/sizeof(uint32_t); }
+
+} ;
+
+#endif // of __SOCKET_H__
+
+// =========================================================================================
+
diff --git a/src/sysmon.h b/src/sysmon.h
new file mode 100644
index 0000000..4cb1d2a
--- /dev/null
+++ b/src/sysmon.h
@@ -0,0 +1,142 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <time.h>
+
+#if !defined(__MACH__)   // OSX and Cygwin have no ntp_ calls
+#include <sys/sysinfo.h>
+#if !defined(__CYGWIN__)
+#include <sys/time.h>
+#include <sys/timex.h>
+#endif
+#endif
+
+// ===================================================================================================
+
+int getMemoryUsage(int &Total, int &Free) // get total and free RAM [kB]
+{ FILE *File=fopen("/proc/meminfo","rt"); if(File==0) return -1;
+  char Line[64];
+  if(fgets(Line, 64, File)==0) goto Error;
+  if(memcmp(Line, "MemTotal:", 9)!=0) goto Error;
+  Total = atoi(Line+10);
+  if(fgets(Line, 64, File)==0) goto Error;
+  if(memcmp(Line, "MemFree:", 8)!=0) goto Error;
+  Free = atoi(Line+10);
+  fclose(File); return 0;
+Error:
+  fclose(File); return -1; }
+template <class Float>
+ int getMemoryUsage(Float &Used) // get used RAM as a ratio
+{ int Total, Free;
+  int Error = getMemoryUsage(Total, Free); if(Error<0) return Error;
+  Used = (Float)(Total-Free)/Total; return 0; }
+
+// ===================================================================================================
+
+int getCpuUsage(int &DiffTotal, int &DiffUser, int &DiffSystem) // get CPU usage
+{ static int RefTotal=0, RefUser=0, RefSystem=0;
+  FILE *File=fopen("/proc/stat","rt"); if(File==0) return -1;
+  char Line[64];
+  if(fgets(Line, 64, File)==0) goto Error;
+  if(memcmp(Line, "cpu ", 4)!=0) goto Error;
+  int Total, User, Nice, System, Idle;
+  if(sscanf(Line+4, "%d %d %d %d", &User, &Nice, &System, &Idle)!=4) goto Error;
+  User+=Nice;
+  Total = User+System+Idle;
+  DiffTotal=Total-RefTotal; DiffUser=User-RefUser; DiffSystem=System-RefSystem;
+  RefTotal=Total; RefUser=User; RefSystem=System;
+  fclose(File); return 0;
+Error:
+  fclose(File); return -1; }
+
+int getCpuUsage(void)                       // get CPU usage - initialize
+{ int DiffTotal, DiffUser, DiffSystem; return getCpuUsage(DiffTotal, DiffUser, DiffSystem); }
+
+int getCpuUsage(float &User, float &System) // get CPU usage as ratios
+{ int DiffTotal, DiffUser, DiffSystem;
+  int Error=getCpuUsage(DiffTotal, DiffUser, DiffSystem); if(Error<0) return Error;
+  if(DiffTotal<=0) return -1;
+  User = (float)DiffUser/DiffTotal; System = (float)DiffSystem/DiffTotal; return 0; }
+
+// ===================================================================================================
+
+template <class Type>
+ int getSysValue(Type &Value, const char *Name, const char *Format="%d")
+{ FILE *File=fopen(Name, "rt"); if(File==0) return -1;
+  int Ret=fscanf(File, Format, &Value);
+  fclose(File); return (Ret==1) ? 1:-2; }
+
+template <class Float>
+ int getCpuTemperature(Float &Temperature)
+{ int IntValue;
+  if(getSysValue(IntValue, "/sys/class/thermal/thermal_zone0/temp", "%d")<0)
+  { if(getSysValue(IntValue, "/sys/class/hwmon/hwmon0/device/temp1_input", "%d")<0) return -1; }
+  Temperature=0.001*IntValue; return 0; }
+
+template <class Float>
+ int getSupplyVoltage(Float &Voltage)
+{ int IntValue;
+  if(getSysValue(IntValue, "/sys/class/power_supply/ac/voltage_now", "%d")<0) return -1;
+  Voltage = 1e-6*IntValue; return 0; }
+
+template <class Float>
+ int getSupplyCurrent(Float &Current)
+{ int IntValue;
+  if(getSysValue(IntValue, "/sys/class/power_supply/ac/current_now", "%d")<0) return -1;
+  Current = 1e-6*IntValue; return 0; }
+
+/*
+template <class Float>
+ int getCpuTemperature(Float &Temperature)
+{ FILE *File=fopen("/sys/class/thermal/thermal_zone0/temp","rt"); if(File==0) return -1;
+  char Line[16];
+  if(fgets(Line, 16, File)==0) goto Error;
+  Temperature = 0.001*atoi(Line);
+  fclose(File); return 0;
+Error:
+  fclose(File); return -1; }
+*/
+// ===================================================================================================
+
+#if defined(__MACH__) || defined(__CYGWIN__) // for OSX we cannot read NTP status
+
+template <class Float>
+ int getNTP(Float &Time, Float &EstError, Float &RefFreqCorr) { return -1; }
+
+#else
+template <class Float>
+ int getNTP(Float &Time, Float &EstError, Float &RefFreqCorr)
+{ struct timex TimeX; TimeX.modes=0;
+  int Error=ntp_adjtime(&TimeX);
+  if(TimeX.status&STA_NANO)
+    Time = TimeX.time.tv_sec + 1e-9*TimeX.time.tv_usec;
+  else
+    Time = TimeX.time.tv_sec + 1e-6*TimeX.time.tv_usec;
+  EstError = 1e-6*TimeX.esterror;
+  RefFreqCorr = (Float)TimeX.freq/(1<<16);
+  return Error; }
+
+#endif // of __MACH__
+
+// ===================================================================================================
diff --git a/src/thread.h b/src/thread.h
new file mode 100644
index 0000000..49dda0a
--- /dev/null
+++ b/src/thread.h
@@ -0,0 +1,263 @@
+/*
+    OGN - Open Glider Network - http://glidernet.org/
+    Copyright (c) 2015 The OGN Project
+
+    A detailed list of copyright holders can be found in the file "AUTHORS".
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this software.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef __THREAD_H__
+#define __THREAD_H__
+
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <time.h>
+
+#include <pthread.h>
+#include <errno.h>
+
+#include <queue>
+
+// ======================================================================================
+
+class MutEx   // for Mutual Exclusive access to a resource
+{ private:
+   pthread_mutex_t muLock;
+
+  public:
+   MutEx() { Init(); }
+  ~MutEx() { Destroy(); }
+
+  private:
+   int Init(void)     { return pthread_mutex_init(&muLock, 0); }
+   int Destroy(void)  { return pthread_mutex_destroy(&muLock); }
+
+  public:
+   int Lock(void)     { return pthread_mutex_lock(&muLock); }        // gain access to the object (can block)
+   int Unlock(void)   { return pthread_mutex_unlock(&muLock); }      // release the access to the object
+   int TryLock(void)  { int Err=pthread_mutex_lock(&muLock);         // non-blocking attempt to lock
+                        return Err==EBUSY ? 1:Err; }                 // 0 => lock succesfull, 1 => already locked by someone
+} ;
+
+// ======================================================================================
+
+class Condition
+{ private:
+   pthread_cond_t      sigCond;
+   pthread_condattr_t  Attr;
+   pthread_mutex_t     muLock;
+
+ public:
+  Condition() { Init(); }
+ ~Condition() { Destroy(); }
+
+  private:
+   int Init(void)     { pthread_condattr_init(&Attr);
+#ifndef __MACH__ // _POSIX_TIMERS
+                        pthread_condattr_setclock( &Attr, CLOCK_MONOTONIC); // use monotonic clock for timed wait
+#endif
+                        if(pthread_cond_init(&sigCond, &Attr)!=0) return -1;
+                        return pthread_mutex_init(&muLock, 0); }
+   int Destroy(void)  { int Err=pthread_mutex_destroy(&muLock); if(Err!=0) return Err;
+                            Err=pthread_cond_destroy(&sigCond); if(Err!=0) return Err;
+                        pthread_condattr_destroy(&Attr); return 0; }
+
+  public:
+   int Lock(void)      { return pthread_mutex_lock(&muLock); }           // gain access to the object (can block)
+   int Unlock(void)    { return pthread_mutex_unlock(&muLock); }         // release the access to the object
+   int TryLock(void)   { int Err=pthread_mutex_lock(&muLock);            // non-blocking attempt to lock
+                         return Err==EBUSY ? 1:Err; }                    // 0 => lock succesfull, 1 => already locked by someone
+
+   int Signal(void)    { return pthread_cond_signal(&sigCond); }         // signal to at least one thread, that something has changed
+   int Broadcast(void) { return pthread_cond_broadcast(&sigCond); }      // signal to all threads, that something has changed
+   int Wait(void)      { return pthread_cond_wait(&sigCond, &muLock); }  // wait for a signal (can block)
+                                                                         // mutex must be locked while waiting
+#ifndef __MACH__ // _POSIX_TIMERS       // OSX has no clock_gettime() thus we need a different code here
+   int TimedWait(int usec)                                              // wait, but no longer than [usec]
+   { timespec Now; clock_gettime(CLOCK_MONOTONIC, &Now);
+                               // printf("clock_gettime(%ld.%06ld)\n", (long)(Now.tv_sec), (long)(Now.tv_nsec) );
+     timespec StopTime;
+     int sec=usec/1000000; usec-=sec*1000000; int nsec=usec*1000;
+                               // printf("%ld.%06ld = %ld.%09ld\n", sec, usec, sec, nsec);
+     StopTime.tv_sec  = Now.tv_sec  + sec;
+     StopTime.tv_nsec = Now.tv_nsec + nsec;
+     if(StopTime.tv_nsec>1000000000) { StopTime.tv_nsec-=1000000000; StopTime.tv_sec+=1; }
+                               // printf("StopTime = %ld.%09ld\n", (long)(StopTime.tv_sec), (long)(StopTime.tv_nsec));
+     return TimedWait(StopTime); }
+   int TimedWait(struct timespec &StopTime)                              // wait, but wakeup no later than [StopTime]
+   { return pthread_cond_timedwait(&sigCond, &muLock, &StopTime); }
+#endif
+
+} ;
+
+// ======================================================================================
+
+template <class Type>
+ class MessageQueue
+{ public:
+   std::queue<Type> Queue;
+   Condition        Cond;
+
+  public:
+
+   int Push(Type Msg)
+   { Cond.Lock();
+     Queue.push(Msg); int Size=Queue.size();
+     Cond.Unlock();
+     Cond.Signal(); return Size; }
+
+   int Pop(Type &Msg)
+   { Cond.Lock();
+     while(Queue.empty()) Cond.Wait();
+     Msg = Queue.front();
+     Queue.pop(); int Size=Queue.size();
+     Cond.Unlock(); return Size; }
+
+   int Size(void)
+   { Cond.Lock();
+     int size = Queue.size();
+     Cond.Unlock();
+     return size; }
+
+} ;
+
+template <class Type>
+ class ReuseObjectQueue           // this object queue holds objects
+{ public:                         // that can be reused - thus don't need to be created and deleted all the time
+   std::queue<Type *> Queue;      // objects in the queue
+   std::queue<Type *> Reuse;      // objects to be reused, these can be queued again
+   Condition          Cond;
+
+  public:
+
+  ~ReuseObjectQueue()
+   { while(!Queue.empty()) { delete Queue.front(); Queue.pop(); }
+     while(!Reuse.empty()) { delete Reuse.front(); Reuse.pop(); }
+   }
+
+   Type *New(void)                // vreate new object
+   { Cond.Lock();
+     Type *Obj;
+     if(Reuse.empty())
+     { Obj = new Type; }
+     else                         // but if possible take one from the Reuse queue
+     { Obj = Reuse.front(); Reuse.pop(); }
+     Cond.Unlock();
+     return Obj; }
+
+   void Push(Type *Obj)
+   { Cond.Lock();
+     Queue.push(Obj);
+     Cond.Unlock();
+     Cond.Signal(); }
+
+   Type *Pop(void)
+   { Cond.Lock();
+     while(Queue.empty()) Cond.Wait();
+     Type *Obj = Queue.front(); Queue.pop();
+     Cond.Unlock(); return Obj; }
+
+   void Recycle(Type *Obj)
+   { Cond.Lock();
+     Reuse.push(Obj);
+     Cond.Unlock();
+     Cond.Signal(); }
+
+   int Size(void)
+   { Cond.Lock();
+     int size = Queue.size();
+     Cond.Unlock();
+     return size; }
+
+} ;
+
+// ======================================================================================
+
+class Lock    // for multiple read-access and exclusive write-access to a resource
+{ private:
+   pthread_rwlock_t rwLock;
+
+  public:
+   Lock() { Init(); }
+  ~Lock() { Destroy(); }
+
+   int Init(void)     { return pthread_rwlock_init(&rwLock, 0); }
+   int Destroy(void)  { return pthread_rwlock_destroy(&rwLock); }
+
+   int ReadLock(void)  { return pthread_rwlock_rdlock(&rwLock); } // lock for read-only
+   int WriteLock(void) { return pthread_rwlock_wrlock(&rwLock); } // lock for read-write
+   int Unlock(void)    { return pthread_rwlock_unlock(&rwLock); } // unlock
+
+} ;
+
+// ======================================================================================
+
+class Thread
+{ private:
+   pthread_t ID;
+   void *(*Exec)(void *Context);
+
+  public:
+   Thread( void *(*Function)(void *) = 0) { ID=0; setExec(Function); }
+
+   void setExec( void *(*Function)(void *)) { Exec=Function; } // set the function to run by this thread
+
+   int Create(void *Context=0)                                 // create (start) this thread
+   { if(Exec==0) return -1;                                    // Exec function not set
+     if(ID) return -1;                                         // ID non-zero - a thread is running ?
+     return pthread_create(&ID, 0, Exec, Context); }
+
+   int Join(void)
+   { void *ExitStatus;
+     if(ID==0) return -1;                                      // ID zero - a thread is not running anymore ?
+     int Ret=pthread_join(ID, &ExitStatus);
+     ID=0; return Ret; }
+   int Join(void *&ExitStatus)                                 // wait for the thread to terminate
+   { if(ID==0) return -1;                                      // ID zero - a thread is NOT running anymore ?
+     int Ret=pthread_join(ID, &ExitStatus);                    // give back its termination status
+     ID=0; return Ret; }                                       // not clear how to behave if an error occures.
+
+   int Cancel(void)                                            // request to cancel the thread
+   { if(ID==0) return -1;                                      // ID zero - a thread is NOT running anymore ?
+     return pthread_cancel(ID); }
+
+   int getMaxPriority(int Policy=SCHED_FIFO)
+   { return sched_get_priority_max(Policy); }
+
+   int setPriority(int Priority, int Policy=SCHED_FIFO)
+   { struct sched_param params; params.sched_priority = Priority;
+     return pthread_setschedparam(ID, Policy, &params); }
+
+   int setPriority(int &Priority, int &Policy)
+   { struct sched_param params;
+     int Error=pthread_getschedparam(ID, &Policy, &params);
+     if(Error>=0) Priority=params.sched_priority;
+     return Error; }
+
+// ------------------------------------------------------------------------------------
+                                    // the following calls are by the running thread:
+   static int CancelEnable(void)                               // I CAN be cancelled
+   { int Old; return pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &Old); }
+   static int CancelDisable(void)                              // I CAN NOT be cancelled
+   { int Old; return pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &Old); }
+   static void TestCancel(void)                                // test, if I was cancelled
+   { pthread_testcancel(); }                                   // if I was: terminate
+
+} ;
+
+// ======================================================================================
+
+#endif // of __THREAD_H__
diff --git a/src/tonefilter.h b/src/tonefilter.h
new file mode 100644
index 0000000..cb490c8
--- /dev/null
+++ b/src/tonefilter.h
@@ -0,0 +1,91 @@
+#include <string.h>
+
+#include "buffer.h"
+#include "boxfilter.h"
+
+template <class Float>
+ class ToneFilter
+{ public:
+   int              FFTsize;
+   double           Threshold;
+
+   DFT1d<Float>     FwdFFT;
+   DFT1d<Float>     BwdFFT;
+   Float           *Window;
+   Float           *Sort;
+
+   SampleBuffer< std::complex<Float> > SpectraBuffer;
+   SampleBuffer<Float>                 SpectraPwr;
+
+   const static int PulseBoxRadius = 17;
+   const static int PulseBoxSize = 2*PulseBoxRadius+1;
+   BoxPeakSum<Float> PulseBox;
+
+   int Pulses;
+   Float Duty;
+
+  public:
+
+   ToneFilter() { PulseBox.Preset(PulseBoxSize);
+                  FFTsize=32768; Window=0; Sort=0; Duty=0; }
+
+  ~ToneFilter() { if(Window) free(Window);
+                  if(Sort)   free(Sort); }
+
+   int Preset(void)
+   { FwdFFT.PresetForward(FFTsize);
+     BwdFFT.PresetBackward(FFTsize);
+     Window=(Float *)realloc(Window, FFTsize*sizeof(Float));
+     Sort  =(Float *)realloc(Sort,   FFTsize*sizeof(Float));
+     FwdFFT.SetSineWindow(Window, FFTsize, (Float)(1.0/sqrt(FFTsize)) );
+     return 1; }
+
+   int Process(SampleBuffer< std::complex<Float> > *OutBuffer, SampleBuffer<uint8_t> *InpBuffer)
+   { Pulses=0;
+     SlidingFFT(SpectraBuffer, *InpBuffer, FwdFFT, Window);   // Process input samples, produce FFT spectra
+     SpectraPower(SpectraPwr, SpectraBuffer);                 // calculate spectra power
+                                                                // process spectra: remove coherent signals
+     int FFTslides = SpectraBuffer.Samples();                 // number of FFT slides in the input spectra
+     std::complex<Float> *Spectra = SpectraBuffer.Data;
+                  Float  *Pwr     = SpectraPwr.Data;
+     for(int Slide=0; Slide<FFTslides; Slide++)               // loop over FFT slides (or time)
+     { Pulses+=Process(Spectra, Pwr); Spectra+=FFTsize; Pwr+=FFTsize; }
+
+     ReconstrFFT(*OutBuffer, SpectraBuffer, BwdFFT, Window);  // reconstruct input samples
+     OutBuffer->Crop(FFTsize/2, FFTsize/2);
+     return Pulses; }
+/*
+     int Process(std::complex<Float> *Spectra, Float *Pwr)
+     { int Pulses=0;
+       memcpy(Sort, Pwr, FFTsize*sizeof(Float));
+       std::nth_element(Sort, Sort+FFTsize/2, Sort+FFTsize);
+       Float Median = Sort[FFTsize/2];
+       Float Thres = Threshold*Median;
+       for(int Bin=0; Bin<FFTsize; Bin++)                     // loop over frequency bins
+       { Float Power = Pwr[Bin];
+         if(Power>Thres) Spectra[Bin]*=sqrt(Thres/Power);
+         Pulses++; }
+       return Pulses; }
+*/
+     int Process(std::complex<Float> *Spectra, Float *Pwr)
+     { PulseBox.Clear();
+       int Pulses=0;
+       int Bin;
+       for(Bin=0; Bin<PulseBoxSize; Bin++)
+       { PulseBox.Process(Pwr[Bin]); }
+       for(     ; Bin<FFTsize;      Bin++)
+       { if(PulseBox.isAtPeak())
+         { Float PeakAmpl=PulseBox.PeakSum(1);
+           Float BkgNoise=(PulseBox.Sum-PeakAmpl)/(PulseBoxSize-3);
+           if(PeakAmpl>(Threshold*BkgNoise))
+           { int PeakBin=Bin-PulseBoxRadius-1;
+             Spectra[PeakBin]=0;
+             Spectra[PeakBin+1]*=0.5;
+             Spectra[PeakBin-1]*=0.5; }
+         }
+         PulseBox.Process(Pwr[Bin]); }
+       return Pulses; }
+
+
+} ;
+
diff --git a/sysmon.h b/sysmon.h
deleted file mode 100644
index 4cb1d2a..0000000
--- a/sysmon.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <time.h>
-
-#if !defined(__MACH__)   // OSX and Cygwin have no ntp_ calls
-#include <sys/sysinfo.h>
-#if !defined(__CYGWIN__)
-#include <sys/time.h>
-#include <sys/timex.h>
-#endif
-#endif
-
-// ===================================================================================================
-
-int getMemoryUsage(int &Total, int &Free) // get total and free RAM [kB]
-{ FILE *File=fopen("/proc/meminfo","rt"); if(File==0) return -1;
-  char Line[64];
-  if(fgets(Line, 64, File)==0) goto Error;
-  if(memcmp(Line, "MemTotal:", 9)!=0) goto Error;
-  Total = atoi(Line+10);
-  if(fgets(Line, 64, File)==0) goto Error;
-  if(memcmp(Line, "MemFree:", 8)!=0) goto Error;
-  Free = atoi(Line+10);
-  fclose(File); return 0;
-Error:
-  fclose(File); return -1; }
-template <class Float>
- int getMemoryUsage(Float &Used) // get used RAM as a ratio
-{ int Total, Free;
-  int Error = getMemoryUsage(Total, Free); if(Error<0) return Error;
-  Used = (Float)(Total-Free)/Total; return 0; }
-
-// ===================================================================================================
-
-int getCpuUsage(int &DiffTotal, int &DiffUser, int &DiffSystem) // get CPU usage
-{ static int RefTotal=0, RefUser=0, RefSystem=0;
-  FILE *File=fopen("/proc/stat","rt"); if(File==0) return -1;
-  char Line[64];
-  if(fgets(Line, 64, File)==0) goto Error;
-  if(memcmp(Line, "cpu ", 4)!=0) goto Error;
-  int Total, User, Nice, System, Idle;
-  if(sscanf(Line+4, "%d %d %d %d", &User, &Nice, &System, &Idle)!=4) goto Error;
-  User+=Nice;
-  Total = User+System+Idle;
-  DiffTotal=Total-RefTotal; DiffUser=User-RefUser; DiffSystem=System-RefSystem;
-  RefTotal=Total; RefUser=User; RefSystem=System;
-  fclose(File); return 0;
-Error:
-  fclose(File); return -1; }
-
-int getCpuUsage(void)                       // get CPU usage - initialize
-{ int DiffTotal, DiffUser, DiffSystem; return getCpuUsage(DiffTotal, DiffUser, DiffSystem); }
-
-int getCpuUsage(float &User, float &System) // get CPU usage as ratios
-{ int DiffTotal, DiffUser, DiffSystem;
-  int Error=getCpuUsage(DiffTotal, DiffUser, DiffSystem); if(Error<0) return Error;
-  if(DiffTotal<=0) return -1;
-  User = (float)DiffUser/DiffTotal; System = (float)DiffSystem/DiffTotal; return 0; }
-
-// ===================================================================================================
-
-template <class Type>
- int getSysValue(Type &Value, const char *Name, const char *Format="%d")
-{ FILE *File=fopen(Name, "rt"); if(File==0) return -1;
-  int Ret=fscanf(File, Format, &Value);
-  fclose(File); return (Ret==1) ? 1:-2; }
-
-template <class Float>
- int getCpuTemperature(Float &Temperature)
-{ int IntValue;
-  if(getSysValue(IntValue, "/sys/class/thermal/thermal_zone0/temp", "%d")<0)
-  { if(getSysValue(IntValue, "/sys/class/hwmon/hwmon0/device/temp1_input", "%d")<0) return -1; }
-  Temperature=0.001*IntValue; return 0; }
-
-template <class Float>
- int getSupplyVoltage(Float &Voltage)
-{ int IntValue;
-  if(getSysValue(IntValue, "/sys/class/power_supply/ac/voltage_now", "%d")<0) return -1;
-  Voltage = 1e-6*IntValue; return 0; }
-
-template <class Float>
- int getSupplyCurrent(Float &Current)
-{ int IntValue;
-  if(getSysValue(IntValue, "/sys/class/power_supply/ac/current_now", "%d")<0) return -1;
-  Current = 1e-6*IntValue; return 0; }
-
-/*
-template <class Float>
- int getCpuTemperature(Float &Temperature)
-{ FILE *File=fopen("/sys/class/thermal/thermal_zone0/temp","rt"); if(File==0) return -1;
-  char Line[16];
-  if(fgets(Line, 16, File)==0) goto Error;
-  Temperature = 0.001*atoi(Line);
-  fclose(File); return 0;
-Error:
-  fclose(File); return -1; }
-*/
-// ===================================================================================================
-
-#if defined(__MACH__) || defined(__CYGWIN__) // for OSX we cannot read NTP status
-
-template <class Float>
- int getNTP(Float &Time, Float &EstError, Float &RefFreqCorr) { return -1; }
-
-#else
-template <class Float>
- int getNTP(Float &Time, Float &EstError, Float &RefFreqCorr)
-{ struct timex TimeX; TimeX.modes=0;
-  int Error=ntp_adjtime(&TimeX);
-  if(TimeX.status&STA_NANO)
-    Time = TimeX.time.tv_sec + 1e-9*TimeX.time.tv_usec;
-  else
-    Time = TimeX.time.tv_sec + 1e-6*TimeX.time.tv_usec;
-  EstError = 1e-6*TimeX.esterror;
-  RefFreqCorr = (Float)TimeX.freq/(1<<16);
-  return Error; }
-
-#endif // of __MACH__
-
-// ===================================================================================================
diff --git a/thread.h b/thread.h
deleted file mode 100644
index 49dda0a..0000000
--- a/thread.h
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
-    OGN - Open Glider Network - http://glidernet.org/
-    Copyright (c) 2015 The OGN Project
-
-    A detailed list of copyright holders can be found in the file "AUTHORS".
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this software.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __THREAD_H__
-#define __THREAD_H__
-
-#include <stdio.h>
-#include <unistd.h>
-#include <sys/time.h>
-#include <time.h>
-
-#include <pthread.h>
-#include <errno.h>
-
-#include <queue>
-
-// ======================================================================================
-
-class MutEx   // for Mutual Exclusive access to a resource
-{ private:
-   pthread_mutex_t muLock;
-
-  public:
-   MutEx() { Init(); }
-  ~MutEx() { Destroy(); }
-
-  private:
-   int Init(void)     { return pthread_mutex_init(&muLock, 0); }
-   int Destroy(void)  { return pthread_mutex_destroy(&muLock); }
-
-  public:
-   int Lock(void)     { return pthread_mutex_lock(&muLock); }        // gain access to the object (can block)
-   int Unlock(void)   { return pthread_mutex_unlock(&muLock); }      // release the access to the object
-   int TryLock(void)  { int Err=pthread_mutex_lock(&muLock);         // non-blocking attempt to lock
-                        return Err==EBUSY ? 1:Err; }                 // 0 => lock succesfull, 1 => already locked by someone
-} ;
-
-// ======================================================================================
-
-class Condition
-{ private:
-   pthread_cond_t      sigCond;
-   pthread_condattr_t  Attr;
-   pthread_mutex_t     muLock;
-
- public:
-  Condition() { Init(); }
- ~Condition() { Destroy(); }
-
-  private:
-   int Init(void)     { pthread_condattr_init(&Attr);
-#ifndef __MACH__ // _POSIX_TIMERS
-                        pthread_condattr_setclock( &Attr, CLOCK_MONOTONIC); // use monotonic clock for timed wait
-#endif
-                        if(pthread_cond_init(&sigCond, &Attr)!=0) return -1;
-                        return pthread_mutex_init(&muLock, 0); }
-   int Destroy(void)  { int Err=pthread_mutex_destroy(&muLock); if(Err!=0) return Err;
-                            Err=pthread_cond_destroy(&sigCond); if(Err!=0) return Err;
-                        pthread_condattr_destroy(&Attr); return 0; }
-
-  public:
-   int Lock(void)      { return pthread_mutex_lock(&muLock); }           // gain access to the object (can block)
-   int Unlock(void)    { return pthread_mutex_unlock(&muLock); }         // release the access to the object
-   int TryLock(void)   { int Err=pthread_mutex_lock(&muLock);            // non-blocking attempt to lock
-                         return Err==EBUSY ? 1:Err; }                    // 0 => lock succesfull, 1 => already locked by someone
-
-   int Signal(void)    { return pthread_cond_signal(&sigCond); }         // signal to at least one thread, that something has changed
-   int Broadcast(void) { return pthread_cond_broadcast(&sigCond); }      // signal to all threads, that something has changed
-   int Wait(void)      { return pthread_cond_wait(&sigCond, &muLock); }  // wait for a signal (can block)
-                                                                         // mutex must be locked while waiting
-#ifndef __MACH__ // _POSIX_TIMERS       // OSX has no clock_gettime() thus we need a different code here
-   int TimedWait(int usec)                                              // wait, but no longer than [usec]
-   { timespec Now; clock_gettime(CLOCK_MONOTONIC, &Now);
-                               // printf("clock_gettime(%ld.%06ld)\n", (long)(Now.tv_sec), (long)(Now.tv_nsec) );
-     timespec StopTime;
-     int sec=usec/1000000; usec-=sec*1000000; int nsec=usec*1000;
-                               // printf("%ld.%06ld = %ld.%09ld\n", sec, usec, sec, nsec);
-     StopTime.tv_sec  = Now.tv_sec  + sec;
-     StopTime.tv_nsec = Now.tv_nsec + nsec;
-     if(StopTime.tv_nsec>1000000000) { StopTime.tv_nsec-=1000000000; StopTime.tv_sec+=1; }
-                               // printf("StopTime = %ld.%09ld\n", (long)(StopTime.tv_sec), (long)(StopTime.tv_nsec));
-     return TimedWait(StopTime); }
-   int TimedWait(struct timespec &StopTime)                              // wait, but wakeup no later than [StopTime]
-   { return pthread_cond_timedwait(&sigCond, &muLock, &StopTime); }
-#endif
-
-} ;
-
-// ======================================================================================
-
-template <class Type>
- class MessageQueue
-{ public:
-   std::queue<Type> Queue;
-   Condition        Cond;
-
-  public:
-
-   int Push(Type Msg)
-   { Cond.Lock();
-     Queue.push(Msg); int Size=Queue.size();
-     Cond.Unlock();
-     Cond.Signal(); return Size; }
-
-   int Pop(Type &Msg)
-   { Cond.Lock();
-     while(Queue.empty()) Cond.Wait();
-     Msg = Queue.front();
-     Queue.pop(); int Size=Queue.size();
-     Cond.Unlock(); return Size; }
-
-   int Size(void)
-   { Cond.Lock();
-     int size = Queue.size();
-     Cond.Unlock();
-     return size; }
-
-} ;
-
-template <class Type>
- class ReuseObjectQueue           // this object queue holds objects
-{ public:                         // that can be reused - thus don't need to be created and deleted all the time
-   std::queue<Type *> Queue;      // objects in the queue
-   std::queue<Type *> Reuse;      // objects to be reused, these can be queued again
-   Condition          Cond;
-
-  public:
-
-  ~ReuseObjectQueue()
-   { while(!Queue.empty()) { delete Queue.front(); Queue.pop(); }
-     while(!Reuse.empty()) { delete Reuse.front(); Reuse.pop(); }
-   }
-
-   Type *New(void)                // vreate new object
-   { Cond.Lock();
-     Type *Obj;
-     if(Reuse.empty())
-     { Obj = new Type; }
-     else                         // but if possible take one from the Reuse queue
-     { Obj = Reuse.front(); Reuse.pop(); }
-     Cond.Unlock();
-     return Obj; }
-
-   void Push(Type *Obj)
-   { Cond.Lock();
-     Queue.push(Obj);
-     Cond.Unlock();
-     Cond.Signal(); }
-
-   Type *Pop(void)
-   { Cond.Lock();
-     while(Queue.empty()) Cond.Wait();
-     Type *Obj = Queue.front(); Queue.pop();
-     Cond.Unlock(); return Obj; }
-
-   void Recycle(Type *Obj)
-   { Cond.Lock();
-     Reuse.push(Obj);
-     Cond.Unlock();
-     Cond.Signal(); }
-
-   int Size(void)
-   { Cond.Lock();
-     int size = Queue.size();
-     Cond.Unlock();
-     return size; }
-
-} ;
-
-// ======================================================================================
-
-class Lock    // for multiple read-access and exclusive write-access to a resource
-{ private:
-   pthread_rwlock_t rwLock;
-
-  public:
-   Lock() { Init(); }
-  ~Lock() { Destroy(); }
-
-   int Init(void)     { return pthread_rwlock_init(&rwLock, 0); }
-   int Destroy(void)  { return pthread_rwlock_destroy(&rwLock); }
-
-   int ReadLock(void)  { return pthread_rwlock_rdlock(&rwLock); } // lock for read-only
-   int WriteLock(void) { return pthread_rwlock_wrlock(&rwLock); } // lock for read-write
-   int Unlock(void)    { return pthread_rwlock_unlock(&rwLock); } // unlock
-
-} ;
-
-// ======================================================================================
-
-class Thread
-{ private:
-   pthread_t ID;
-   void *(*Exec)(void *Context);
-
-  public:
-   Thread( void *(*Function)(void *) = 0) { ID=0; setExec(Function); }
-
-   void setExec( void *(*Function)(void *)) { Exec=Function; } // set the function to run by this thread
-
-   int Create(void *Context=0)                                 // create (start) this thread
-   { if(Exec==0) return -1;                                    // Exec function not set
-     if(ID) return -1;                                         // ID non-zero - a thread is running ?
-     return pthread_create(&ID, 0, Exec, Context); }
-
-   int Join(void)
-   { void *ExitStatus;
-     if(ID==0) return -1;                                      // ID zero - a thread is not running anymore ?
-     int Ret=pthread_join(ID, &ExitStatus);
-     ID=0; return Ret; }
-   int Join(void *&ExitStatus)                                 // wait for the thread to terminate
-   { if(ID==0) return -1;                                      // ID zero - a thread is NOT running anymore ?
-     int Ret=pthread_join(ID, &ExitStatus);                    // give back its termination status
-     ID=0; return Ret; }                                       // not clear how to behave if an error occures.
-
-   int Cancel(void)                                            // request to cancel the thread
-   { if(ID==0) return -1;                                      // ID zero - a thread is NOT running anymore ?
-     return pthread_cancel(ID); }
-
-   int getMaxPriority(int Policy=SCHED_FIFO)
-   { return sched_get_priority_max(Policy); }
-
-   int setPriority(int Priority, int Policy=SCHED_FIFO)
-   { struct sched_param params; params.sched_priority = Priority;
-     return pthread_setschedparam(ID, Policy, &params); }
-
-   int setPriority(int &Priority, int &Policy)
-   { struct sched_param params;
-     int Error=pthread_getschedparam(ID, &Policy, &params);
-     if(Error>=0) Priority=params.sched_priority;
-     return Error; }
-
-// ------------------------------------------------------------------------------------
-                                    // the following calls are by the running thread:
-   static int CancelEnable(void)                               // I CAN be cancelled
-   { int Old; return pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &Old); }
-   static int CancelDisable(void)                              // I CAN NOT be cancelled
-   { int Old; return pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &Old); }
-   static void TestCancel(void)                                // test, if I was cancelled
-   { pthread_testcancel(); }                                   // if I was: terminate
-
-} ;
-
-// ======================================================================================
-
-#endif // of __THREAD_H__
diff --git a/tonefilter.h b/tonefilter.h
deleted file mode 100644
index cb490c8..0000000
--- a/tonefilter.h
+++ /dev/null
@@ -1,91 +0,0 @@
-#include <string.h>
-
-#include "buffer.h"
-#include "boxfilter.h"
-
-template <class Float>
- class ToneFilter
-{ public:
-   int              FFTsize;
-   double           Threshold;
-
-   DFT1d<Float>     FwdFFT;
-   DFT1d<Float>     BwdFFT;
-   Float           *Window;
-   Float           *Sort;
-
-   SampleBuffer< std::complex<Float> > SpectraBuffer;
-   SampleBuffer<Float>                 SpectraPwr;
-
-   const static int PulseBoxRadius = 17;
-   const static int PulseBoxSize = 2*PulseBoxRadius+1;
-   BoxPeakSum<Float> PulseBox;
-
-   int Pulses;
-   Float Duty;
-
-  public:
-
-   ToneFilter() { PulseBox.Preset(PulseBoxSize);
-                  FFTsize=32768; Window=0; Sort=0; Duty=0; }
-
-  ~ToneFilter() { if(Window) free(Window);
-                  if(Sort)   free(Sort); }
-
-   int Preset(void)
-   { FwdFFT.PresetForward(FFTsize);
-     BwdFFT.PresetBackward(FFTsize);
-     Window=(Float *)realloc(Window, FFTsize*sizeof(Float));
-     Sort  =(Float *)realloc(Sort,   FFTsize*sizeof(Float));
-     FwdFFT.SetSineWindow(Window, FFTsize, (Float)(1.0/sqrt(FFTsize)) );
-     return 1; }
-
-   int Process(SampleBuffer< std::complex<Float> > *OutBuffer, SampleBuffer<uint8_t> *InpBuffer)
-   { Pulses=0;
-     SlidingFFT(SpectraBuffer, *InpBuffer, FwdFFT, Window);   // Process input samples, produce FFT spectra
-     SpectraPower(SpectraPwr, SpectraBuffer);                 // calculate spectra power
-                                                                // process spectra: remove coherent signals
-     int FFTslides = SpectraBuffer.Samples();                 // number of FFT slides in the input spectra
-     std::complex<Float> *Spectra = SpectraBuffer.Data;
-                  Float  *Pwr     = SpectraPwr.Data;
-     for(int Slide=0; Slide<FFTslides; Slide++)               // loop over FFT slides (or time)
-     { Pulses+=Process(Spectra, Pwr); Spectra+=FFTsize; Pwr+=FFTsize; }
-
-     ReconstrFFT(*OutBuffer, SpectraBuffer, BwdFFT, Window);  // reconstruct input samples
-     OutBuffer->Crop(FFTsize/2, FFTsize/2);
-     return Pulses; }
-/*
-     int Process(std::complex<Float> *Spectra, Float *Pwr)
-     { int Pulses=0;
-       memcpy(Sort, Pwr, FFTsize*sizeof(Float));
-       std::nth_element(Sort, Sort+FFTsize/2, Sort+FFTsize);
-       Float Median = Sort[FFTsize/2];
-       Float Thres = Threshold*Median;
-       for(int Bin=0; Bin<FFTsize; Bin++)                     // loop over frequency bins
-       { Float Power = Pwr[Bin];
-         if(Power>Thres) Spectra[Bin]*=sqrt(Thres/Power);
-         Pulses++; }
-       return Pulses; }
-*/
-     int Process(std::complex<Float> *Spectra, Float *Pwr)
-     { PulseBox.Clear();
-       int Pulses=0;
-       int Bin;
-       for(Bin=0; Bin<PulseBoxSize; Bin++)
-       { PulseBox.Process(Pwr[Bin]); }
-       for(     ; Bin<FFTsize;      Bin++)
-       { if(PulseBox.isAtPeak())
-         { Float PeakAmpl=PulseBox.PeakSum(1);
-           Float BkgNoise=(PulseBox.Sum-PeakAmpl)/(PulseBoxSize-3);
-           if(PeakAmpl>(Threshold*BkgNoise))
-           { int PeakBin=Bin-PulseBoxRadius-1;
-             Spectra[PeakBin]=0;
-             Spectra[PeakBin+1]*=0.5;
-             Spectra[PeakBin-1]*=0.5; }
-         }
-         PulseBox.Process(Pwr[Bin]); }
-       return Pulses; }
-
-
-} ;
-
-- 
2.1.4

